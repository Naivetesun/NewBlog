<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>var&#39;Blog</title>
    <link>https://naivete.cc/</link>
    <description>Recent content on var&#39;Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 06 Aug 2018 11:13:06 +0800</lastBuildDate>
    
	<atom:link href="https://naivete.cc/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>日记</title>
      <link>https://naivete.cc/%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/</link>
      <pubDate>Mon, 06 Aug 2018 11:13:06 +0800</pubDate>
      
      <guid>https://naivete.cc/%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/</guid>
      <description>乱七八糟的日记 2018-11月 日记写在博客还是麻烦、日记从此写在平时世界APP上。
2018-11-03-08 部分日记用手机端的平行世界上去了，比较方便写&amp;hellip;
2018-11-02 星期五 没课，
2018-11-01 星期四 写各种实验报告。
2018-10月 2018-10-29-31 这个月结束了。。。
2018-10-22-28 6天 这段时间不知道做了些什么，补了些乱七八糟的东西。打了一些乱七八糟的CTF。
2018-10-21 星期天 今天决定就把云计算的团队退了，以后就安心学移动安全和看一些IoT吧。补知识ing。
2018-10-18-20 咸鱼的生活，第八周了很多课要做大作业，还得赶。。
2018-10-17 星期三 雾霾w(ﾟДﾟ)w。
2018-10-15-16 课比较多的两天。花时间调库，补C++ing。
2018-10-14 星期天 昨晚又通宵了。早上起床困难。今天为了出题，试了一波音频隐写，jpg隐写，又配了一下抓包的环境。出了一道很简单的题。没达到想要的效果。
2018-10-13 星期六 终于周末了，护网杯打开-&amp;gt;护网杯结束。 电影院看了《无双》。over。
2018-10-10 - 12 赶作业+屁事不断。Helib库基本搞懂了，对二级制的加减乘除也基本搞懂了，会弄half adder -&amp;gt; full adder了。
2018-10-09 星期二 满课的一天，还要忙奖学金的事情。今天可以说是最烦的一天。做不完的事情，空闲时间都不知道用来干嘛了。
2018-10-08 星期一 上课生涯又开始了。早起的开始。无聊啊，这些课都没啥意义，像小白鼠一样的拿来做实验似的。
招新赛开始，题目还没出完，学了新的东西，忘记了旧的知识。。只打算出两道Android的。
2018-10-01 - 07 国庆7天，日记写在了：死肥宅的国庆节
2018-9月 2018-09-30 星期天  明天就是国庆节啦，提前祝节日快乐。不回家的我看来要宅个6天左右。。
 今天上了安全编程课，发现连基本的C++的忘记的差不多了，看来国庆得补补，而且同态加密论文的算法也应该用c++来实现，难度瞬间上升。正好国庆放假，每天稍微补一点知识吧。
  2018-09-29 星期六  从国庆开始，主要更新学习方面的东西，不再说那么多废话。
 今天除了上课的内容以外，在Twitter看到#flareon5,打算刷一下，卡在了第二关，真的菜，主要是一点都没接过.net的知识，还得补一些基础知识。才能看懂。主要看了两个工具一个dnSpy、一个ILSpy用来反汇编.net的程序。
 任务的论文是真的难看懂，同态加密的知识还得补补。之前上课讲的已经忘记得差不多了。C++开发的知识也得补补。也是忘记得差不多了。</description>
    </item>
    
    <item>
      <title>Pytorch学习_1安装</title>
      <link>https://naivete.cc/2018/12/08/pytorch%E5%AD%A6%E4%B9%A0_1%E5%AE%89%E8%A3%85/</link>
      <pubDate>Sat, 08 Dec 2018 23:40:51 +0800</pubDate>
      
      <guid>https://naivete.cc/2018/12/08/pytorch%E5%AD%A6%E4%B9%A0_1%E5%AE%89%E8%A3%85/</guid>
      <description>前言 本来想着用tensorflow的 然而GPU版总是报各种各样的BUG
所以打算入坑一下学pytorch
配置：win10+i76700HQ+GTX1060+16G
软件版本：CUDA10+python3.6+pytorch 1 源码编译
尝试1：官方安装方法不支持 CUDA 10 太坑，社区有编译通过的，所以只有自己编译试试
报各种异常，但是没停，那就等等
CPU被占满，巨卡。
一觉起来之后：安装失败
尝试2：等着完全支持CUDA10之后在用GPU跑吧。
妥协：用阿里云的学生服务器装了CPU的版本：顺便把TensorFlow 也给装了。。
然而 在一个星期之后 pytorch1.0出来了 支持了CUDA10 nice
pip3 install http://download.pytorch.org/whl/cu100/torch-1.0.0-cp36-cp36m-win_amd64.whl pip3 install torchvision  期间没有遇到任何问题 真舒畅。。。</description>
    </item>
    
    <item>
      <title>死肥宅的国庆节</title>
      <link>https://naivete.cc/2018/10/01/%E6%AD%BB%E8%82%A5%E5%AE%85%E7%9A%84%E5%9B%BD%E5%BA%86%E8%8A%82/</link>
      <pubDate>Mon, 01 Oct 2018 19:47:05 +0800</pubDate>
      
      <guid>https://naivete.cc/2018/10/01/%E6%AD%BB%E8%82%A5%E5%AE%85%E7%9A%84%E5%9B%BD%E5%BA%86%E8%8A%82/</guid>
      <description>七天国庆，死肥宅的日常修炼 10.1 昨晚大约3天才睡，第二天更是没精神。学了一个晚上Linux提权。
早上8点钟醒，下雨ing，开始懒床。又不小心睡着了。醒来已经是11点。起床，吃饭，打开电脑，开始了修炼的第一天。心里很是烦躁，天气又冷，好想回到被窝里继续暖着。（这才是死肥宅该过的日子）。
下午出去吃了碗米线，买了一些备战粮食，晚上继续刚。不弄懂坚决不睡觉！
10.2 停电时怎么一肥事。起床就发现停电了，电脑无法开机，手机没充电。热水也没有。好恐怖，随便洗漱，直接冲到实验室。
今天的打算是看完同态加密的那篇论文。然而，看完一脸懵逼，计组、电路、离散的知识早就不记得那么多了。明天继续理解，做点其他的吧。放松了一下。然后不小心把招新的网站调崩了，算了，睡觉去了。
10.3 不想通宵的晚上，聊着聊着就差不多2点了。早上起床失败，12点钟到实验室，真是怠惰呀。先把招新网站调好。话了好几个小时，终于搞完了。后面还是看论文。心累呀，作业还没做。计划的C++复习又耽搁了。zoom了一下，被指导之后忽然有点豁然开朗。明天真的要按计划完成作业。后面吧知识点补上，要补的知识点有：逻辑门运算，加法器相关知识、硬件上二进制的加减乘除。
10.4 今天也很元气满满的哟。早上不知道做了什么，中午吃了冒菜。下午好困，还是坚持看完了同态加密的BGV的基础知识，虽然还是有点懵逼，但是比之前完全懵逼好很多了。
 知识点：
  10.5 躺尸ing。C++知识补充ing。调HElib加密操作。终于是弄懂了这个库的基本操作。
10.6 搞一整天的HElib，二进制的XOR门什么的。作业什么的，完全没做呀。
10.7 不知不觉国庆长假（？）就没了，怎么感觉什么都没发生。。就没了？明天开学，今天补作业。</description>
    </item>
    
    <item>
      <title>UAF漏洞（释放后使用）学习记录</title>
      <link>https://naivete.cc/2018/09/12/uaf%E6%BC%8F%E6%B4%9E%E9%87%8A%E6%94%BE%E5%90%8E%E4%BD%BF%E7%94%A8%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</link>
      <pubDate>Wed, 12 Sep 2018 21:24:08 +0800</pubDate>
      
      <guid>https://naivete.cc/2018/09/12/uaf%E6%BC%8F%E6%B4%9E%E9%87%8A%E6%94%BE%E5%90%8E%E4%BD%BF%E7%94%A8%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Android应用安全防护和逆向分析-基础篇5-6</title>
      <link>https://naivete.cc/2018/08/29/android%E5%BA%94%E7%94%A8%E5%AE%89%E5%85%A8%E9%98%B2%E6%8A%A4%E5%92%8C%E9%80%86%E5%90%91%E5%88%86%E6%9E%90-%E5%9F%BA%E7%A1%80%E7%AF%875-6/</link>
      <pubDate>Wed, 29 Aug 2018 20:39:26 +0800</pubDate>
      
      <guid>https://naivete.cc/2018/08/29/android%E5%BA%94%E7%94%A8%E5%AE%89%E5%85%A8%E9%98%B2%E6%8A%A4%E5%92%8C%E9%80%86%E5%90%91%E5%88%86%E6%9E%90-%E5%9F%BA%E7%A1%80%E7%AF%875-6/</guid>
      <description>一、 基础篇⑤-⑥ 这两章主要描述AndroidManifest.xml和resourec.arsc这两个android文件。内容不是很多，下面是两章的笔记。
第五章 AndroidManifest.xml格式解析 AndroidManifest.xml文件格式图
头部信息  文件魔数：4bytes。
 文件大小：4bytes。
 Chunk内容 头部相同（ChunkType(4bytes)、ChunkSize(4bytes)）。
 Sting Chunk ：主要用于存放AndroidManifest.xml文件中所有的字符串信息。
 ChunkType：类型，固定4bytes（0x001C001)。
 ChunkSize：大小，4bytes。
 StringCount：字符串的个数 ，4bytes。
 StyleCount ：样式的个数，4bytes。
 Unknown ：位置区域。4bytes。
 StringPoolOffset ：字符串池的偏移值。4bytes。偏移值相对于StringChunk头部的位置。
 StylePoolOffset : 样式池的偏移值。4bytes。没有Style可忽略。
 StringOffsets ：每一个字符串的偏移值，大小为StringChunk*4。
 StyleOffsets：每个样式的偏移值，大小为StyleChunk*4。
  如何读取这个文件？
 Resourceld Chunk ：主要用来存放AndroidManifest 中用到的系统属性值对应的资源ID
 ChunkType：类型，固定4bytes（0x00080108）。
 ChunkSize：大小，4bytes。
 ResourceIds : 内容，大小为Resourceld Chunk大小除以4减去头部的8字节。
  解析？
 Start Namespace Chunk：主要包含了AndroidMaifest文件中的命名空间的内容，android中的xml都是采用Schema格式（两种格式DTD和Schema）的，所有肯定有Prefix和URI。
 Chunk Type：类型，固定4bytes。（0x00100100)。</description>
    </item>
    
    <item>
      <title>ARM汇编基础</title>
      <link>https://naivete.cc/2018/08/10/arm%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Fri, 10 Aug 2018 19:34:10 +0800</pubDate>
      
      <guid>https://naivete.cc/2018/08/10/arm%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80/</guid>
      <description>##ARM汇编基础(简)
经常忘记，做个笔记，好作复习。。
内容主要来源于《Android软件安全与逆向分析》和《逆向工程权威指南》以及 ARM 汇编 和Azeria-labs
ARM架构 ARM属于RISC CPU，
 ARM模式 4个字节opcode 32位
 Thumb模式 2个字节opcode 16位
 Thumb-2模式 同上（只是有部分4个字节的opcode)
 64位ARM 4个字节opcode
 ARM机器码在版本3之前是小端。但是之后默认采用大端格式，但可以设置切换到小端。
  数据类型 数据类型在汇编语言中的扩展后缀为-h或者-sh对应着半字，-b或者-sb对应着字节，但是对于字并没有对应的扩展
ldr = 加载字，宽度四字节 ldrh = 加载无符号的半字，宽度两字节 ldrsh = 加载有符号的半字，宽度两字节 ldrb = 加载无符号的字节 ldrsb = 加载有符号的字节 str = 存储字，宽度四字节 strh = 存储无符号的半字，宽度两字节 strsh = 存储有符号的半字，宽度两字节 strb = 存储无符号的字节 strsb = 存储有符号的字节  字节序 在内存中有两种字节排布顺序，大端序(BE)或者小端序(LE)。两者的主要不同是对象中的每个字节在内存中的存储顺序存在差异。一般X86中是小端序，最低的字节存储在最低的地址上。在大端机中最高的字节存储在最低的地址上。
数据访问时采取大端序还是小端序使用程序状态寄存器(CPSR)的第9比特位来决定的。
寄存器 37个32位寄存器，其中31个为基础寄存器，6个为状态寄存器。
用户模式下有
 不分组寄存器（R0-R7） R7一般存放系统调用号</description>
    </item>
    
    <item>
      <title>QEMU的安装使用</title>
      <link>https://naivete.cc/2018/08/09/qemu%E7%9A%84%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Thu, 09 Aug 2018 19:34:34 +0800</pubDate>
      
      <guid>https://naivete.cc/2018/08/09/qemu%E7%9A%84%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/</guid>
      <description>QEMU的安装使用 安装 WIndows：https://qemu.weilnetz.de/w64/ 下载exe安装就行
MACOS:brew install qemu or sudo port install qemu
LINUX：
 Arch: pacman -S qemu
 Debian/Ubuntu: apt-get install qemu
 Fedora: dnf install @virtualization
 Gentoo: emerge --ask app-emulation/qemu
 RHEL/CentOS: yum install qemu-kvm
 SUSE: zypper install qemu
  源码安装：https://download.qemu.org/
wget
wget https://download.qemu.org/qemu-3.0.0-rc1.tar.xz tar xvJf qemu-3.0.0-rc1.tar.xz cd qemu-3.0.0-rc1 ./configure make  git
git clone git://git.qemu.org/qemu.git cd qemu git submodule init git submodule update --recursive .</description>
    </item>
    
    <item>
      <title>在Android的个人字典中发现和利用漏洞(CVE 2018 9375)</title>
      <link>https://naivete.cc/2018/08/05/%E5%9C%A8android%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%AD%97%E5%85%B8%E4%B8%AD%E5%8F%91%E7%8E%B0%E5%92%8C%E5%88%A9%E7%94%A8%E6%BC%8F%E6%B4%9Ecve-2018-9375/</link>
      <pubDate>Sun, 05 Aug 2018 21:16:52 +0800</pubDate>
      
      <guid>https://naivete.cc/2018/08/05/%E5%9C%A8android%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%AD%97%E5%85%B8%E4%B8%AD%E5%8F%91%E7%8E%B0%E5%92%8C%E5%88%A9%E7%94%A8%E6%BC%8F%E6%B4%9Ecve-2018-9375/</guid>
      <description>翻译的文章
原作者：Daniel Kachakil
 我正在审计一款Android手机，审计范围是所有已经安装了的应用程序。我的首选方法是，在时间允许的时候，就手动检查尽可能多的代码。我发现了一个巧妙的漏洞，这个漏洞允许我与一个内容提供者交互，而该内容提供者应该在最近的Android版本中受到保护：用户的个人词典，它存储了用户想要保留的非标准单词的拼写。
虽然理论上应该只授权给特权用户、授权的输入法编辑器(IMEs) ，以及拼写检查程序访问用户的个人词典，但是有一种方法可以绕过这些限制，允许恶意应用程序更新、删除甚至检索字典内的所有内容。而不需要任何权限或者与用户交互。
这个中等风险的漏洞被归类为权限提升，并于2018年6月修复，影响到Android的以下版本：6.0、6.0.1、7.0、7.1.1、7.1.2、8.0和8.1。
用户的个人词典 Android提供了一个自定义词典，可以手动输入或者自动定制，从用户的输入中学习。这本字典的入口为“设置→ 语言和键盘 → 个人词典” （也可能在“高级“或者不同的选项下）。他可能包含有敏感信息，比如姓名、地址、电话号码、电子邮件、密码、商业品牌、不存常的词汇（可能包括疾病、药品、技术术语等），甚至信用卡号。
用户还可以为每个单词或者句子定义一个快捷方式，因此想要输入的家庭地址的时候，你可以添加一个条目并简单地为其添加一个快捷方式（比如“myhome”）来自动完成填写。
在内部，这些单词存储在SQLLite数据库中，该数据库只包含有一个名为“words”的表（除了“android_metadata” ），这个表有6列：
 _id (INTEGER, PRIMARY KEY)
 word (TEXT)
 frequency (INTEGER)
 locale (TEXT)
 appid (INTEGER)
 shortcut (TEXT)
  我们主要注意“word&amp;rdquo;这列，正如名称所示，它包含了自定义的单词。然而，同一数据库中所有剩余的列和表也可以访问。
漏洞细节 在较早版本的Android中，对个人字典的读写访问分别受到以下权限的保护：
 android.permission.READ_USER_DICTIONARY
 android.permission.WRITE_USER_DICTIONARY
  对于新版本来说，这已经不再适用了，根据官方文档[1]:&amp;ldquo;从API 23开始，用户字典只能通过IME和拼写检查器访问” ，以前的权限已经被内部检查所取代，因此理论上，只有特权帐户(比如 root 和 system), 启用的IMEs和拼写检查器可以访问个人字典内容提供者 (content://user_dictionary/words)。
我们可以检查AOSP代码库，查看一个变更[2]中引入了一个新的名为canCallerAccessUserDictionary 的私有函数，并从 UserDictionary 内容提供者中的所有标准查询、插入、更新和删除函数中调用该函数，以防止对这些函数的未经授权的调用。
虽然更改似乎对查询和插入函数都有效，但是在更新和删除过程中，授权检查发生滞后引入了安全漏洞，允许任何应用程序通过公开的内容提供者成功地调用受影响的函数，从而绕过错误的授权检查。
在下面的 UserDictionaryProvider类[3]的代码中，注意高亮（标注在注释）的片段，查看在数据库已经被修改之后如何执行授权检查：
@Override public int delete(Uri uri, String where, String[] whereArgs) { SQLiteDatabase db = mOpenHelper.</description>
    </item>
    
    <item>
      <title>(转)Android Inline Hook中的指令修复详解</title>
      <link>https://naivete.cc/2018/07/30/%E8%BD%ACandroid-inline-hook%E4%B8%AD%E7%9A%84%E6%8C%87%E4%BB%A4%E4%BF%AE%E5%A4%8D%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Mon, 30 Jul 2018 15:03:41 +0800</pubDate>
      
      <guid>https://naivete.cc/2018/07/30/%E8%BD%ACandroid-inline-hook%E4%B8%AD%E7%9A%84%E6%8C%87%E4%BB%A4%E4%BF%AE%E5%A4%8D%E8%AF%A6%E8%A7%A3/</guid>
      <description>前言  本文是另一篇《Android Native Hook工具实践》的一份补充文章，本人建议各位学习者先去看该篇主文以了解本文的需求背景。本文将会对该文中指令修复部分的技术细节进行阐述。本文的部分源码来自于ele7enxxh大神的项目，由于大神的技术博客里解释省略了较多细节，所以出于学习的目的，本人也会一点一点慢慢啃。同时由于该库并不完善，因此本文将补充该库没考虑到的一些修复指令方案，并且对许多特殊状况和Bug也尽力解决。
 目前需要进行指令修复的ARM32指令主要可以分为如下几类：
 BLX_ARM, BL_ARM, B_ARM（不包含条件跳转）, BX_ARM
 条件跳转BEQ_ARM BNE_ARM BCS_ARM BCC_ARM BMI_ARM BPL_ARM BVS_ARM BVC_ARM BHI_ARM BLS_ARM BGE_ARM BLT_ARM BGT_ARM BLE_ARM
 ADD_ARM
 ADR_ARM, LDR_ARM, MOV_ARM
 其它指令 OTHER_ARM
  Thumb16指令主要可以分为如下几类：
 B1_THUMB16（不包含条件跳转）, B2_THUMB16, BX_THUMB16
 条件跳转B1_BEQ_THUMB16, B1_BNE_THUMB16, B1_BCS_THUMB16, B1_BCC_THUMB16, B1_BMI_THUMB16, B1_BPL_THUMB16, B1_BVS_THUMB16, B1_BVC_THUMB16, B1_BHI_THUMB16, B1_BLS_THUMB16, B1_BGE_THUMB16, B1_BLT_THUMB16, B1_BGT_THUMB16, B1_BLE_THUMB16
 ADD_THUMB16
 MOV_THUMB16, ADR_THUMB16, LDR_THUMB16
 其它指令 OTHER_THUMB16
  Thumb32指令主要可以分为如下几类：</description>
    </item>
    
    <item>
      <title>(转)Android Native Hook工具实践</title>
      <link>https://naivete.cc/2018/07/30/%E8%BD%ACandroid-native-hook%E5%B7%A5%E5%85%B7%E5%AE%9E%E8%B7%B5/</link>
      <pubDate>Mon, 30 Jul 2018 14:48:12 +0800</pubDate>
      
      <guid>https://naivete.cc/2018/07/30/%E8%BD%ACandroid-native-hook%E5%B7%A5%E5%85%B7%E5%AE%9E%E8%B7%B5/</guid>
      <description>前言 在目前的安卓APP测试中对于Native Hook的需求越来越大，越来越多的APP开始逐渐使用NDK来开发核心或者敏感代码逻辑。个人认为原因如下：
 安全的考虑。各大APP越来越注重安全性，NDK所编译出来的so库逆向难度明显高于java代码产生的dex文件。越是敏感的加密算法与数据就越是需要用NDK进行开发。
 性能的追求。NDK对于一些高性能的功能需求是java层无法比拟的。
 手游的兴起。虚幻4，Unity等引擎开发的手游中都有大量包含游戏逻辑的so库。
  因此，本人调查了一下Android Native Hook工具目前的现状。尽管Java层的Hook工具多种多样，但是Native Hook的工具却非常少并且在安卓5.0以上的适配工具更是寥寥无几。（文末说明1）而目前Native Hook主要有两大技术路线：
 PLT Hook
 Inline Hook
  这两种技术路线本人都实践了一下，关于它们的对比，我在《Android Native Hook技术路线概述》中有介绍，所以这里就不多说了。最终，我用了Inline Hook来做这个项目。
本文篇幅已经较长，因此写了一些独立的学习笔记来对其中的细节问题进行解释：
 《Android Native Hook技术路线概述》
 《Android Inline Hook中的指令修复》
 项目仓库
 项目案例——Arm32
 项目案例——Thumb-2
  目标效果 根据本人自身的使用需求提出了如下几点目标：
 工具运行原理中不能涉及调试目标APP，否则本工具在遇到反调试措施的APP时会失效。尽管可以先去逆向调试patch掉反调试功能，但是对于大多数情况下只是想看看参数和返回值的Hook需求而言，这样的前期处理实在过于麻烦。
 依靠现有的各大Java Hook工具就能运行本工具，换句话说就是最好能用类似这些工具的插件的形式加载起本工具从而获得Native Hook的能力。由于Java Hook工具如Xposed、YAHFA等对于各个版本的Android都做了不错的适配，因此利用这些已有的工具即可向目标APP的Native层中注入我们的Hook功能将会方便很多小伙伴的使用。
 既然要能够让各种Java Hook工具都能用本工具得到Native Hook的能力，那就这个工具就要有被加载起来以后自动执行自身功能逻辑的能力！而不是针对各个Java Hook工具找调用起来的方式。
 要适配Android NDK下的armv7和thumb-2指令集。由于现在默认编译为thumb-2模式，所以对于thumb16和thumb32的Native Hook支持是重中之重。
 修复Inline Hook后的原本指令。
 Hook目标的最小单位至少是函数，最好可以是某行汇编代码。
  最终方案 最后完成项目的方案是：本工具是一个so库。用Java Hook工具在APP的入口Activity运行一开始的onCreate方法处Hook，然后加载本so。 加载后，自动开始执行Hook逻辑。 为了方便叙述，接下来的Java Hook工具我就使用目前这类工具里最流行的Xposed，本项目的生成文件名为libautohook.</description>
    </item>
    
    <item>
      <title>Java反射机制学习笔记</title>
      <link>https://naivete.cc/2018/07/25/java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Wed, 25 Jul 2018 16:40:20 +0800</pubDate>
      
      <guid>https://naivete.cc/2018/07/25/java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</guid>
      <description>Java 反射机制学习记录 在逆向中反射也是能经常看见，之前理解不是很深透，现在来重点学习一下，做个笔记。
什么是反射机制？ 反射(Reflection)是Java 程序开发语言的特征之一，它允许运行中的 Java 程序获取自身的信息，并且可以操作类或对象的内部属性。 通俗一点：在动态运行时，获取到一个类的所有方法以及成员。简而言之，通过反射，我们可以在运行时获得程序或程序集中每一个类型的成员和成员的信息。
作用？  1.在运行时判断任意一个对象所属的类；
 2.在运行时构造任意一个类的对象；
 3.在运行时判断任意一个类所具有的成员变量和方法（通过反射甚至可以调用private方法）；
 4.在运行时调用任意一个对象的方法
  是运行时而不是编译时  获取某些类的一些变量，调用某些类的私有方法。
 增加代码的灵活性。很多主流框架都使用了反射技术.像ssh框架都采用两种技术 xml做配置文件+反射技术.
  基本使用 反射相关的类一般都在java.lang.relfect 包里。
 获取Class对象 3种方法
  (1)使用Class类的forName静态方法:
public static Class&amp;lt;?&amp;gt; forName(String className) //在JDBC开发中常用此方法加载数据库驱动: Class.forName(driver);  (2)直接获取某一个对象的class，比如:
Class&amp;lt;?&amp;gt; klass = int.class; Class&amp;lt;?&amp;gt; classInt = Integer.TYPE;  (3)调用某个对象的getClass()方法,比如:
StringBuilder str = new StringBuilder(&amp;quot;123&amp;quot;); Class&amp;lt;?&amp;gt; klass = str.getClass();   判断是否为某一个类的实例
  一般使用instanceof来判断，也可以借助反射中的Class对象的isInstance()方法来判断 是一个Native方法：</description>
    </item>
    
    <item>
      <title>Android应用安全防护和逆向分析-基础篇④</title>
      <link>https://naivete.cc/2018/07/22/android%E5%BA%94%E7%94%A8%E5%AE%89%E5%85%A8%E9%98%B2%E6%8A%A4%E5%92%8C%E9%80%86%E5%90%91%E5%88%86%E6%9E%90-%E5%9F%BA%E7%A1%80%E7%AF%87/</link>
      <pubDate>Sun, 22 Jul 2018 14:15:38 +0800</pubDate>
      
      <guid>https://naivete.cc/2018/07/22/android%E5%BA%94%E7%94%A8%E5%AE%89%E5%85%A8%E9%98%B2%E6%8A%A4%E5%92%8C%E9%80%86%E5%90%91%E5%88%86%E6%9E%90-%E5%9F%BA%E7%A1%80%E7%AF%87/</guid>
      <description>一、 基础篇④ 第四章 so文件格式解析  ELF文件格式
  so文件-&amp;gt;elf文件，文件格式看图（引用自@非虫）：
 解析工具
 readelf 常用命令
 readelf -h xxx.so 查头部信息
 readelf -S xxx.so 查节（Section）信息
 readelf -l xxx.so 查段（Program）信息
 readelf -a xxx.so 查全部信息
   解析ELF文件
  动手解析一个elf文件 。。。
太水 这里的内容
直接去看源码实现用java解析elf文件信息https://github.com/fourbrother/parse_androidso
ELF 相关内容还是单独详细分析 单独写一篇吧
ELF书籍《Linux二进制分析》
### 总结
加固脱壳必须掌握的知识点。</description>
    </item>
    
    <item>
      <title>Android应用安全防护和逆向分析 基础篇③</title>
      <link>https://naivete.cc/2018/07/16/android%E5%BA%94%E7%94%A8%E5%AE%89%E5%85%A8%E9%98%B2%E6%8A%A4%E5%92%8C%E9%80%86%E5%90%91%E5%88%86%E6%9E%90-%E5%9F%BA%E7%A1%80%E7%AF%87/</link>
      <pubDate>Mon, 16 Jul 2018 13:51:50 +0800</pubDate>
      
      <guid>https://naivete.cc/2018/07/16/android%E5%BA%94%E7%94%A8%E5%AE%89%E5%85%A8%E9%98%B2%E6%8A%A4%E5%92%8C%E9%80%86%E5%90%91%E5%88%86%E6%9E%90-%E5%9F%BA%E7%A1%80%E7%AF%87/</guid>
      <description>一、 基础篇③ 第三章 Android中开发与逆向常用命令总结 1. 基础命令 1.1 cat命令 ​ 查看文件内容 结合grep进行过滤
1.2 echo/touch命令 ​ 写文件 配个定向符使用
2. 非shell命令 2.1 adb shell dumpsys sctivity top ​ 说明：查看当前应用的activity信息
​ 用法：运行需要查看的应用
​ 如果直接运行 adb shell dmpsys会把当前系统中的所有应用运行的四大组件都打印出来 内容非常多 使用信息重定向来进行选择：可借助Windows的start命令
2.2 adb shell dumpsys package ​ 说明：查看指定包名应用的详细信息 （相当于AndroidManifest.xml的内容）
​ 用法：adb shell dumpsys package [pkgname]
2.3 adb shell dumpsys meminfo ​ 说明：查看指定进程名或者进程id的内存信息
​ 用法：adb shell dumpsys meminfo [pname/pid]
​ 和后面的top命令结合使用 可以分析应用的性能消耗情况
2.4 adb shell dump dbnfo ​ 说明：查看指定包名应用的数据库存储信息（包括存储的SQL语句）</description>
    </item>
    
    <item>
      <title>Android应用安全防护和逆向分析 基础篇②</title>
      <link>https://naivete.cc/2018/07/13/android%E5%BA%94%E7%94%A8%E5%AE%89%E5%85%A8%E9%98%B2%E6%8A%A4%E5%92%8C%E9%80%86%E5%90%91%E5%88%86%E6%9E%90-%E5%9F%BA%E7%A1%80%E7%AF%87/</link>
      <pubDate>Fri, 13 Jul 2018 15:01:09 +0800</pubDate>
      
      <guid>https://naivete.cc/2018/07/13/android%E5%BA%94%E7%94%A8%E5%AE%89%E5%85%A8%E9%98%B2%E6%8A%A4%E5%92%8C%E9%80%86%E5%90%91%E5%88%86%E6%9E%90-%E5%9F%BA%E7%A1%80%E7%AF%87/</guid>
      <description>一、 基础篇② 第二章 Android中NDK的开发 1. 相关环境 相关环境参考另外一篇文章Android安全和开发环境搭建
2. JNI基础 2.1 第一行代码(书上使用Eclipse,我使用AS(简单方便很多)) ​ 参考文章Android安全和开发环境搭建中的JNI开发章节
2.2 JNIEnv类型和jobject类型  AS 默认自动生成
  public native String stringFromJNI();  Java_com_naivete_jni_1study_MainActivity_stringFromJNI( JNIEnv *env, jobject /* this */) { std::string hello = &amp;quot;Hello from C++&amp;quot;; return env-&amp;gt;NewStringUTF(hello.c_str());   JNIEnv类型
  通过JNIEnv* 指针就可以对Java端的代码进行操作
Jni的所有函数可以查看jni.h文件
下面是一些函数eg：
 NewObject : 创建Java类中的对象。
 NewString : 创建Java类中的String对象。
 NewArray : 创建类型为Type的数组对象
 GetField: 获取型为Type的字段。
 SetFileld: 设置类型为Type的字段的值。
 GetStaticField: 获取类型为Type的static的字段。</description>
    </item>
    
    <item>
      <title>Android安全和开发环境搭建</title>
      <link>https://naivete.cc/2018/07/05/android%E5%AE%89%E5%85%A8%E5%92%8C%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</link>
      <pubDate>Thu, 05 Jul 2018 17:35:46 +0800</pubDate>
      
      <guid>https://naivete.cc/2018/07/05/android%E5%AE%89%E5%85%A8%E5%92%8C%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</guid>
      <description>Android安全和开发环境搭建  补充中·····
JAVA环境   JDK下载与安装。
 环境变量配置
  Android Studio  官网下载（扶墙）
 SDK
  NDK（JNI）开发  NDK下载
 使用
  Eclipse (还是推荐上面的AS) 不喜欢界面，弃用。</description>
    </item>
    
    <item>
      <title>CTF</title>
      <link>https://naivete.cc/ctf/</link>
      <pubDate>Mon, 02 Jul 2018 18:20:34 +0800</pubDate>
      
      <guid>https://naivete.cc/ctf/</guid>
      <description> CTF题目汇总  个人搭建平台
 MISC
 
  RE
 
  PWN
 
  Crypto
 
  Web
 
   </description>
    </item>
    
    <item>
      <title>Android应用安全防护和逆向分析 基础篇①</title>
      <link>https://naivete.cc/2018/07/02/android%E5%BA%94%E7%94%A8%E5%AE%89%E5%85%A8%E9%98%B2%E6%8A%A4%E5%92%8C%E9%80%86%E5%90%91%E5%88%86%E6%9E%90-%E5%9F%BA%E7%A1%80%E7%AF%87/</link>
      <pubDate>Mon, 02 Jul 2018 17:33:05 +0800</pubDate>
      
      <guid>https://naivete.cc/2018/07/02/android%E5%BA%94%E7%94%A8%E5%AE%89%E5%85%A8%E9%98%B2%E6%8A%A4%E5%92%8C%E9%80%86%E5%90%91%E5%88%86%E6%9E%90-%E5%9F%BA%E7%A1%80%E7%AF%87/</guid>
      <description>第一章 Android中锁屏密码加密算法分析 1. 锁屏密码方式：  手势
 九宫格连线
 输入密码
 指纹、人脸、虹膜
 可穿戴设备
  2. 这儿分析手势密码和输入密码 找到android源代码中的LockPatternUtils,java 这个工具类
路径：Android-5.1.1\frameworks\base\core\java\com\android\internal\widget
 2.1 输入密码算法分析 (5.1版本的源代码 和书上细微差异)
 public byte[] passwordToHash(String password, int userId) {//参数为密码和对应用户ID 默认0 if (password == null) { return null; } try { byte[] saltedPassword = (password + getSalt(userId)).getBytes(); byte[] sha1 = MessageDigest.getInstance(&amp;quot;SHA-1&amp;quot;).digest(saltedPassword); byte[] md5 = MessageDigest.getInstance(&amp;quot;MD5&amp;quot;).digest(saltedPassword); //首先让 password+salt值 再SHA-1和MD5 byte[] combined = new byte[sha1.length + md5.length]; System.</description>
    </item>
    
    <item>
      <title>New Blog</title>
      <link>https://naivete.cc/2018/07/02/new-blog/</link>
      <pubDate>Mon, 02 Jul 2018 17:31:24 +0800</pubDate>
      
      <guid>https://naivete.cc/2018/07/02/new-blog/</guid>
      <description> 关于这个新博客 折腾了两天，终于弄得差不多了，接下来只差把自动化部署搞定就OK啦。。  先列个计划：
 以后就一直维护，不改了，先列一个flag
 后面吧相关文章转过来
 尽量更新吧
 以后总结就更新过来吧 微信公众号同步更新
  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://naivete.cc/%E5%8F%8B%E9%93%BE/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://naivete.cc/%E5%8F%8B%E9%93%BE/</guid>
      <description> 友链  []()
  </description>
    </item>
    
  </channel>
</rss>