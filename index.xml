<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Vorblock&#39;Blog</title>
    <link>https://naivete.cc/</link>
    <description>Recent content on Vorblock&#39;Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 06 Aug 2018 11:13:06 +0800</lastBuildDate>
    
	<atom:link href="https://naivete.cc/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>日记</title>
      <link>https://naivete.cc/%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/</link>
      <pubDate>Mon, 06 Aug 2018 11:13:06 +0800</pubDate>
      
      <guid>https://naivete.cc/%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/</guid>
      <description>乱七八糟的日记 2018-11月 日记写在博客还是麻烦、日记从此写在平时世界APP上。
2018-11-03-08 部分日记用手机端的平行世界上去了，比较方便写&amp;hellip;
2018-11-02 星期五 没课，
2018-11-01 星期四 写各种实验报告。
2018-10月 2018-10-29-31 这个月结束了。。。
2018-10-22-28 6天 这段时间不知道做了些什么，补了些乱七八糟的东西。打了一些乱七八糟的CTF。
2018-10-21 星期天 今天决定就把云计算的团队退了，以后就安心学移动安全和看一些IoT吧。补知识ing。
2018-10-18-20 咸鱼的生活，第八周了很多课要做大作业，还得赶。。
2018-10-17 星期三 雾霾w(ﾟДﾟ)w。
2018-10-15-16 课比较多的两天。花时间调库，补C++ing。
2018-10-14 星期天 昨晚又通宵了。早上起床困难。今天为了出题，试了一波音频隐写，jpg隐写，又配了一下抓包的环境。出了一道很简单的题。没达到想要的效果。
2018-10-13 星期六 终于周末了，护网杯打开-&amp;gt;护网杯结束。 电影院看了《无双》。over。
2018-10-10 - 12 赶作业+屁事不断。Helib库基本搞懂了，对二级制的加减乘除也基本搞懂了，会弄half adder -&amp;gt; full adder了。
2018-10-09 星期二 满课的一天，还要忙奖学金的事情。今天可以说是最烦的一天。做不完的事情，空闲时间都不知道用来干嘛了。
2018-10-08 星期一 上课生涯又开始了。早起的开始。无聊啊，这些课都没啥意义，像小白鼠一样的拿来做实验似的。
招新赛开始，题目还没出完，学了新的东西，忘记了旧的知识。。只打算出两道Android的。
2018-10-01 - 07 国庆7天，日记写在了：死肥宅的国庆节
2018-9月 2018-09-30 星期天  明天就是国庆节啦，提前祝节日快乐。不回家的我看来要宅个6天左右。。
 今天上了安全编程课，发现连基本的C++的忘记的差不多了，看来国庆得补补，而且同态加密论文的算法也应该用c++来实现，难度瞬间上升。正好国庆放假，每天稍微补一点知识吧。
  2018-09-29 星期六  从国庆开始，主要更新学习方面的东西，不再说那么多废话。
 今天除了上课的内容以外，在Twitter看到#flareon5,打算刷一下，卡在了第二关，真的菜，主要是一点都没接过.net的知识，还得补一些基础知识。才能看懂。主要看了两个工具一个dnSpy、一个ILSpy用来反汇编.net的程序。
 任务的论文是真的难看懂，同态加密的知识还得补补。之前上课讲的已经忘记得差不多了。C++开发的知识也得补补。也是忘记得差不多了。</description>
    </item>
    
    <item>
      <title>Frida从入门到放弃_2</title>
      <link>https://naivete.cc/2019/02/02/frida%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83_2/</link>
      <pubDate>Sat, 02 Feb 2019 20:39:26 +0800</pubDate>
      
      <guid>https://naivete.cc/2019/02/02/frida%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83_2/</guid>
      <description> 补充ing
  </description>
    </item>
    
    <item>
      <title>Frida从入门到放弃_1</title>
      <link>https://naivete.cc/2019/01/22/frida%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83_1/</link>
      <pubDate>Tue, 22 Jan 2019 20:39:26 +0800</pubDate>
      
      <guid>https://naivete.cc/2019/01/22/frida%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83_1/</guid>
      <description>0x00 Frida Frida 官网：https://www.frida.re/
github: https://github.com/frida/frida
Dynamic instrumentation toolkit for developers, reverse-engineers, and security
researchers.
0x01 安装 用python
pip install frida-tools 就一个命令搞定
 Failed to load the Frida native extension: DLL load failed: 找不到指定的模块
报了这个错 查了大半天 原来我用的版本是基于python3.7编译的。我现在用的3.6.。。。。
作者真的是脑子一根筋。。。 所以只好升级成3.7.。。。
 0x02 Android环境 设备：小米mix2 运行Android8.0 MIUI10开发版已解锁root
frida-server: 用的arm64版本
下载号frida-server 然后adb push 进去
adb push frida-server /data/local/tmp
然后chomd 755 frida-server
运行./frida-server
命令行运行frida-ps -U
安装成功</description>
    </item>
    
    <item>
      <title>radare2&#43;cutter使用指南</title>
      <link>https://naivete.cc/2019/01/02/radare2-cutter%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</link>
      <pubDate>Wed, 02 Jan 2019 20:39:26 +0800</pubDate>
      
      <guid>https://naivete.cc/2019/01/02/radare2-cutter%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</guid>
      <description>0x00 介绍 radare2 一个很实用的二进制分析和调试工具
cutter 是r2的GUI版。
0x01 安装 支持的平台有如下：
 Windows (since XP), GNU/Linux, OS X, [Net|Free|Open]BSD,
Android, iOS, OSX, QNX, Solaris, Haiku, FirefoxOS.
 Linux平台下直接
git clone https://github.com/radare/radare2 cd radare2 sys/install.sh //(or sys/user.sh)  Windows下可以下载二进制安装包安装。官网下载
Windows用户推荐使用Windows下的linux（wsl）来使用， win下更新慢。还是linux下用得舒服（方便，快捷）。
0x03 工具介绍 r2常用的包含有一下组件：
 rax2 用于数值转换
 rasm2 反汇编和汇编
 rabin2 查看文件格式
 radiff2 对文件进行 diff
 ragg2/ragg2­cc 开发shellcode工具
 rahash2 各种密码算法， hash算法
 radare2 整合了所有工具
  使用帮助直接-h
 rax2</description>
    </item>
    
    <item>
      <title>Pytorch学习_1安装</title>
      <link>https://naivete.cc/2018/12/08/pytorch%E5%AD%A6%E4%B9%A0_1%E5%AE%89%E8%A3%85/</link>
      <pubDate>Sat, 08 Dec 2018 23:40:51 +0800</pubDate>
      
      <guid>https://naivete.cc/2018/12/08/pytorch%E5%AD%A6%E4%B9%A0_1%E5%AE%89%E8%A3%85/</guid>
      <description>前言 本来想着用tensorflow的 然而GPU版总是报各种各样的BUG
所以打算入坑一下学pytorch
配置：win10+i76700HQ+GTX1060+16G
软件版本：CUDA10+python3.6+pytorch 1 源码编译
尝试1：官方安装方法不支持 CUDA 10 太坑，社区有编译通过的，所以只有自己编译试试
报各种异常，但是没停，那就等等
CPU被占满，巨卡。
一觉起来之后：安装失败
尝试2：等着完全支持CUDA10之后在用GPU跑吧。
妥协：用阿里云的学生服务器装了CPU的版本：顺便把TensorFlow 也给装了。。
然而 在一个星期之后 pytorch1.0出来了 支持了CUDA10 nice
pip3 install http://download.pytorch.org/whl/cu100/torch-1.0.0-cp36-cp36m-win_amd64.whl pip3 install torchvision  期间没有遇到任何问题 真舒畅。。。</description>
    </item>
    
    <item>
      <title>PWN 小tools的使用</title>
      <link>https://naivete.cc/2018/10/22/pwn-%E5%B0%8Ftools%E7%9A%84%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Mon, 22 Oct 2018 20:39:26 +0800</pubDate>
      
      <guid>https://naivete.cc/2018/10/22/pwn-%E5%B0%8Ftools%E7%9A%84%E4%BD%BF%E7%94%A8/</guid>
      <description>GCC 编译常用命令    不带选项  gcc test.c 将test.c预处理、汇编、编译并链接形成可执行文件。这里未指定输出文件，默认输出为a.out。     -o 指定生成的输出文件； gcc test.c -o test 将test.c预处理、汇编、编译并链接形成可执行文件test。-o选项用来指定输出文件的文件名。   -E 仅执行编译预处理； gcc -E test.c -o test.i 将test.c预处理输出test.i文件。   -S 将C代码转换为汇编代码； gcc -S test.i 将预处理输出文件test.i汇编成test.s文件。   -c 仅执行编译操作，不进行连接操作。 gcc -c test.s 将汇编输出文件test.s编译输出test.o文件。   -wall 显示警告信息；    无选项链接  gcc test.o -o test 将编译输出文件test.o链接成最终可执行文件test。   -O 使用编译优化级别1编译程序。级别为1~3，级别越大优化效果越好，但编译时间越长 gcc -O1 test.c -o test    关掉DEP/NX（堆栈不可执行） gcc -z execstack -o level level.</description>
    </item>
    
    <item>
      <title>Android-ARM进阶</title>
      <link>https://naivete.cc/2018/10/10/android-arm%E8%BF%9B%E9%98%B6/</link>
      <pubDate>Wed, 10 Oct 2018 16:40:20 +0800</pubDate>
      
      <guid>https://naivete.cc/2018/10/10/android-arm%E8%BF%9B%E9%98%B6/</guid>
      <description>学习一些关于ARM的汇编结构特点，以及分析。理解一些结构最好的方法就是多去尝试动手做。。
NDK-Build的使用 可以参考官方文档。
 创建一个Android项目
 cd 项目目录
 /ndk-build 。也可以将NDK-build加入环境变量。
 创建jni文件夹，添加 Android.mk和 Application.mk两个文件。（参考官方文档）
  //Android.mk LOCAL_PATH := $(call my-dir) include $(CLEAR_VARS) # 要生成的.so库名称 LOCAL_MODULE := hello # c++文件 LOCAL_SRC_FILES := hello.cpp include $(BUILD_SHARED_LIBRARY)  //Application.mk APP_PLATFORM := android-17 # APP_ABI := all APP_ABI :=armeabi-v7a arm64-v8a  添加hello.cpp：
#include&amp;lt;cstdio&amp;gt; int i,j; int num[] = {1,2,3,4,5}; int main() { /* code */ printf(&amp;quot;hello,world!\n&amp;quot;); for(i=0;i&amp;lt;5;i++){ printf(&amp;quot;num value is %d\n&amp;quot;,num[i]); } return 0; }   ndk-build</description>
    </item>
    
    <item>
      <title>UAF漏洞（释放后使用）学习记录</title>
      <link>https://naivete.cc/2018/09/12/uaf%E6%BC%8F%E6%B4%9E%E9%87%8A%E6%94%BE%E5%90%8E%E4%BD%BF%E7%94%A8%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</link>
      <pubDate>Wed, 12 Sep 2018 21:24:08 +0800</pubDate>
      
      <guid>https://naivete.cc/2018/09/12/uaf%E6%BC%8F%E6%B4%9E%E9%87%8A%E6%94%BE%E5%90%8E%E4%BD%BF%E7%94%A8%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</guid>
      <description>打回重写
  0x00原理 堆内存在释放后被直接再次使用(释放了堆块之后，未将该指针值为NULL,导致指针处于悬空状态，被释放的内存能被恶意利用) 在浏览器中比较常见的漏洞
根本原因是：
 应用程序调用free()释放内存时，如果内存块小于256kb，dlmalloc并不马上将内存块释放回内存，而是将内存块标记为空闲状态。这么做的原因有两个：一是内存块不一定能马上释放会内核（比如内存块不是位于堆顶端），二是供应用程序下次申请内存使用（这是主要原因）。当dlmalloc中空闲内存量达到一定值时dlmalloc才将空闲内存释放会内核。如果应用程序申请的内存大于256kb，dlmalloc调用mmap()向内核申请一块内存，返回返还给应用程序使用。如果应用程序释放的内存大于256kb，dlmalloc马上调用munmap()释放内存。dlmalloc不会缓存大于256kb的内存块，因为这样的内存块太大了，最好不要长期占用这么大的内存资源。
 利用 简单利用 #include &amp;lt;stdio.h&amp;gt; #include &amp;lt;stdlib.h&amp;gt; typedef void (*func_ptr)(char *); void evil_fuc(char command[]) { system(command); } void echo(char content[]) { printf(&amp;quot;%s&amp;quot;,content); } int main() { func_ptr *p1=(func_ptr*)malloc(4*sizeof(int)); printf(&amp;quot;malloc addr: %p\n&amp;quot;,p1); p1[3]=echo; p1[3](&amp;quot;hello world\n&amp;quot;); free(p1); //在这里free了p1,但并未将p1置空,导致后续可以再使用p1指针 p1[3](&amp;quot;hello again\n&amp;quot;); //p1指针未被置空,虽然free了,但仍可使用. func_ptr *p2=(func_ptr*)malloc(4*sizeof(int));//malloc在free一块内存后,再次申请同样大小的指针会把刚刚释放的内存分配出来. printf(&amp;quot;malloc addr: %p\n&amp;quot;,p2); printf(&amp;quot;malloc addr: %p\n&amp;quot;,p1);//p2与p1指针指向的内存为同一地址 p2[3]=evil_fuc; //在这里将p1指针里面保存的echo函数指针覆盖成为了evil_func指针. p1[3](&amp;quot;/bin/sh&amp;quot;); return 0; }  pwnable.kr uaf 先看看源码：
#include &amp;lt;fcntl.h&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;unistd.</description>
    </item>
    
    <item>
      <title>TEA加密与解密</title>
      <link>https://naivete.cc/2018/09/11/tea%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86/</link>
      <pubDate>Tue, 11 Sep 2018 20:39:26 +0800</pubDate>
      
      <guid>https://naivete.cc/2018/09/11/tea%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86/</guid>
      <description>TEA加密与解密  TEA算法由剑桥大学计算机实验室的David Wheeler和Roger Needham于1994年发明。它是一种分组密码算法，其明文密文块为64比特，密钥长度为128比特。TEA算法利用不断增加的Delta(黄金分割率)值作为变化，使得每轮的加密是不同，该加密算法的迭代次数可以改变，建议的迭代次数为32轮。
 在游戏项目中，一般需要对资源或数据进行加密保护，最简单高效的加密算法就是采用位与或之类的，但是比较容易被人分析出来。 TEA加密算法不但比较简单，而且有很强的抗差分分析能力，加密速度也比较快。可以根据项目需求设置加密轮数来增加加密强度。主要运用了移位和异或运算。密钥在加密过程中始终不变。
 差分分析是一种选择明文攻击，其基本思想是：通过分析特定明文差分对相对应密文差分影响来获得尽可能大的密钥。它可以用来攻击任何由迭代一个固定的轮函数的结构的密码以及很多分组密码（包括DES），它是由Biham和Shamir于1991年提出的选择明文攻击。
  加密核心函数
  void EncryptTEA(unsigned int *firstChunk, unsigned int *secondChunk, unsigned int* key) { unsigned int y = *firstChunk; unsigned int z = *secondChunk; unsigned int sum = 0; unsigned int delta = 0x9e3779b9; for (int i = 0; i &amp;lt; 8; i++) //8轮运算(需要对应下面的解密核心函数的轮数一样) { sum += delta; y += ((z &amp;lt;&amp;lt; 4) + key[0]) ^ (z + sum) ^ ((z &amp;gt;&amp;gt; 5) + key[1]); z += ((y &amp;lt;&amp;lt; 4) + key[2]) ^ (y + sum) ^ ((y &amp;gt;&amp;gt; 5) + key[3]); } *firstChunk = y; *secondChunk = z; }   算法使用了一个神秘常数δ作为倍数，它来源于黄金比率，以保证每一轮加密都不相同。但δ的精确值似乎并不重要，这里 TEA 把它定义为 δ=「(√5 - 1)231」&amp;ndash;&amp;gt; delta = 0x9e3779b9;</description>
    </item>
    
    <item>
      <title>OLLVM 混淆之一</title>
      <link>https://naivete.cc/2018/09/10/ollvm-%E6%B7%B7%E6%B7%86%E4%B9%8B%E4%B8%80/</link>
      <pubDate>Mon, 10 Sep 2018 20:39:26 +0800</pubDate>
      
      <guid>https://naivete.cc/2018/09/10/ollvm-%E6%B7%B7%E6%B7%86%E4%B9%8B%E4%B8%80/</guid>
      <description>OLLVM OLLVM(Obfuscator-LLVM)是瑞士西北应用科技大学安全实验室于2010年6月份发起的一个针对LLVM代码混淆项目， 用于增加逆向难度，保护代码的安全。最新版本为4.0。OLLVM适用LLVM支持的所有语言（C, C++, Objective-C, Ada 和 Fortran）和目标平台（x86, x86-64, PowerPC, PowerPC-64, ARM, Thumb, SPARC, Alpha, CellSPU, MIPS, MSP430, SystemZ, 和 XCore）。
 LLVM是lowlevel virtual machine的简称，是一个编译器框架。详细介绍可以看WIKI-LLVM
  经典的三段式设计，前端使用不同的编译工具对代码进行分析转换成LLVM的中间表示IR（intermediate representation）。中间部分优化器只对IR进行操作，通过一系列的Pass对IR做优化。后端主要是讲优化好的IR解释成对应的机器码。
对IR的处理过程下图：
OLLVM的混淆操作在IR层，通过编写Pass来混淆IR，以致后端生成的目标代码也被混淆了。
OLLVM-Android环境搭建 前提环境：
 NDK环境
 LLVM
  下载源码(包括了LLVM和Clang)-编译OLLVM步骤如下：
 $ git clone -b llvm-4.0 https://github.com/obfuscator-llvm/obfuscator.git $ mkdir build $ cd build $ cmake -DCMAKE_BUILD_TYPE=Release ../obfuscator/ //（cmake -G &amp;quot;MinGW Makefiles&amp;quot; -DCMAKE_BUILD_TYPE=Release ../obfuscator/）(windows) $ make -j7 //这个数字自己看自己CPU填 太小可能非常编译慢   可以参照官方wiki来操作。编译完成后，二进制文件放在build/bin目录下。</description>
    </item>
    
    <item>
      <title>IDA 动态调试.so 基本步骤</title>
      <link>https://naivete.cc/2018/08/31/ida-%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95.so-%E5%9F%BA%E6%9C%AC%E6%AD%A5%E9%AA%A4/</link>
      <pubDate>Fri, 31 Aug 2018 20:39:26 +0800</pubDate>
      
      <guid>https://naivete.cc/2018/08/31/ida-%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95.so-%E5%9F%BA%E6%9C%AC%E6%AD%A5%E9%AA%A4/</guid>
      <description>IDA 动态调试.so 基本步骤  待补图
  0x00 IDA快捷键  Shirt+F12 字符串窗口
 F5大法好 反汇编
 Ctrl+S 查看so对应段的信息（非调试），快速定位so文件的内存地址（Debug）
 G 快速跳转到对应地址。s
 调试-F7单步进入调试、F8单步、F9运行
  0x01 方法一  获取运行Android_server。
  android_server文件放在IDA安装目录下的\dbgsrv目录下 注意版本的不同。
之后只需 push android_server /data/local/tmp/。
之后adb shell，su ，cd /data/local/tmp/。
可能还得chmod 755 android_server 才有权限运行。
 建立通信、attach进程。
  adb forward tcp:23946 tcp:23946命令。
在IDA的Debugger选项中attach进程。
 加载so、找函数下断点
  双开IDA ，Ctrl+S找到so文件的基地址，另外一个IDA找到函数的相对地址。相加得到绝对地址。
0x02 方法二 无法加载so文件需要在加载之前断点。反调试之类
 Debug方式启动app。需要应用可调试开启
  adb shell am start -D -n 包名/.</description>
    </item>
    
    <item>
      <title>Android应用安全防护和逆向分析-基础篇5-6</title>
      <link>https://naivete.cc/2018/08/29/android%E5%BA%94%E7%94%A8%E5%AE%89%E5%85%A8%E9%98%B2%E6%8A%A4%E5%92%8C%E9%80%86%E5%90%91%E5%88%86%E6%9E%90-%E5%9F%BA%E7%A1%80%E7%AF%875-6/</link>
      <pubDate>Wed, 29 Aug 2018 20:39:26 +0800</pubDate>
      
      <guid>https://naivete.cc/2018/08/29/android%E5%BA%94%E7%94%A8%E5%AE%89%E5%85%A8%E9%98%B2%E6%8A%A4%E5%92%8C%E9%80%86%E5%90%91%E5%88%86%E6%9E%90-%E5%9F%BA%E7%A1%80%E7%AF%875-6/</guid>
      <description>一、 基础篇⑤-⑥ 这两章主要描述AndroidManifest.xml和resourec.arsc这两个android文件。内容不是很多，下面是两章的笔记。
第五章 AndroidManifest.xml格式解析 AndroidManifest.xml文件格式图
头部信息  文件魔数：4bytes。
 文件大小：4bytes。
 Chunk内容 头部相同（ChunkType(4bytes)、ChunkSize(4bytes)）。
 Sting Chunk ：主要用于存放AndroidManifest.xml文件中所有的字符串信息。
 ChunkType：类型，固定4bytes（0x001C001)。
 ChunkSize：大小，4bytes。
 StringCount：字符串的个数 ，4bytes。
 StyleCount ：样式的个数，4bytes。
 Unknown ：位置区域。4bytes。
 StringPoolOffset ：字符串池的偏移值。4bytes。偏移值相对于StringChunk头部的位置。
 StylePoolOffset : 样式池的偏移值。4bytes。没有Style可忽略。
 StringOffsets ：每一个字符串的偏移值，大小为StringChunk*4。
 StyleOffsets：每个样式的偏移值，大小为StyleChunk*4。
  如何读取这个文件？
 Resourceld Chunk ：主要用来存放AndroidManifest 中用到的系统属性值对应的资源ID
 ChunkType：类型，固定4bytes（0x00080108）。
 ChunkSize：大小，4bytes。
 ResourceIds : 内容，大小为Resourceld Chunk大小除以4减去头部的8字节。
  解析？
 Start Namespace Chunk：主要包含了AndroidMaifest文件中的命名空间的内容，android中的xml都是采用Schema格式（两种格式DTD和Schema）的，所有肯定有Prefix和URI。
 Chunk Type：类型，固定4bytes。（0x00100100)。</description>
    </item>
    
    <item>
      <title>ARM汇编基础</title>
      <link>https://naivete.cc/2018/08/10/arm%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Fri, 10 Aug 2018 19:34:10 +0800</pubDate>
      
      <guid>https://naivete.cc/2018/08/10/arm%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80/</guid>
      <description>##ARM汇编基础(简)
经常忘记，做个笔记，好作复习。。
内容主要来源于《Android软件安全与逆向分析》和《逆向工程权威指南》以及 ARM 汇编 和Azeria-labs
ARM架构 ARM属于RISC CPU，
 ARM模式 4个字节opcode 32位
 Thumb模式 2个字节opcode 16位
 Thumb-2模式 同上（只是有部分4个字节的opcode)
 64位ARM 4个字节opcode
 ARM机器码在版本3之前是小端。但是之后默认采用大端格式，但可以设置切换到小端。
  数据类型 数据类型在汇编语言中的扩展后缀为-h或者-sh对应着半字，-b或者-sb对应着字节，但是对于字并没有对应的扩展
ldr = 加载字，宽度四字节 ldrh = 加载无符号的半字，宽度两字节 ldrsh = 加载有符号的半字，宽度两字节 ldrb = 加载无符号的字节 ldrsb = 加载有符号的字节 str = 存储字，宽度四字节 strh = 存储无符号的半字，宽度两字节 strsh = 存储有符号的半字，宽度两字节 strb = 存储无符号的字节 strsb = 存储有符号的字节  字节序 在内存中有两种字节排布顺序，大端序(BE)或者小端序(LE)。两者的主要不同是对象中的每个字节在内存中的存储顺序存在差异。一般X86中是小端序，最低的字节存储在最低的地址上。在大端机中最高的字节存储在最低的地址上。
数据访问时采取大端序还是小端序使用程序状态寄存器(CPSR)的第9比特位来决定的。
寄存器 37个32位寄存器，其中31个为基础寄存器，6个为状态寄存器。
用户模式下有
 不分组寄存器（R0-R7） R7一般存放系统调用号</description>
    </item>
    
    <item>
      <title>QEMU的安装使用</title>
      <link>https://naivete.cc/2018/08/09/qemu%E7%9A%84%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Thu, 09 Aug 2018 19:34:34 +0800</pubDate>
      
      <guid>https://naivete.cc/2018/08/09/qemu%E7%9A%84%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/</guid>
      <description>QEMU的安装使用 安装 WIndows：https://qemu.weilnetz.de/w64/ 下载exe安装就行
MACOS:brew install qemu or sudo port install qemu
LINUX：
 Arch: pacman -S qemu
 Debian/Ubuntu: apt-get install qemu
 Fedora: dnf install @virtualization
 Gentoo: emerge --ask app-emulation/qemu
 RHEL/CentOS: yum install qemu-kvm
 SUSE: zypper install qemu
  源码安装：https://download.qemu.org/
wget
wget https://download.qemu.org/qemu-3.0.0-rc1.tar.xz tar xvJf qemu-3.0.0-rc1.tar.xz cd qemu-3.0.0-rc1 ./configure make  git
git clone git://git.qemu.org/qemu.git cd qemu git submodule init git submodule update --recursive .</description>
    </item>
    
    <item>
      <title>在Android的个人字典中发现和利用漏洞(CVE 2018 9375)</title>
      <link>https://naivete.cc/2018/08/05/%E5%9C%A8android%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%AD%97%E5%85%B8%E4%B8%AD%E5%8F%91%E7%8E%B0%E5%92%8C%E5%88%A9%E7%94%A8%E6%BC%8F%E6%B4%9Ecve-2018-9375/</link>
      <pubDate>Sun, 05 Aug 2018 21:16:52 +0800</pubDate>
      
      <guid>https://naivete.cc/2018/08/05/%E5%9C%A8android%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%AD%97%E5%85%B8%E4%B8%AD%E5%8F%91%E7%8E%B0%E5%92%8C%E5%88%A9%E7%94%A8%E6%BC%8F%E6%B4%9Ecve-2018-9375/</guid>
      <description>翻译的文章
原作者：Daniel Kachakil
 我正在审计一款Android手机，审计范围是所有已经安装了的应用程序。我的首选方法是，在时间允许的时候，就手动检查尽可能多的代码。我发现了一个巧妙的漏洞，这个漏洞允许我与一个内容提供者交互，而该内容提供者应该在最近的Android版本中受到保护：用户的个人词典，它存储了用户想要保留的非标准单词的拼写。
虽然理论上应该只授权给特权用户、授权的输入法编辑器(IMEs) ，以及拼写检查程序访问用户的个人词典，但是有一种方法可以绕过这些限制，允许恶意应用程序更新、删除甚至检索字典内的所有内容。而不需要任何权限或者与用户交互。
这个中等风险的漏洞被归类为权限提升，并于2018年6月修复，影响到Android的以下版本：6.0、6.0.1、7.0、7.1.1、7.1.2、8.0和8.1。
用户的个人词典 Android提供了一个自定义词典，可以手动输入或者自动定制，从用户的输入中学习。这本字典的入口为“设置→ 语言和键盘 → 个人词典” （也可能在“高级“或者不同的选项下）。他可能包含有敏感信息，比如姓名、地址、电话号码、电子邮件、密码、商业品牌、不存常的词汇（可能包括疾病、药品、技术术语等），甚至信用卡号。
用户还可以为每个单词或者句子定义一个快捷方式，因此想要输入的家庭地址的时候，你可以添加一个条目并简单地为其添加一个快捷方式（比如“myhome”）来自动完成填写。
在内部，这些单词存储在SQLLite数据库中，该数据库只包含有一个名为“words”的表（除了“android_metadata” ），这个表有6列：
 _id (INTEGER, PRIMARY KEY)
 word (TEXT)
 frequency (INTEGER)
 locale (TEXT)
 appid (INTEGER)
 shortcut (TEXT)
  我们主要注意“word&amp;rdquo;这列，正如名称所示，它包含了自定义的单词。然而，同一数据库中所有剩余的列和表也可以访问。
漏洞细节 在较早版本的Android中，对个人字典的读写访问分别受到以下权限的保护：
 android.permission.READ_USER_DICTIONARY
 android.permission.WRITE_USER_DICTIONARY
  对于新版本来说，这已经不再适用了，根据官方文档[1]:&amp;ldquo;从API 23开始，用户字典只能通过IME和拼写检查器访问” ，以前的权限已经被内部检查所取代，因此理论上，只有特权帐户(比如 root 和 system), 启用的IMEs和拼写检查器可以访问个人字典内容提供者 (content://user_dictionary/words)。
我们可以检查AOSP代码库，查看一个变更[2]中引入了一个新的名为canCallerAccessUserDictionary 的私有函数，并从 UserDictionary 内容提供者中的所有标准查询、插入、更新和删除函数中调用该函数，以防止对这些函数的未经授权的调用。
虽然更改似乎对查询和插入函数都有效，但是在更新和删除过程中，授权检查发生滞后引入了安全漏洞，允许任何应用程序通过公开的内容提供者成功地调用受影响的函数，从而绕过错误的授权检查。
在下面的 UserDictionaryProvider类[3]的代码中，注意高亮（标注在注释）的片段，查看在数据库已经被修改之后如何执行授权检查：
@Override public int delete(Uri uri, String where, String[] whereArgs) { SQLiteDatabase db = mOpenHelper.</description>
    </item>
    
    <item>
      <title>(转)Android Inline Hook中的指令修复详解</title>
      <link>https://naivete.cc/2018/07/30/%E8%BD%ACandroid-inline-hook%E4%B8%AD%E7%9A%84%E6%8C%87%E4%BB%A4%E4%BF%AE%E5%A4%8D%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Mon, 30 Jul 2018 15:03:41 +0800</pubDate>
      
      <guid>https://naivete.cc/2018/07/30/%E8%BD%ACandroid-inline-hook%E4%B8%AD%E7%9A%84%E6%8C%87%E4%BB%A4%E4%BF%AE%E5%A4%8D%E8%AF%A6%E8%A7%A3/</guid>
      <description>前言  本文是另一篇《Android Native Hook工具实践》的一份补充文章，本人建议各位学习者先去看该篇主文以了解本文的需求背景。本文将会对该文中指令修复部分的技术细节进行阐述。本文的部分源码来自于ele7enxxh大神的项目，由于大神的技术博客里解释省略了较多细节，所以出于学习的目的，本人也会一点一点慢慢啃。同时由于该库并不完善，因此本文将补充该库没考虑到的一些修复指令方案，并且对许多特殊状况和Bug也尽力解决。
 目前需要进行指令修复的ARM32指令主要可以分为如下几类：
 BLX_ARM, BL_ARM, B_ARM（不包含条件跳转）, BX_ARM
 条件跳转BEQ_ARM BNE_ARM BCS_ARM BCC_ARM BMI_ARM BPL_ARM BVS_ARM BVC_ARM BHI_ARM BLS_ARM BGE_ARM BLT_ARM BGT_ARM BLE_ARM
 ADD_ARM
 ADR_ARM, LDR_ARM, MOV_ARM
 其它指令 OTHER_ARM
  Thumb16指令主要可以分为如下几类：
 B1_THUMB16（不包含条件跳转）, B2_THUMB16, BX_THUMB16
 条件跳转B1_BEQ_THUMB16, B1_BNE_THUMB16, B1_BCS_THUMB16, B1_BCC_THUMB16, B1_BMI_THUMB16, B1_BPL_THUMB16, B1_BVS_THUMB16, B1_BVC_THUMB16, B1_BHI_THUMB16, B1_BLS_THUMB16, B1_BGE_THUMB16, B1_BLT_THUMB16, B1_BGT_THUMB16, B1_BLE_THUMB16
 ADD_THUMB16
 MOV_THUMB16, ADR_THUMB16, LDR_THUMB16
 其它指令 OTHER_THUMB16
  Thumb32指令主要可以分为如下几类：</description>
    </item>
    
    <item>
      <title>(转)Android Native Hook工具实践</title>
      <link>https://naivete.cc/2018/07/30/%E8%BD%ACandroid-native-hook%E5%B7%A5%E5%85%B7%E5%AE%9E%E8%B7%B5/</link>
      <pubDate>Mon, 30 Jul 2018 14:48:12 +0800</pubDate>
      
      <guid>https://naivete.cc/2018/07/30/%E8%BD%ACandroid-native-hook%E5%B7%A5%E5%85%B7%E5%AE%9E%E8%B7%B5/</guid>
      <description>前言 在目前的安卓APP测试中对于Native Hook的需求越来越大，越来越多的APP开始逐渐使用NDK来开发核心或者敏感代码逻辑。个人认为原因如下：
 安全的考虑。各大APP越来越注重安全性，NDK所编译出来的so库逆向难度明显高于java代码产生的dex文件。越是敏感的加密算法与数据就越是需要用NDK进行开发。
 性能的追求。NDK对于一些高性能的功能需求是java层无法比拟的。
 手游的兴起。虚幻4，Unity等引擎开发的手游中都有大量包含游戏逻辑的so库。
  因此，本人调查了一下Android Native Hook工具目前的现状。尽管Java层的Hook工具多种多样，但是Native Hook的工具却非常少并且在安卓5.0以上的适配工具更是寥寥无几。（文末说明1）而目前Native Hook主要有两大技术路线：
 PLT Hook
 Inline Hook
  这两种技术路线本人都实践了一下，关于它们的对比，我在《Android Native Hook技术路线概述》中有介绍，所以这里就不多说了。最终，我用了Inline Hook来做这个项目。
本文篇幅已经较长，因此写了一些独立的学习笔记来对其中的细节问题进行解释：
 《Android Native Hook技术路线概述》
 《Android Inline Hook中的指令修复》
 项目仓库
 项目案例——Arm32
 项目案例——Thumb-2
  目标效果 根据本人自身的使用需求提出了如下几点目标：
 工具运行原理中不能涉及调试目标APP，否则本工具在遇到反调试措施的APP时会失效。尽管可以先去逆向调试patch掉反调试功能，但是对于大多数情况下只是想看看参数和返回值的Hook需求而言，这样的前期处理实在过于麻烦。
 依靠现有的各大Java Hook工具就能运行本工具，换句话说就是最好能用类似这些工具的插件的形式加载起本工具从而获得Native Hook的能力。由于Java Hook工具如Xposed、YAHFA等对于各个版本的Android都做了不错的适配，因此利用这些已有的工具即可向目标APP的Native层中注入我们的Hook功能将会方便很多小伙伴的使用。
 既然要能够让各种Java Hook工具都能用本工具得到Native Hook的能力，那就这个工具就要有被加载起来以后自动执行自身功能逻辑的能力！而不是针对各个Java Hook工具找调用起来的方式。
 要适配Android NDK下的armv7和thumb-2指令集。由于现在默认编译为thumb-2模式，所以对于thumb16和thumb32的Native Hook支持是重中之重。
 修复Inline Hook后的原本指令。
 Hook目标的最小单位至少是函数，最好可以是某行汇编代码。
  最终方案 最后完成项目的方案是：本工具是一个so库。用Java Hook工具在APP的入口Activity运行一开始的onCreate方法处Hook，然后加载本so。 加载后，自动开始执行Hook逻辑。 为了方便叙述，接下来的Java Hook工具我就使用目前这类工具里最流行的Xposed，本项目的生成文件名为libautohook.</description>
    </item>
    
    <item>
      <title>Java反射机制学习笔记</title>
      <link>https://naivete.cc/2018/07/25/java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Wed, 25 Jul 2018 16:40:20 +0800</pubDate>
      
      <guid>https://naivete.cc/2018/07/25/java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</guid>
      <description>Java 反射机制学习记录 在逆向中反射也是能经常看见，之前理解不是很深透，现在来重点学习一下，做个笔记。
什么是反射机制？ 反射(Reflection)是Java 程序开发语言的特征之一，它允许运行中的 Java 程序获取自身的信息，并且可以操作类或对象的内部属性。 通俗一点：在动态运行时，获取到一个类的所有方法以及成员。简而言之，通过反射，我们可以在运行时获得程序或程序集中每一个类型的成员和成员的信息。
作用？  1.在运行时判断任意一个对象所属的类；
 2.在运行时构造任意一个类的对象；
 3.在运行时判断任意一个类所具有的成员变量和方法（通过反射甚至可以调用private方法）；
 4.在运行时调用任意一个对象的方法
  是运行时而不是编译时  获取某些类的一些变量，调用某些类的私有方法。
 增加代码的灵活性。很多主流框架都使用了反射技术.像ssh框架都采用两种技术 xml做配置文件+反射技术.
  基本使用 反射相关的类一般都在java.lang.relfect 包里。
 获取Class对象 3种方法
  (1)使用Class类的forName静态方法:
public static Class&amp;lt;?&amp;gt; forName(String className) //在JDBC开发中常用此方法加载数据库驱动: Class.forName(driver);  (2)直接获取某一个对象的class，比如:
Class&amp;lt;?&amp;gt; klass = int.class; Class&amp;lt;?&amp;gt; classInt = Integer.TYPE;  (3)调用某个对象的getClass()方法,比如:
StringBuilder str = new StringBuilder(&amp;quot;123&amp;quot;); Class&amp;lt;?&amp;gt; klass = str.getClass();   判断是否为某一个类的实例
  一般使用instanceof来判断，也可以借助反射中的Class对象的isInstance()方法来判断 是一个Native方法：</description>
    </item>
    
    <item>
      <title>Android应用安全防护和逆向分析-基础篇④</title>
      <link>https://naivete.cc/2018/07/22/android%E5%BA%94%E7%94%A8%E5%AE%89%E5%85%A8%E9%98%B2%E6%8A%A4%E5%92%8C%E9%80%86%E5%90%91%E5%88%86%E6%9E%90-%E5%9F%BA%E7%A1%80%E7%AF%87/</link>
      <pubDate>Sun, 22 Jul 2018 14:15:38 +0800</pubDate>
      
      <guid>https://naivete.cc/2018/07/22/android%E5%BA%94%E7%94%A8%E5%AE%89%E5%85%A8%E9%98%B2%E6%8A%A4%E5%92%8C%E9%80%86%E5%90%91%E5%88%86%E6%9E%90-%E5%9F%BA%E7%A1%80%E7%AF%87/</guid>
      <description>一、 基础篇④ 第四章 so文件格式解析  ELF文件格式
  so文件-&amp;gt;elf文件，文件格式看图（引用自@非虫）：
 解析工具
 readelf 常用命令
 readelf -h xxx.so 查头部信息
 readelf -S xxx.so 查节（Section）信息
 readelf -l xxx.so 查段（Program）信息
 readelf -a xxx.so 查全部信息
   解析ELF文件
  动手解析一个elf文件 。。。
太水 这里的内容
直接去看源码实现用java解析elf文件信息https://github.com/fourbrother/parse_androidso
ELF 相关内容还是单独详细分析 单独写一篇吧
ELF书籍《Linux二进制分析》
### 总结
加固脱壳必须掌握的知识点。</description>
    </item>
    
    <item>
      <title>Android应用安全防护和逆向分析 基础篇③</title>
      <link>https://naivete.cc/2018/07/16/android%E5%BA%94%E7%94%A8%E5%AE%89%E5%85%A8%E9%98%B2%E6%8A%A4%E5%92%8C%E9%80%86%E5%90%91%E5%88%86%E6%9E%90-%E5%9F%BA%E7%A1%80%E7%AF%87/</link>
      <pubDate>Mon, 16 Jul 2018 13:51:50 +0800</pubDate>
      
      <guid>https://naivete.cc/2018/07/16/android%E5%BA%94%E7%94%A8%E5%AE%89%E5%85%A8%E9%98%B2%E6%8A%A4%E5%92%8C%E9%80%86%E5%90%91%E5%88%86%E6%9E%90-%E5%9F%BA%E7%A1%80%E7%AF%87/</guid>
      <description>一、 基础篇③ 第三章 Android中开发与逆向常用命令总结 1. 基础命令 1.1 cat命令 ​ 查看文件内容 结合grep进行过滤
1.2 echo/touch命令 ​ 写文件 配个定向符使用
2. 非shell命令 2.1 adb shell dumpsys sctivity top ​ 说明：查看当前应用的activity信息
​ 用法：运行需要查看的应用
​ 如果直接运行 adb shell dmpsys会把当前系统中的所有应用运行的四大组件都打印出来 内容非常多 使用信息重定向来进行选择：可借助Windows的start命令
2.2 adb shell dumpsys package ​ 说明：查看指定包名应用的详细信息 （相当于AndroidManifest.xml的内容）
​ 用法：adb shell dumpsys package [pkgname]
2.3 adb shell dumpsys meminfo ​ 说明：查看指定进程名或者进程id的内存信息
​ 用法：adb shell dumpsys meminfo [pname/pid]
​ 和后面的top命令结合使用 可以分析应用的性能消耗情况
2.4 adb shell dump dbnfo ​ 说明：查看指定包名应用的数据库存储信息（包括存储的SQL语句）</description>
    </item>
    
    <item>
      <title>Android应用安全防护和逆向分析 基础篇②</title>
      <link>https://naivete.cc/2018/07/13/android%E5%BA%94%E7%94%A8%E5%AE%89%E5%85%A8%E9%98%B2%E6%8A%A4%E5%92%8C%E9%80%86%E5%90%91%E5%88%86%E6%9E%90-%E5%9F%BA%E7%A1%80%E7%AF%87/</link>
      <pubDate>Fri, 13 Jul 2018 15:01:09 +0800</pubDate>
      
      <guid>https://naivete.cc/2018/07/13/android%E5%BA%94%E7%94%A8%E5%AE%89%E5%85%A8%E9%98%B2%E6%8A%A4%E5%92%8C%E9%80%86%E5%90%91%E5%88%86%E6%9E%90-%E5%9F%BA%E7%A1%80%E7%AF%87/</guid>
      <description>一、 基础篇② 第二章 Android中NDK的开发 1. 相关环境 相关环境参考另外一篇文章Android安全和开发环境搭建
2. JNI基础 2.1 第一行代码(书上使用Eclipse,我使用AS(简单方便很多)) ​ 参考文章Android安全和开发环境搭建中的JNI开发章节
2.2 JNIEnv类型和jobject类型  AS 默认自动生成
  public native String stringFromJNI();  Java_com_naivete_jni_1study_MainActivity_stringFromJNI( JNIEnv *env, jobject /* this */) { std::string hello = &amp;quot;Hello from C++&amp;quot;; return env-&amp;gt;NewStringUTF(hello.c_str());   JNIEnv类型
  通过JNIEnv* 指针就可以对Java端的代码进行操作
Jni的所有函数可以查看jni.h文件
下面是一些函数eg：
 NewObject : 创建Java类中的对象。
 NewString : 创建Java类中的String对象。
 NewArray : 创建类型为Type的数组对象
 GetField: 获取型为Type的字段。
 SetFileld: 设置类型为Type的字段的值。
 GetStaticField: 获取类型为Type的static的字段。</description>
    </item>
    
    <item>
      <title>Android安全和开发环境搭建</title>
      <link>https://naivete.cc/2018/07/05/android%E5%AE%89%E5%85%A8%E5%92%8C%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</link>
      <pubDate>Thu, 05 Jul 2018 17:35:46 +0800</pubDate>
      
      <guid>https://naivete.cc/2018/07/05/android%E5%AE%89%E5%85%A8%E5%92%8C%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</guid>
      <description>Android安全和开发环境搭建  补充中·····
JAVA环境   JDK下载与安装。
 环境变量配置
  Android Studio  官网下载（扶墙）
 SDK
  NDK（JNI）开发  NDK下载
 使用
  Eclipse (还是推荐上面的AS) 不喜欢界面，弃用。</description>
    </item>
    
    <item>
      <title>CTF</title>
      <link>https://naivete.cc/ctf/</link>
      <pubDate>Mon, 02 Jul 2018 18:20:34 +0800</pubDate>
      
      <guid>https://naivete.cc/ctf/</guid>
      <description> CTF题目汇总  个人搭建平台
 MISC
 
  RE
 
  PWN
 
  Crypto
 
  Web
 
   </description>
    </item>
    
    <item>
      <title>Android应用安全防护和逆向分析 基础篇①</title>
      <link>https://naivete.cc/2018/07/02/android%E5%BA%94%E7%94%A8%E5%AE%89%E5%85%A8%E9%98%B2%E6%8A%A4%E5%92%8C%E9%80%86%E5%90%91%E5%88%86%E6%9E%90-%E5%9F%BA%E7%A1%80%E7%AF%87/</link>
      <pubDate>Mon, 02 Jul 2018 17:33:05 +0800</pubDate>
      
      <guid>https://naivete.cc/2018/07/02/android%E5%BA%94%E7%94%A8%E5%AE%89%E5%85%A8%E9%98%B2%E6%8A%A4%E5%92%8C%E9%80%86%E5%90%91%E5%88%86%E6%9E%90-%E5%9F%BA%E7%A1%80%E7%AF%87/</guid>
      <description>第一章 Android中锁屏密码加密算法分析 1. 锁屏密码方式：  手势
 九宫格连线
 输入密码
 指纹、人脸、虹膜
 可穿戴设备
  2. 这儿分析手势密码和输入密码 找到android源代码中的LockPatternUtils,java 这个工具类
路径：Android-5.1.1\frameworks\base\core\java\com\android\internal\widget
 2.1 输入密码算法分析 (5.1版本的源代码 和书上细微差异)
 public byte[] passwordToHash(String password, int userId) {//参数为密码和对应用户ID 默认0 if (password == null) { return null; } try { byte[] saltedPassword = (password + getSalt(userId)).getBytes(); byte[] sha1 = MessageDigest.getInstance(&amp;quot;SHA-1&amp;quot;).digest(saltedPassword); byte[] md5 = MessageDigest.getInstance(&amp;quot;MD5&amp;quot;).digest(saltedPassword); //首先让 password+salt值 再SHA-1和MD5 byte[] combined = new byte[sha1.length + md5.length]; System.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://naivete.cc/%E5%8F%8B%E9%93%BE/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://naivete.cc/%E5%8F%8B%E9%93%BE/</guid>
      <description> 友链  []()
  </description>
    </item>
    
  </channel>
</rss>