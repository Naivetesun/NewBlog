<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Android安全 on Vorblock&#39;Blog</title>
    <link>https://naivete.cc/categories/android%E5%AE%89%E5%85%A8/</link>
    <description>Recent content in Android安全 on Vorblock&#39;Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 10 Oct 2018 16:40:20 +0800</lastBuildDate>
    
	<atom:link href="https://naivete.cc/categories/android%E5%AE%89%E5%85%A8/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Android-ARM进阶</title>
      <link>https://naivete.cc/2018/10/10/android-arm%E8%BF%9B%E9%98%B6/</link>
      <pubDate>Wed, 10 Oct 2018 16:40:20 +0800</pubDate>
      
      <guid>https://naivete.cc/2018/10/10/android-arm%E8%BF%9B%E9%98%B6/</guid>
      <description>学习一些关于ARM的汇编结构特点，以及分析。理解一些结构最好的方法就是多去尝试动手做。。
NDK-Build的使用 可以参考官方文档。
 创建一个Android项目
 cd 项目目录
 /ndk-build 。也可以将NDK-build加入环境变量。
 创建jni文件夹，添加 Android.mk和 Application.mk两个文件。（参考官方文档）
  //Android.mk LOCAL_PATH := $(call my-dir) include $(CLEAR_VARS) # 要生成的.so库名称 LOCAL_MODULE := hello # c++文件 LOCAL_SRC_FILES := hello.cpp include $(BUILD_SHARED_LIBRARY)  //Application.mk APP_PLATFORM := android-17 # APP_ABI := all APP_ABI :=armeabi-v7a arm64-v8a  添加hello.cpp：
#include&amp;lt;cstdio&amp;gt; int i,j; int num[] = {1,2,3,4,5}; int main() { /* code */ printf(&amp;quot;hello,world!\n&amp;quot;); for(i=0;i&amp;lt;5;i++){ printf(&amp;quot;num value is %d\n&amp;quot;,num[i]); } return 0; }   ndk-build</description>
    </item>
    
    <item>
      <title>OLLVM 混淆之一</title>
      <link>https://naivete.cc/2018/09/10/ollvm-%E6%B7%B7%E6%B7%86%E4%B9%8B%E4%B8%80/</link>
      <pubDate>Mon, 10 Sep 2018 20:39:26 +0800</pubDate>
      
      <guid>https://naivete.cc/2018/09/10/ollvm-%E6%B7%B7%E6%B7%86%E4%B9%8B%E4%B8%80/</guid>
      <description>OLLVM OLLVM(Obfuscator-LLVM)是瑞士西北应用科技大学安全实验室于2010年6月份发起的一个针对LLVM代码混淆项目， 用于增加逆向难度，保护代码的安全。最新版本为4.0。OLLVM适用LLVM支持的所有语言（C, C++, Objective-C, Ada 和 Fortran）和目标平台（x86, x86-64, PowerPC, PowerPC-64, ARM, Thumb, SPARC, Alpha, CellSPU, MIPS, MSP430, SystemZ, 和 XCore）。
 LLVM是lowlevel virtual machine的简称，是一个编译器框架。详细介绍可以看WIKI-LLVM
  经典的三段式设计，前端使用不同的编译工具对代码进行分析转换成LLVM的中间表示IR（intermediate representation）。中间部分优化器只对IR进行操作，通过一系列的Pass对IR做优化。后端主要是讲优化好的IR解释成对应的机器码。
对IR的处理过程下图：
OLLVM的混淆操作在IR层，通过编写Pass来混淆IR，以致后端生成的目标代码也被混淆了。
OLLVM-Android环境搭建 前提环境：
 NDK环境
 LLVM
  下载源码(包括了LLVM和Clang)-编译OLLVM步骤如下：
 $ git clone -b llvm-4.0 https://github.com/obfuscator-llvm/obfuscator.git $ mkdir build $ cd build $ cmake -DCMAKE_BUILD_TYPE=Release ../obfuscator/ //（cmake -G &amp;quot;MinGW Makefiles&amp;quot; -DCMAKE_BUILD_TYPE=Release ../obfuscator/）(windows) $ make -j7 //这个数字自己看自己CPU填 太小可能非常编译慢   可以参照官方wiki来操作。编译完成后，二进制文件放在build/bin目录下。</description>
    </item>
    
    <item>
      <title>IDA 动态调试.so 基本步骤</title>
      <link>https://naivete.cc/2018/08/31/ida-%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95.so-%E5%9F%BA%E6%9C%AC%E6%AD%A5%E9%AA%A4/</link>
      <pubDate>Fri, 31 Aug 2018 20:39:26 +0800</pubDate>
      
      <guid>https://naivete.cc/2018/08/31/ida-%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95.so-%E5%9F%BA%E6%9C%AC%E6%AD%A5%E9%AA%A4/</guid>
      <description>IDA 动态调试.so 基本步骤  待补图
  0x00 IDA快捷键  Shirt+F12 字符串窗口
 F5大法好 反汇编
 Ctrl+S 查看so对应段的信息（非调试），快速定位so文件的内存地址（Debug）
 G 快速跳转到对应地址。s
 调试-F7单步进入调试、F8单步、F9运行
  0x01 方法一  获取运行Android_server。
  android_server文件放在IDA安装目录下的\dbgsrv目录下 注意版本的不同。
之后只需 push android_server /data/local/tmp/。
之后adb shell，su ，cd /data/local/tmp/。
可能还得chmod 755 android_server 才有权限运行。
 建立通信、attach进程。
  adb forward tcp:23946 tcp:23946命令。
在IDA的Debugger选项中attach进程。
 加载so、找函数下断点
  双开IDA ，Ctrl+S找到so文件的基地址，另外一个IDA找到函数的相对地址。相加得到绝对地址。
0x02 方法二 无法加载so文件需要在加载之前断点。反调试之类
 Debug方式启动app。需要应用可调试开启
  adb shell am start -D -n 包名/.</description>
    </item>
    
    <item>
      <title>(转)Android Inline Hook中的指令修复详解</title>
      <link>https://naivete.cc/2018/07/30/%E8%BD%ACandroid-inline-hook%E4%B8%AD%E7%9A%84%E6%8C%87%E4%BB%A4%E4%BF%AE%E5%A4%8D%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Mon, 30 Jul 2018 15:03:41 +0800</pubDate>
      
      <guid>https://naivete.cc/2018/07/30/%E8%BD%ACandroid-inline-hook%E4%B8%AD%E7%9A%84%E6%8C%87%E4%BB%A4%E4%BF%AE%E5%A4%8D%E8%AF%A6%E8%A7%A3/</guid>
      <description>前言  本文是另一篇《Android Native Hook工具实践》的一份补充文章，本人建议各位学习者先去看该篇主文以了解本文的需求背景。本文将会对该文中指令修复部分的技术细节进行阐述。本文的部分源码来自于ele7enxxh大神的项目，由于大神的技术博客里解释省略了较多细节，所以出于学习的目的，本人也会一点一点慢慢啃。同时由于该库并不完善，因此本文将补充该库没考虑到的一些修复指令方案，并且对许多特殊状况和Bug也尽力解决。
 目前需要进行指令修复的ARM32指令主要可以分为如下几类：
 BLX_ARM, BL_ARM, B_ARM（不包含条件跳转）, BX_ARM
 条件跳转BEQ_ARM BNE_ARM BCS_ARM BCC_ARM BMI_ARM BPL_ARM BVS_ARM BVC_ARM BHI_ARM BLS_ARM BGE_ARM BLT_ARM BGT_ARM BLE_ARM
 ADD_ARM
 ADR_ARM, LDR_ARM, MOV_ARM
 其它指令 OTHER_ARM
  Thumb16指令主要可以分为如下几类：
 B1_THUMB16（不包含条件跳转）, B2_THUMB16, BX_THUMB16
 条件跳转B1_BEQ_THUMB16, B1_BNE_THUMB16, B1_BCS_THUMB16, B1_BCC_THUMB16, B1_BMI_THUMB16, B1_BPL_THUMB16, B1_BVS_THUMB16, B1_BVC_THUMB16, B1_BHI_THUMB16, B1_BLS_THUMB16, B1_BGE_THUMB16, B1_BLT_THUMB16, B1_BGT_THUMB16, B1_BLE_THUMB16
 ADD_THUMB16
 MOV_THUMB16, ADR_THUMB16, LDR_THUMB16
 其它指令 OTHER_THUMB16
  Thumb32指令主要可以分为如下几类：</description>
    </item>
    
    <item>
      <title>(转)Android Native Hook工具实践</title>
      <link>https://naivete.cc/2018/07/30/%E8%BD%ACandroid-native-hook%E5%B7%A5%E5%85%B7%E5%AE%9E%E8%B7%B5/</link>
      <pubDate>Mon, 30 Jul 2018 14:48:12 +0800</pubDate>
      
      <guid>https://naivete.cc/2018/07/30/%E8%BD%ACandroid-native-hook%E5%B7%A5%E5%85%B7%E5%AE%9E%E8%B7%B5/</guid>
      <description>前言 在目前的安卓APP测试中对于Native Hook的需求越来越大，越来越多的APP开始逐渐使用NDK来开发核心或者敏感代码逻辑。个人认为原因如下：
 安全的考虑。各大APP越来越注重安全性，NDK所编译出来的so库逆向难度明显高于java代码产生的dex文件。越是敏感的加密算法与数据就越是需要用NDK进行开发。
 性能的追求。NDK对于一些高性能的功能需求是java层无法比拟的。
 手游的兴起。虚幻4，Unity等引擎开发的手游中都有大量包含游戏逻辑的so库。
  因此，本人调查了一下Android Native Hook工具目前的现状。尽管Java层的Hook工具多种多样，但是Native Hook的工具却非常少并且在安卓5.0以上的适配工具更是寥寥无几。（文末说明1）而目前Native Hook主要有两大技术路线：
 PLT Hook
 Inline Hook
  这两种技术路线本人都实践了一下，关于它们的对比，我在《Android Native Hook技术路线概述》中有介绍，所以这里就不多说了。最终，我用了Inline Hook来做这个项目。
本文篇幅已经较长，因此写了一些独立的学习笔记来对其中的细节问题进行解释：
 《Android Native Hook技术路线概述》
 《Android Inline Hook中的指令修复》
 项目仓库
 项目案例——Arm32
 项目案例——Thumb-2
  目标效果 根据本人自身的使用需求提出了如下几点目标：
 工具运行原理中不能涉及调试目标APP，否则本工具在遇到反调试措施的APP时会失效。尽管可以先去逆向调试patch掉反调试功能，但是对于大多数情况下只是想看看参数和返回值的Hook需求而言，这样的前期处理实在过于麻烦。
 依靠现有的各大Java Hook工具就能运行本工具，换句话说就是最好能用类似这些工具的插件的形式加载起本工具从而获得Native Hook的能力。由于Java Hook工具如Xposed、YAHFA等对于各个版本的Android都做了不错的适配，因此利用这些已有的工具即可向目标APP的Native层中注入我们的Hook功能将会方便很多小伙伴的使用。
 既然要能够让各种Java Hook工具都能用本工具得到Native Hook的能力，那就这个工具就要有被加载起来以后自动执行自身功能逻辑的能力！而不是针对各个Java Hook工具找调用起来的方式。
 要适配Android NDK下的armv7和thumb-2指令集。由于现在默认编译为thumb-2模式，所以对于thumb16和thumb32的Native Hook支持是重中之重。
 修复Inline Hook后的原本指令。
 Hook目标的最小单位至少是函数，最好可以是某行汇编代码。
  最终方案 最后完成项目的方案是：本工具是一个so库。用Java Hook工具在APP的入口Activity运行一开始的onCreate方法处Hook，然后加载本so。 加载后，自动开始执行Hook逻辑。 为了方便叙述，接下来的Java Hook工具我就使用目前这类工具里最流行的Xposed，本项目的生成文件名为libautohook.</description>
    </item>
    
  </channel>
</rss>