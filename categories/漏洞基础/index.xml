<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>漏洞基础 on Vorblock&#39;Blog</title>
    <link>https://naivete.cc/categories/%E6%BC%8F%E6%B4%9E%E5%9F%BA%E7%A1%80/</link>
    <description>Recent content in 漏洞基础 on Vorblock&#39;Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 12 Apr 2019 15:37:31 +0800</lastBuildDate>
    
	<atom:link href="https://naivete.cc/categories/%E6%BC%8F%E6%B4%9E%E5%9F%BA%E7%A1%80/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>漏洞基础之5格式化字符串漏洞(FMT)</title>
      <link>https://naivete.cc/2019/04/12/%E6%BC%8F%E6%B4%9E%E5%9F%BA%E7%A1%80%E4%B9%8B5%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9Efmt/</link>
      <pubDate>Fri, 12 Apr 2019 15:37:31 +0800</pubDate>
      
      <guid>https://naivete.cc/2019/04/12/%E6%BC%8F%E6%B4%9E%E5%9F%BA%E7%A1%80%E4%B9%8B5%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9Efmt/</guid>
      <description></description>
    </item>
    
    <item>
      <title>漏洞基础之4OOB</title>
      <link>https://naivete.cc/2019/03/25/%E6%BC%8F%E6%B4%9E%E5%9F%BA%E7%A1%80%E4%B9%8B4oob/</link>
      <pubDate>Mon, 25 Mar 2019 15:37:23 +0800</pubDate>
      
      <guid>https://naivete.cc/2019/03/25/%E6%BC%8F%E6%B4%9E%E5%9F%BA%E7%A1%80%E4%B9%8B4oob/</guid>
      <description></description>
    </item>
    
    <item>
      <title>漏洞基础之3UAF</title>
      <link>https://naivete.cc/2019/03/20/%E6%BC%8F%E6%B4%9E%E5%9F%BA%E7%A1%80%E4%B9%8B3uaf/</link>
      <pubDate>Wed, 20 Mar 2019 15:37:13 +0800</pubDate>
      
      <guid>https://naivete.cc/2019/03/20/%E6%BC%8F%E6%B4%9E%E5%9F%BA%E7%A1%80%E4%B9%8B3uaf/</guid>
      <description>重写ing
  0x00原理 堆内存在释放后被直接再次使用(释放了堆块之后，未将该指针值为NULL,导致指针处于悬空状态，被释放的内存能被恶意利用) 在浏览器中比较常见的漏洞
根本原因是：
 应用程序调用free()释放内存时，如果内存块小于256kb，dlmalloc并不马上将内存块释放回内存，而是将内存块标记为空闲状态。这么做的原因有两个：一是内存块不一定能马上释放会内核（比如内存块不是位于堆顶端），二是供应用程序下次申请内存使用（这是主要原因）。当dlmalloc中空闲内存量达到一定值时dlmalloc才将空闲内存释放会内核。如果应用程序申请的内存大于256kb，dlmalloc调用mmap()向内核申请一块内存，返回返还给应用程序使用。如果应用程序释放的内存大于256kb，dlmalloc马上调用munmap()释放内存。dlmalloc不会缓存大于256kb的内存块，因为这样的内存块太大了，最好不要长期占用这么大的内存资源。
 利用 简单利用 #include &amp;lt;stdio.h&amp;gt; #include &amp;lt;stdlib.h&amp;gt; typedef void (*func_ptr)(char *); void evil_fuc(char command[]) { system(command); } void echo(char content[]) { printf(&amp;quot;%s&amp;quot;,content); } int main() { func_ptr *p1=(func_ptr*)malloc(4*sizeof(int)); printf(&amp;quot;malloc addr: %p\n&amp;quot;,p1); p1[3]=echo; p1[3](&amp;quot;hello world\n&amp;quot;); free(p1); //在这里free了p1,但并未将p1置空,导致后续可以再使用p1指针 p1[3](&amp;quot;hello again\n&amp;quot;); //p1指针未被置空,虽然free了,但仍可使用. func_ptr *p2=(func_ptr*)malloc(4*sizeof(int));//malloc在free一块内存后,再次申请同样大小的指针会把刚刚释放的内存分配出来. printf(&amp;quot;malloc addr: %p\n&amp;quot;,p2); printf(&amp;quot;malloc addr: %p\n&amp;quot;,p1);//p2与p1指针指向的内存为同一地址 p2[3]=evil_fuc; //在这里将p1指针里面保存的echo函数指针覆盖成为了evil_func指针. p1[3](&amp;quot;/bin/sh&amp;quot;); return 0; }  pwnable.kr uaf 先看看源码：
#include &amp;lt;fcntl.h&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;unistd.</description>
    </item>
    
    <item>
      <title>漏洞基础之2堆溢出</title>
      <link>https://naivete.cc/2019/03/15/%E6%BC%8F%E6%B4%9E%E5%9F%BA%E7%A1%80%E4%B9%8B2%E5%A0%86%E6%BA%A2%E5%87%BA/</link>
      <pubDate>Fri, 15 Mar 2019 15:36:59 +0800</pubDate>
      
      <guid>https://naivete.cc/2019/03/15/%E6%BC%8F%E6%B4%9E%E5%9F%BA%E7%A1%80%E4%B9%8B2%E5%A0%86%E6%BA%A2%E5%87%BA/</guid>
      <description></description>
    </item>
    
    <item>
      <title>漏洞基础之1栈溢出</title>
      <link>https://naivete.cc/2019/03/10/%E6%BC%8F%E6%B4%9E%E5%9F%BA%E7%A1%80%E4%B9%8B1%E6%A0%88%E6%BA%A2%E5%87%BA/</link>
      <pubDate>Sun, 10 Mar 2019 15:36:49 +0800</pubDate>
      
      <guid>https://naivete.cc/2019/03/10/%E6%BC%8F%E6%B4%9E%E5%9F%BA%E7%A1%80%E4%B9%8B1%E6%A0%88%E6%BA%A2%E5%87%BA/</guid>
      <description></description>
    </item>
    
  </channel>
</rss>